<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Vts</name>
    </assembly>
    <members>
        <member name="T:Vts.BindableObject">
            <summary>
            Implements the INotifyPropertyChangedPlus interface and 
            exposes a RaisePropertyChanged method for derived 
            classes to raise the PropertyChange event.  The event 
            arguments created by this class are cached to prevent 
            managed heap fragmentation.
            
            Adapted from Josh Smith's post:
            http://joshsmithonwpf.wordpress.com/2007/08/29/a-base-class-which-implements-inotifypropertychanged/
            
            Added SetProperty method to simplify set operations.
            Modified "RaisePropertyChanged" to "OnPropertyChanged"
            to work with INotifyPropertyChangedPlus, enabling
            compatibility with the DependsOn attribute and
            PropertyDependencyManager class.
            </summary>
        </member>
        <member name="M:Vts.BindableObject.#ctor">
            <summary>
            default constructor, protected version
            </summary>
        </member>
        <member name="E:Vts.BindableObject.PropertyChanged">
            <summary>
            Raised when a public property of this object is set.
            </summary>
        </member>
        <member name="M:Vts.BindableObject.GetPropertyChangedEventArgs(System.String)">
            <summary>
            Returns an instance of PropertyChangedEventArgs for 
            the specified property name.
            </summary>
            <param name="propertyName">
            The name of the property to create event args for.
            </param>		
        </member>
        <member name="M:Vts.BindableObject.AfterPropertyChanged(System.String)">
            <summary>
            Derived classes can override this method to
            execute logic after a property is set. The 
            base implementation does nothing.
            </summary>
            <param name="propertyName">
            The property which was changed.
            </param>
        </member>
        <member name="M:Vts.BindableObject.OnPropertyChanged(System.String)">
            <summary>
            Attempts to raise the PropertyChanged event, and 
            invokes the virtual AfterPropertyChanged method, 
            regardless of whether the event was raised or not.
            </summary>
            <param name="propertyName">The property which was changed</param>
        </member>
        <member name="T:Vts.BindableObjectWithChangeTracking">
            <summary>
            Adds change tracking to a bindable object class
            </summary>
        </member>
        <member name="F:Vts.BindableObjectWithChangeTracking.originalValues">
            <summary>
            Holds the "original" values to monitor if values have changed 
            </summary>
        </member>
        <member name="P:Vts.BindableObjectWithChangeTracking.SettingsChanged">
            <summary>
            Specifies if anything in the class (that's being monitored) has changed
            </summary>
        </member>
        <member name="M:Vts.BindableObjectWithChangeTracking.Reset">
            <summary>
            Reset all changes once they have been handled
            </summary>
        </member>
        <member name="M:Vts.BindableObjectWithChangeTracking.SetProperty``1(System.String,``0@,``0@)">
            <summary>
            Helper method to consolidate set operations
            </summary>
            <typeparam name="T">The type of the property</typeparam>
            <param name="propertyName">The property name</param>
            <param name="parameter">the parameter value</param>
            <param name="value">The new value</param>
        </member>
        <member name="M:Vts.BindableObjectWithChangeTracking.HandleChangeTracking``1(System.String,``0@,``0@)">
            <summary>
            Method to handle change tracking
            </summary>
            <typeparam name="T">The type of the property</typeparam>
            <param name="propertyName">The property name</param>
            <param name="parameter">not used - need to remove</param>
            <param name="value">The property value</param>
        </member>
        <member name="T:Vts.DependsOnAttribute">
            <summary>
            This is an attribute that when applied to a property will create a dependency for
            when that property changes. The DependsOn attribute contains no logic, just a list
            of dependencies. It is used by the PropertyDependencyManager to determine if a
            property has changed due to a change in a dependent property.
            Usage:
            [DependsOn("Second", third)]
            public int First { get; set; }
            </summary>
        </member>
        <member name="M:Vts.DependsOnAttribute.#ctor(System.String[])">
            <summary>
            Takes a string of properties that the property depends upon
            </summary>
            <param name="properties"></param>
        </member>
        <member name="P:Vts.DependsOnAttribute.Properties">
            <summary>
            The list of properties with dependencies
            </summary>
        </member>
        <member name="T:Vts.Common.Direction">
            <summary>
            Class describes unit directional vector.
            </summary>
        </member>
        <member name="M:Vts.Common.Direction.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            constructor for direction, passes x, y and z values
            </summary>
            <param name="ux">x direction</param>
            <param name="uy">y direction</param>
            <param name="uz">z direction</param>
        </member>
        <member name="M:Vts.Common.Direction.#ctor">
            <summary>
            default constructor for direction (0,0,1)
            </summary>
        </member>
        <member name="P:Vts.Common.Direction.Ux">
            <summary>
            x direction
            </summary>
        </member>
        <member name="P:Vts.Common.Direction.Uy">
            <summary>
            y direction
            </summary>
        </member>
        <member name="P:Vts.Common.Direction.Uz">
            <summary>
            z direction
            </summary>
        </member>
        <member name="M:Vts.Common.Direction.op_Equality(Vts.Common.Direction,Vts.Common.Direction)">
            <summary>
            Equality overload for two 3D direction cosines
            </summary>
            <param name="d1">first direction cosine</param>
            <param name="d2">second direction cosine</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Direction.op_Inequality(Vts.Common.Direction,Vts.Common.Direction)">
            <summary>
            Inequality overload for two 3D direction cosines
            </summary>
            <param name="d1">first direction cosine</param>
            <param name="d2">second direction cosine</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Direction.Equals(System.Object)">
            <summary>
            Instance member for equality comparison
            </summary>
            <param name="obj">object of comparision</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Direction.GetDotProduct(Vts.Common.Direction,Vts.Common.Direction)">
            <summary>
            Method to determine dot product between two unit directionals.
            </summary>
            <param name="d1">first direction</param>
            <param name="d2">second direction</param>
            <returns>the dot product</returns>
        </member>
        <member name="M:Vts.Common.Direction.WriteBinary(System.IO.BinaryWriter)">
            <summary>
            Method to write binary version of unit directional
            </summary>
            <param name="bw"></param>
        </member>
        <member name="M:Vts.Common.Direction.ReadBinary(System.IO.BinaryReader)">
            <summary>
            Method to read binary version of unit directional
            </summary>
            <param name="br">BinaryReader</param>
            <returns>a direction</returns>
        </member>
        <member name="P:Vts.Common.Direction.AlongPositiveXAxis">
            <summary>
            Method that returns unit directional along positive x-axis
            </summary>
        </member>
        <member name="P:Vts.Common.Direction.AlongPositiveYAxis">
            <summary>
            Method that returns unit directional along positive y-axis
            </summary>
        </member>
        <member name="P:Vts.Common.Direction.AlongPositiveZAxis">
            <summary>
            Method that returns unit directional along positive z-axis
            </summary>
        </member>
        <member name="P:Vts.Common.Direction.AlongNegativeXAxis">
            <summary>
            Method that returns unit directional along positive x-axis
            </summary>
        </member>
        <member name="P:Vts.Common.Direction.AlongNegativeYAxis">
            <summary>
            Method that returns unit directional along positive y-axis
            </summary>
        </member>
        <member name="P:Vts.Common.Direction.AlongNegativeZAxis">
            <summary>
            Method that returns unit directional along positive z-axis
            </summary>
        </member>
        <member name="M:Vts.Common.Direction.Clone">
            <summary>
            Method to clone unit directional
            </summary>
            <returns>a direction</returns>
        </member>
        <member name="M:Vts.Common.Direction.GetHashCode">
            <summary>
            Override of GetHashCode to allow the type to work correctly in a hash table
            </summary>
            <returns>The hashcode as an integer</returns>
        </member>
        <member name="T:Vts.Common.DoubleRange">
            <summary>
            Class that specifies a range of doubles
            </summary>
        </member>
        <member name="M:Vts.Common.DoubleRange.#ctor(System.Double,System.Double,System.Int32)">
            <summary>
            Defines the double range
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
            <param name="number">The The number of values in the range, inclusive of the endpoints</param>
        </member>
        <member name="M:Vts.Common.DoubleRange.#ctor(System.Double,System.Double)">
            <summary>
            Defines a double range with a count of 2
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
        </member>
        <member name="M:Vts.Common.DoubleRange.#ctor">
            <summary>
            Defines a double range starting from 0 to 1 with a count of 2
            </summary>
        </member>
        <member name="M:Vts.Common.DoubleRange.GetDelta">
            <summary>
            Returns the value for delta
            </summary>
            <returns>A double representing delta</returns>
        </member>
        <member name="M:Vts.Common.DoubleRange.GetIncrement">
            <summary>
            Returns the increment
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.DoubleRange.Clone">
            <summary>
            Clones the double range
            </summary>
            <returns>A new DoubleRange</returns>
        </member>
        <member name="T:Vts.Common.FloatRange">
            <summary>
            Class that specifies a range of floating-point values
            </summary>
        </member>
        <member name="M:Vts.Common.FloatRange.#ctor(System.Single,System.Single,System.Int32)">
            <summary>
            Defines the range of floats
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
            <param name="number">The number of values in the range, inclusive of the endpoints</param>
        </member>
        <member name="M:Vts.Common.FloatRange.#ctor(System.Single,System.Single)">
            <summary>
            Defines a range of floats with a count of 2
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
        </member>
        <member name="M:Vts.Common.FloatRange.#ctor">
            <summary>
            Defines a range of floats from 0 to 1 with a count of 2
            </summary>
        </member>
        <member name="M:Vts.Common.FloatRange.GetDelta">
            <summary>
            Returns the value for delta
            </summary>
            <returns>A float representing delta</returns>
        </member>
        <member name="M:Vts.Common.FloatRange.GetIncrement">
            <summary>
            Returns the increment
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.FloatRange.Clone">
            <summary>
            Clones the range of floats
            </summary>
            <returns>A new FloatRange</returns>
        </member>
        <member name="T:Vts.Common.IntRange">
            <summary>
            Class that specifies a range of integers
            </summary>
        </member>
        <member name="M:Vts.Common.IntRange.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Defines the range of integers
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
            <param name="number">The The number of values in the range, inclusive of the endpoints</param>
        </member>
        <member name="M:Vts.Common.IntRange.#ctor(System.Int32,System.Int32)">
            <summary>
            Defines a range of integers with a count of (stop - start) + 1
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
        </member>
        <member name="M:Vts.Common.IntRange.#ctor">
            <summary>
            Defines a range of integers from 0 to 1 with a count of 2
            </summary>
        </member>
        <member name="M:Vts.Common.IntRange.GetDelta">
            <summary>
            Returns the value for delta
            </summary>
            <returns>An integer representing delta</returns>
        </member>
        <member name="M:Vts.Common.IntRange.GetIncrement">
            <summary>
            Returns the increment
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.IntRange.Clone">
            <summary>
            Clones the range of integers
            </summary>
            <returns>A new IntRange</returns>
        </member>
        <member name="T:Vts.Common.LongRange">
            <summary>
            Class that specifies a range of long variables
            </summary>
        </member>
        <member name="M:Vts.Common.LongRange.#ctor(System.Int64,System.Int64,System.Int32)">
            <summary>
            Defines the range of long variables
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
            <param name="number">The The number of values in the range, inclusive of the endpoints</param>
        </member>
        <member name="M:Vts.Common.LongRange.#ctor(System.Int64,System.Int64)">
            <summary>
            Defines a range of long variables with a count of (stop - start) + 1
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
        </member>
        <member name="M:Vts.Common.LongRange.#ctor">
            <summary>
            Defines a range of long variables from 0 to 1 with a count of 2
            </summary>
        </member>
        <member name="M:Vts.Common.LongRange.GetDelta">
            <summary>
            Returns the value for delta
            </summary>
            <returns>A long representing delta</returns>
        </member>
        <member name="M:Vts.Common.LongRange.GetIncrement">
            <summary>
            Returns the increment
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.LongRange.Clone">
            <summary>
            Clones the range of long variables
            </summary>
            <returns>A new LongRange</returns>
        </member>
        <member name="T:Vts.Common.UIntRange">
            <summary>
            Class that specifies a range of unsigned integers
            </summary>
        </member>
        <member name="M:Vts.Common.UIntRange.#ctor(System.UInt32,System.UInt32,System.Int32)">
            <summary>
            Defines the range of unsigned integers
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
            <param name="number">The The number of values in the range, inclusive of the endpoints</param>
        </member>
        <member name="M:Vts.Common.UIntRange.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Defines a range of unsigned integers with a count of (stop - start) + 1
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
        </member>
        <member name="M:Vts.Common.UIntRange.#ctor">
            <summary>
            Defines a range of unsigned integers from 0 to 1 with a count of 2
            </summary>
        </member>
        <member name="M:Vts.Common.UIntRange.GetDelta">
            <summary>
            Returns the value for delta
            </summary>
            <returns>An unsigned integer representing delta</returns>
        </member>
        <member name="M:Vts.Common.UIntRange.GetIncrement">
            <summary>
            Returns the increment
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.UIntRange.Clone">
            <summary>
            Clones the range of unsigned integers
            </summary>
            <returns>A new UIntRange</returns>
        </member>
        <member name="T:Vts.Common.LayerOpticalPropertyRegion">
            <summary>
            class for layer region optical properties
            </summary>
        </member>
        <member name="M:Vts.Common.LayerOpticalPropertyRegion.#ctor(Vts.Common.DoubleRange,Vts.OpticalProperties)">
            <summary>
            Create an instance of LayerOpticalPropertyRegion
            </summary>
            <param name="regionOP"></param>
            <param name="zRange"></param>
        </member>
        <member name="P:Vts.Common.LayerOpticalPropertyRegion.RegionOP">
            <summary>
            Optical properties of tissue region.
            </summary>
        </member>
        <member name="P:Vts.Common.LayerOpticalPropertyRegion.ZRange">
            <summary>
            extent of z layer
            </summary>
        </member>
        <member name="T:Vts.Common.Logging.AbstractLoggerFactory">
            <summary>
            factory methods for logger
            </summary>
        </member>
        <member name="M:Vts.Common.Logging.AbstractLoggerFactory.Create(System.Type)">
            <summary>
            method to create logger given type
            </summary>
            <param name="type">type</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Logging.AbstractLoggerFactory.Create(System.Type,Vts.Common.Logging.LoggerLevel)">
            <summary>
            method to create logger given type and logger level
            </summary>
            <param name="type">type</param>
            <param name="level">logger level</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Logging.AbstractLoggerFactory.Create(System.String)">
            <summary>
            method to create logger given name
            </summary>
            <param name="name">name string</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Logging.AbstractLoggerFactory.Create(System.String,Vts.Common.Logging.LoggerLevel)">
            <summary>
            method to create logger given name and logger level
            </summary>
            <param name="name">name string</param>
            <param name="level">LoggerLevel</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Logging.AbstractLoggerFactory.GetConfigFile(System.String)">
            <summary>
              Gets the configuration file.
            </summary>
            <param name = "fileName">i.e. log4net.config</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Common.Logging.ILogger">
            <summary>
              Manages logging.
            </summary>
            <remarks>
              This is a facade for the different logging subsystems.
              It offers a simplified interface that follows IOC patterns
              and a simplified priority/level/severity abstraction.
            </remarks>
        </member>
        <member name="P:Vts.Common.Logging.ILogger.IsDebugEnabled">
            <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
            <value>True if "debug" messages will be logged.</value>
        </member>
        <member name="P:Vts.Common.Logging.ILogger.IsErrorEnabled">
            <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
            <value>True if "error" messages will be logged.</value>
        </member>
        <member name="P:Vts.Common.Logging.ILogger.IsFatalEnabled">
            <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
            <value>True if "fatal" messages will be logged.</value>
        </member>
        <member name="P:Vts.Common.Logging.ILogger.IsInfoEnabled">
            <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
            <value>True if "info" messages will be logged.</value>
        </member>
        <member name="P:Vts.Common.Logging.ILogger.IsWarnEnabled">
            <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
            <value>True if "warn" messages will be logged.</value>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.CreateChildLogger(System.String)">
            <summary>
              Create a new child logger.
              The name of the child logger is [current-loggers-name].[passed-in-name]
            </summary>
            <param name = "loggerName">The Subname of this logger.</param>
            <returns>The New ILogger instance.</returns>
            <exception cref = "T:System.ArgumentException">If the name has an empty element name.</exception>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Debug(System.String)">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Debug(System.Func{System.String})">
            <summary>
              Logs a debug message with lazily constructed message. The message will be constructed only if the <see cref = "P:Vts.Common.Logging.ILogger.IsDebugEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Debug(System.String,System.Exception)">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.DebugFormat(System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Error(System.String)">
            <summary>
              Logs an error message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Error(System.Func{System.String})">
            <summary>
              Logs an error message with lazily constructed message. The message will be constructed only if the <see cref = "P:Vts.Common.Logging.ILogger.IsErrorEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Error(System.String,System.Exception)">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.ErrorFormat(System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Fatal(System.String)">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Fatal(System.Func{System.String})">
            <summary>
              Logs a fatal message with lazily constructed message. The message will be constructed only if the <see cref = "P:Vts.Common.Logging.ILogger.IsFatalEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Fatal(System.String,System.Exception)">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.FatalFormat(System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Info(System.String)">
            <summary>
              Logs an info message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Info(System.Func{System.String})">
            <summary>
              Logs a info message with lazily constructed message. The message will be constructed only if the <see cref = "P:Vts.Common.Logging.ILogger.IsInfoEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Info(System.String,System.Exception)">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.InfoFormat(System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Warn(System.String)">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Warn(System.Func{System.String})">
            <summary>
              Logs a warn message with lazily constructed message. The message will be constructed only if the <see cref = "P:Vts.Common.Logging.ILogger.IsWarnEnabled" /> is true.
            </summary>
            <param name = "messageFactory"></param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.Warn(System.String,System.Exception)">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.WarnFormat(System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.ILogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="T:Vts.Common.Logging.ILoggerFactory">
            <summary>
              Manages the instantiation of <see cref = "T:Vts.Common.Logging.ILogger" />s.
            </summary>
        </member>
        <member name="M:Vts.Common.Logging.ILoggerFactory.Create(System.Type)">
            <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Vts.Common.Logging.ILoggerFactory.Create(System.String)">
            <summary>
              Creates a new logger.
            </summary>
        </member>
        <member name="M:Vts.Common.Logging.ILoggerFactory.Create(System.Type,Vts.Common.Logging.LoggerLevel)">
            <summary>
              Creates a new logger, getting the logger name from the specified type.
            </summary>
        </member>
        <member name="M:Vts.Common.Logging.ILoggerFactory.Create(System.String,Vts.Common.Logging.LoggerLevel)">
            <summary>
              Creates a new logger.
            </summary>
        </member>
        <member name="T:Vts.Common.Logging.LoggerFactoryLocator">
            <summary>
            Represents a global service locator for singleton instances of ILoggerFactory
            </summary>
        </member>
        <member name="F:Vts.Common.Logging.LoggerFactoryLocator._loggerFactories">
            <summary>
            Internal dictionary to store singleton instances of ILoggerFactory
            </summary>
        </member>
        <member name="M:Vts.Common.Logging.LoggerFactoryLocator.GetNLogFactory(System.String)">
            <summary>
            Returns a singleton instance of an NLogFactcory
            </summary>
            <param name="loggerName"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Logging.LoggerFactoryLocator.GetDefaultNLogFactory">
            <summary>
            Returns a default singleton instance of an NLogFactcory
            </summary>
            <returns></returns>
        </member>
        <member name="T:Vts.Common.Logging.LoggerLevel">
            <summary>
              Supporting Logger levels.
            </summary>
        </member>
        <member name="F:Vts.Common.Logging.LoggerLevel.Off">
            <summary>
              Logging will be off
            </summary>
        </member>
        <member name="F:Vts.Common.Logging.LoggerLevel.Fatal">
            <summary>
              Fatal logging level
            </summary>
        </member>
        <member name="F:Vts.Common.Logging.LoggerLevel.Error">
            <summary>
              Error logging level
            </summary>
        </member>
        <member name="F:Vts.Common.Logging.LoggerLevel.Warn">
            <summary>
              Warn logging level
            </summary>
        </member>
        <member name="F:Vts.Common.Logging.LoggerLevel.Info">
            <summary>
              Info logging level
            </summary>
        </member>
        <member name="F:Vts.Common.Logging.LoggerLevel.Debug">
            <summary>
              Debug logging level
            </summary>
        </member>
        <member name="T:Vts.Common.Logging.NLogIntegration.NLogFactory">
            <summary>
              Implementation of <see cref = "T:Vts.Common.Logging.ILoggerFactory" /> for NLog.
            </summary>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogFactory.#ctor">
            <summary>
              Initializes a new instance of the <see cref = "T:Vts.Common.Logging.NLogIntegration.NLogFactory" /> class.
            </summary>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogFactory.#ctor(System.String)">
            <summary>
              Initializes a new instance of the <see cref = "T:Vts.Common.Logging.NLogIntegration.NLogFactory" /> class.
            </summary>
            <param name = "configFile">The config file.</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogFactory.Create(System.String)">
            <summary>
              Creates a logger with specified <paramref name = "name" />.
            </summary>
            <param name = "name">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogFactory.Create(System.String,Vts.Common.Logging.LoggerLevel)">
            <summary>
              Not implemented, NLog logger levels cannot be set at runtime.
            </summary>
            <param name = "name">The name.</param>
            <param name = "level">The level.</param>
            <returns></returns>
            <exception cref = "T:System.NotImplementedException" />
        </member>
        <member name="T:Vts.Common.Logging.NLogIntegration.NLogLogger">
            <summary>
              Implementation of <see cref = "T:Vts.Common.Logging.ILogger" /> for NLog.
            </summary>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.#ctor(NLog.Logger,Vts.Common.Logging.NLogIntegration.NLogFactory)">
            <summary>
              Initializes a new instance of the <see cref = "T:Vts.Common.Logging.NLogIntegration.NLogLogger" /> class.
            </summary>
            <param name = "logger">The logger.</param>
            <param name = "factory">The factory.</param>
        </member>
        <member name="P:Vts.Common.Logging.NLogIntegration.NLogLogger.IsDebugEnabled">
            <summary>
              Determines if messages of priority "debug" will be logged.
            </summary>
            <value>True if "debug" messages will be logged.</value>
        </member>
        <member name="P:Vts.Common.Logging.NLogIntegration.NLogLogger.IsErrorEnabled">
            <summary>
              Determines if messages of priority "error" will be logged.
            </summary>
            <value><c>true</c> if "error" messages will be logged, <c>false</c> otherwise</value>
        </member>
        <member name="P:Vts.Common.Logging.NLogIntegration.NLogLogger.IsFatalEnabled">
            <summary>
              Determines if messages of priority "fatal" will be logged.
            </summary>
            <value><c>true</c> if "fatal" messages will be logged, <c>false</c> otherwise</value>
        </member>
        <member name="P:Vts.Common.Logging.NLogIntegration.NLogLogger.IsInfoEnabled">
            <summary>
              Determines if messages of priority "info" will be logged.
            </summary>
            <value><c>true</c> if "info" messages will be logged, <c>false</c> otherwise</value>
        </member>
        <member name="P:Vts.Common.Logging.NLogIntegration.NLogLogger.IsWarnEnabled">
            <summary>
              Determines if messages of priority "warn" will be logged.
            </summary>
            <value><c>true</c> if "warn" messages will be logged, <c>false</c> otherwise</value>
        </member>
        <member name="P:Vts.Common.Logging.NLogIntegration.NLogLogger.Factory">
            <summary>
              Gets or sets the factory.
            </summary>
            <value>The factory.</value>
        </member>
        <member name="P:Vts.Common.Logging.NLogIntegration.NLogLogger.Logger">
            <summary>
              Gets or sets the logger.
            </summary>
            <value>The logger.</value>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.ToString">
            <summary>
              Returns a <see cref = "T:System.String" /> that represents this instance.
            </summary>
            <returns>
              A <see cref = "T:System.String" /> that represents this instance.
            </returns>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.CreateChildLogger(System.String)">
            <summary>
              Creates a child logger with the specied <paramref name = "loggerName" />.
            </summary>
            <param name = "loggerName">The name.</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Debug(System.String)">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Debug(System.Func{System.String})">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "messageFactory">Factory constructing lazily the message to log if the level is enabled</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Debug(System.String,System.Exception)">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.DebugFormat(System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.DebugFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.DebugFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.DebugFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a debug message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Error(System.String)">
            <summary>
              Logs an error message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Error(System.Func{System.String})">
            <summary>
              Logs an error message.
            </summary>
            <param name = "messageFactory">Factory constructing lazily the message to log if the level is enabled</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Error(System.String,System.Exception)">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.ErrorFormat(System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.ErrorFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.ErrorFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.ErrorFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an error message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Fatal(System.String)">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Fatal(System.Func{System.String})">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "messageFactory">Factory constructing lazily the message to log if the level is enabled</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Fatal(System.String,System.Exception)">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.FatalFormat(System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.FatalFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.FatalFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.FatalFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a fatal message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Info(System.String)">
            <summary>
              Logs an info message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Info(System.Func{System.String})">
            <summary>
              Logs a info message.
            </summary>
            <param name = "messageFactory">Factory constructing lazily the message to log if the level is enabled</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Info(System.String,System.Exception)">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.InfoFormat(System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.InfoFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.InfoFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.InfoFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs an info message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Warn(System.String)">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Warn(System.Func{System.String})">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "messageFactory">Factory constructing lazily the message to log if the level is enabled</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.Warn(System.String,System.Exception)">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "message">The message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.WarnFormat(System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.WarnFormat(System.Exception,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.WarnFormat(System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="M:Vts.Common.Logging.NLogIntegration.NLogLogger.WarnFormat(System.Exception,System.IFormatProvider,System.String,System.Object[])">
            <summary>
              Logs a warn message.
            </summary>
            <param name = "exception">The exception to log</param>
            <param name = "formatProvider">The format provider to use</param>
            <param name = "format">Format string for the message to log</param>
            <param name = "args">Format arguments for the message to log</param>
        </member>
        <member name="T:Vts.Common.Logging.ObservableTarget">
            <summary>
            Writes log messages to an ArrayList in memory for programmatic retrieval.
            </summary>
            <seealso href="http://nlog-project.org/wiki/Memory_target">Documentation on NLog Wiki</seealso>
        </member>
        <member name="M:Vts.Common.Logging.ObservableTarget.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:NLog.Targets.MemoryTarget" /> class.
            </summary>
            <remarks>
            The default value of the layout is: <code>${longdate}|${level:uppercase=true}|${logger}|${message}</code>
            </remarks>
        </member>
        <member name="P:Vts.Common.Logging.ObservableTarget.Logs">
            <summary>
            Gets the list of logs gathered in the <see cref="T:NLog.Targets.MemoryTarget"/>.
            </summary>
        </member>
        <member name="M:Vts.Common.Logging.ObservableTarget.Write(NLog.LogEventInfo)">
            <summary>
            Renders the logging event message and adds it to the internal ArrayList of log messages.
            </summary>
            <param name="logEvent">The logging event.</param>
        </member>
        <member name="M:Vts.Common.Logging.ObservableTarget.Subscribe(System.IObserver{System.String})">
            <summary>
            method to subscribe to IObserver
            </summary>
            <param name="observer">IObersver</param>
            <returns>IDisposable</returns>
        </member>
        <member name="T:Vts.Common.Math.Convert">
            <summary>
            Conversion utilities
            </summary>
        </member>
        <member name="M:Vts.Common.Math.Convert.ToPhase(System.Double,System.Double)">
            <summary>
            method determines the phase given real and imag values
            </summary>
        </member>
        <member name="M:Vts.Common.Math.Convert.ToPhase(System.Double[],System.Double[])">
            <summary>
            method determines the phase given real and imag arrays
            </summary>
        </member>
        <member name="M:Vts.Common.Math.Convert.ToAmplitude(System.Double,System.Double)">
            <summary>
            method determines the amplitude given real and imag values
            </summary>
        </member>
        <member name="M:Vts.Common.Math.Convert.ToAmplitude(System.Double[],System.Double[])">
            <summary>
            method determines the amplitude given real and imag arrays
            </summary>
        </member>
        <member name="T:Vts.Common.Math.Convolution2D">
            <summary>
            Class containing the 'Roll' Algorithm, Custom Integration based off Tom, et al, curtesy of Owen Yang, David Cuccia, and Bernard Choi, 
            "Real-time blood flow imaging using the graphics processing unit," (paper in preparation)
            </summary>
        </member>
        <member name="M:Vts.Common.Math.Convolution2D.LsiRoll(System.Int32[],System.Single[],System.Single[],System.Int32[],System.Int32[],System.Int32[],System.Int32[],System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
            'Roll' Algorithm, Custom Integration based off Tom, et al, curtesy of Owen Yang
            Owen Yang, David Cuccia, and Bernard Choi, "Real-time blood flow imaging using the
            graphics processing unit," (paper in preparation)
            </summary>
            <param name="raw">Raw speckle image</param>
            <param name="speckleContrast">Speckle contrast, preallocated 1D matrix</param>
            <param name="speckleFlowIndex">Speckle flow index, preallocated 1D matrix</param>
            <param name="rollRow">Preallocated buffer for holding the strip sum in the row</param>
            <param name="rollColumn">Preallocated buffer for holding the strip sum in the column</param>
            <param name="rollRowSquared">Preallocated buffer for holding the strip sums of squared values in the row</param>
            <param name="rollColumnSquared">Preallocated buffer for holding the strip sums of squared values in the row</param>
            <param name="width">Width of the raw speckle image. Also used for calculating the size of the preallocated buffers, the 4 buffers are width*1</param>
            <param name="height">Height of the raw speckle image</param>
            <param name="wR">Size of the sliding window radius</param>
            <param name="t">Exposure time of the camera used to obtain the raw speckle images</param>
        </member>
        <member name="M:Vts.Common.Math.Convolution2D.RollFilter(System.Single[],System.Int32,System.Int32,System.Int32,System.Single[]@,System.Single[]@,System.Single[]@)">
            <summary>
            'Roll' Algorithm, Custom Integration based off Tom, et al, curtesy of Owen Yang.
            Owen Yang, David Cuccia, and Bernard Choi, "Real-time blood flow imaging using the
            graphics processing unit," (paper in preparation)
            </summary>
            <param name="raw">raw image</param>
            <param name="width">image width</param>
            <param name="height">image height</param>
            <param name="radius">radius of moving window (full window size will be 2*radius+1)</param>
            <param name="processed">pre-allocated processed image destination</param>
            <param name="rollRow">pre-allocated row strip sum</param>
            <param name="rollColumn">pre-allocated column strip sum</param>
        </member>
        <member name="M:Vts.Common.Math.Convolution2D.RollFilter(System.Single[],System.Int32,System.Int32,System.Int32,System.Single[]@)">
            <summary>
            'Roll' Algorithm, Custom Integration based off Tom, et al, curtesy of Owen Yang.
            Owen Yang, David Cuccia, and Bernard Choi, "Real-time blood flow imaging using the
            graphics processing unit," (paper in preparation)
            </summary>
            <param name="raw">raw image</param>
            <param name="width">image width</param>
            <param name="height">image height</param>
            <param name="radius">radius of moving window (full window size will be 2*radius+1)</param>
            <param name="processed">pre-allocated processed image destination</param>
            <remarks>Allocates row and column strip sums and calls the most general overload</remarks>
        </member>
        <member name="M:Vts.Common.Math.Convolution2D.RollFilter(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            'Roll' Algorithm, Custom Integration based off Tom, et al, curtesy of Owen Yang.
            Owen Yang, David Cuccia, and Bernard Choi, "Real-time blood flow imaging using the
            graphics processing unit," (paper in preparation)
            </summary>
            <param name="raw">raw image</param>
            <param name="width">image width</param>
            <param name="height">image height</param>
            <param name="radius">radius of moving window (full window size will be 2*radius+1)</param>
            <returns>processed image</returns>
            <remarks>Allocates processed image, as well as row and column strip sums and calls the most 
            general overload. Calling this version multiple times with large images will probably thrash the GC.</remarks>
        </member>
        <member name="T:Vts.Common.Math.Integration">
            <summary>
            numerical methods to integrate a function
            </summary>
        </member>
        <member name="M:Vts.Common.Math.Integration.IntegrateAdaptiveSimpsonRule(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double)">
            <summary>
            Integration in one dimension
            </summary>
            <param name="f">Function to integrate</param>
            <param name="a">Lower limit of integration</param>
            <param name="b">Upper limit of integration</param>
            <param name="epsilon">Accuracy required)</param>
            
        </member>
        <member name="M:Vts.Common.Math.Integration.IntegrateSimpsonRule(System.Func{System.Double,System.Double},System.Double,System.Double)">
            <summary>
            method to integrate function using Simpson's Rule
            </summary>
            <param name="f">function to integrate</param>
            <param name="a">Lower limit of integration</param>
            <param name="b">Upper limit of integration</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Math.Integration.AdaptiveRecursiveSimpson(System.Func{System.Double,System.Double},System.Double,System.Double,System.Double,System.Double)">
            <summary>
            adaptive recursive Simpson's rule
            </summary>
            <param name="f">function to integrate</param>
            <param name="a">lower bound of integration interval</param>
            <param name="b">upper bound of integration interval</param>
            <param name="epsilon">precision</param>
            <param name="sum"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.Common.Math.Interpolation">
            <summary>
            Provides methods for interpolation of data in 1D and 2D
            </summary>
        </member>
        <member name="M:Vts.Common.Math.Interpolation.interp1(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Double)">
            <summary>
            Interpolation in one dimension (assumes x are monotonically increasing)
            </summary>
            <param name="x">The known dependent values</param>
            <param name="y">The known independent values</param>
            <param name="xi">Value to at which to interpolate</param>
            <returns>If xi outside range of x, returns NaN,
                otherwide, returns linearly interpolated result</returns>
        </member>
        <member name="M:Vts.Common.Math.Interpolation.interp1(System.Collections.Generic.IList{System.Single},System.Collections.Generic.IList{System.Single},System.Single)">
            <summary>
            Interpolation in one dimension (assumes x are monotonically increasing)
            </summary>
            <param name="x">The known dependent values</param>
            <param name="y">The known independent values</param>
            <param name="xi">Value to at which to interpolate</param>
            <returns>If xi outside range of x, returns NaN,
                otherwide, returns linearly interpolated result</returns>
        </member>
        <member name="M:Vts.Common.Math.Interpolation.interp1(System.Collections.Generic.IList{System.Double},System.Double[0:,0:],System.Double,System.Int32,System.Int32)">
            <summary>
            Interpolation in one dimension (assumes x are monotonically increasing) of 2D array 
            over either 1st or 2nd dimension with fixed index in other dimension 
            </summary>
            <param name="x">The known dependent values</param>
            <param name="y">The known independent values</param>
            <param name="xi">Value to at which to interpolate</param>
            <param name="fixedDimension">Dimension of 2D array to keep fixed</param>
            <param name="fixedIndex">Fixed index of dim</param>
            <returns>The interpolated value (clamped to boundary values if xi are of range)</returns>
        </member>
        <member name="M:Vts.Common.Math.Interpolation.interp1(System.Collections.Generic.IList{System.Single},System.Single[0:,0:],System.Single,System.Int32,System.Int32)">
            <summary>
            Interpolation in one dimension (assumes x are monotonically increasing) of 2D array 
            over either 1st or 2nd dimension with fixed index in other dimension 
            </summary>
            <param name="x">The known dependent values</param>
            <param name="y">The known independent values</param>
            <param name="xi">Value to at which to interpolate</param>
            <param name="fixedDimension">Dimension of 2D array to keep fixed</param>
            <param name="fixedIndex">Fixed index of dim</param>
            <returns>The interpolated value (clamped to boundary values if xi are of range)</returns>
        </member>
        <member name="M:Vts.Common.Math.Interpolation.interp1(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Interpolation in one dimension (assumes x are monotonically increasing)
            </summary>
            <param name="x">The known independent values</param>
            <param name="y">The known dependent values</param>
            <param name="xs">Value to at which to interpolate</param>
            <returns>If xs outside range of x, returns NaN,
                otherwise, returns linearly interpolated result</returns>
        </member>
        <member name="M:Vts.Common.Math.Interpolation.interp1(System.Collections.Generic.IList{System.Single},System.Collections.Generic.IList{System.Single},System.Collections.Generic.IEnumerable{System.Single})">
            <summary>
            Interpolation in one dimension (assumes x are monotonically increasing)
            </summary>
            <param name="x">The known independent values</param>
            <param name="y">The known dependent values</param>
            <param name="xs">Value to at which to interpolate</param>
            <returns>If xs outside range of x, returns NaN,
                otherwide, returns linearly interpolated result as an IEnumerable of type float</returns>
        </member>
        <member name="M:Vts.Common.Math.Interpolation.interp1(System.Collections.Generic.IList{System.Double},System.Double[0:,0:],System.Collections.Generic.IEnumerable{System.Double},System.Int32,System.Int32)">
            <summary>
            Interpolation in one dimension within a 2-dimensional array of values
            </summary>
            <param name="x">The known independent value</param>
            <param name="y">The known dependent value</param>
            <param name="xs">Value to at which to interpolate</param>
            <param name="fixedDimension">The dimension of y in which to interpolate</param>
            <param name="fixedIndex">The index within the dimension of y in which to interpolate</param>
            <returns>If xs outside range of x, returns NaN,
                otherwide, returns linearly interpolated result as an IEnumerable of type double</returns>
        </member>
        <member name="M:Vts.Common.Math.Interpolation.interp1(System.Collections.Generic.IList{System.Single},System.Single[0:,0:],System.Collections.Generic.IEnumerable{System.Single},System.Int32,System.Int32)">
            <summary>
            Interpolation in one dimension within a 2-dimensional array of values
            </summary>
            <param name="x">The known independent value</param>
            <param name="y">The known dependent value</param>
            <param name="xs">Value to at which to interpolate</param>
            <param name="fixedDimension">The dimension of y in which to interpolate</param>
            <param name="fixedIndex">The index within the dimension of y in which to interpolate</param>
            <returns>If xs outside range of x, returns NaN,
                otherwide, returns linearly interpolated result as an IEnumerable of type float</returns>
        </member>
        <member name="M:Vts.Common.Math.Interpolation.interp2(System.Collections.Generic.IList{System.Double},System.Collections.Generic.IList{System.Double},System.Double[0:,0:],System.Double,System.Double)">
            <summary>
            Interpolation in two dimensions 
            </summary>
            <remarks>
            Assumptions: 1) x and y are monotonically increasing, and
                         2) xi and yi are inclusive to x and y respectively for interpolated results,
                         otherwise return NaN
            </remarks>
            <param name="x">The known independent values</param>
            <param name="y">The known independent values</param>
            <param name="f">The known dependent values</param>
            <param name="xi">x value to at which to interpolate</param>
            <param name="yi">y value to at which to interpolate</param>
            <returns>The interpolated value (clamped to boundary values if xi are of range)</returns>
        </member>
        <member name="T:Vts.Common.Math.Statistics">
            <summary>
            Statistics utilities
            </summary>
        </member>
        <member name="M:Vts.Common.Math.Statistics.ExpectedValue(System.Double[],System.Double[])">
            <summary>
            method determines the discrete expected value given x and a probability density function, p(x)
            </summary>
        </member>
        <member name="M:Vts.Common.Math.Statistics.MeanSamplingDepth(System.Double[],System.Double[],System.Double[],System.Double[],System.Double[])">
            <sumary>
            method determines expected value of a 2D array given in 1D (row dominant) over the 2nd dimension 
            used to determine mean sampling depth
            </sumary>
        </member>
        <member name="T:Vts.Common.Position">
            <summary>
            Represents a 3-dimensional cartesian point in space
            </summary>
        </member>
        <member name="M:Vts.Common.Position.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Returns a 3-dimensional cartesian point in space, based on an x, y, and z position
            </summary>
            <param name="x">The x position</param>
            <param name="y">The y position</param>
            <param name="z">The z position</param>
        </member>
        <member name="M:Vts.Common.Position.#ctor">
            <summary>
            Returns a default 3-dimensional cartesian point, located at the origin (x=0, y=0, z=0)
            </summary>
        </member>
        <member name="P:Vts.Common.Position.X">
            <summary>
            The X component of the position
            </summary>
        </member>
        <member name="P:Vts.Common.Position.Y">
            <summary>
            The Y component of the position
            </summary>
        </member>
        <member name="P:Vts.Common.Position.Z">
            <summary>
            The Z component of the position
            </summary>
        </member>
        <member name="M:Vts.Common.Position.GetDistance(Vts.Common.Position,Vts.Common.Position)">
            <summary>
            Static helper method for calculating the distance between two 3-dimensional points
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Position.op_Addition(Vts.Common.Position,Vts.Common.Position)">
            <summary>
            Operator overload for adding two 3D cartesian positions
            </summary>
            <param name="p1">The first addend position</param>
            <param name="p2">The second addend position</param>
            <returns>The summed position in 3D cartesian coordinates</returns>
        </member>
        <member name="M:Vts.Common.Position.op_Subtraction(Vts.Common.Position,Vts.Common.Position)">
            <summary>
            Operator overload for subtracting two 3D cartesian positions
            </summary>
            <param name="p1">The minuend position</param>
            <param name="p2">The subtrahend position</param>
            <returns>The difference between the two positions, in 3D cartesian coordinates</returns>
        </member>
        <member name="M:Vts.Common.Position.op_Equality(Vts.Common.Position,Vts.Common.Position)">
            <summary>
            Equality overload for two 3D cartesian coordinates
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Position.op_Inequality(Vts.Common.Position,Vts.Common.Position)">
            <summary>
            Inequality overload for two 3D cartesian coordinates
            </summary>
            <param name="p1"></param>
            <param name="p2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Position.WriteBinary(System.IO.BinaryWriter)">
            <summary>
            Method to write binary version of position
            </summary>
        </member>
        <member name="M:Vts.Common.Position.ReadBinary(System.IO.BinaryReader)">
            <summary>
            Method to read binary version of position
            </summary>
            <param name="br">BinaryReader</param>
            <returns>a position</returns>
        </member>
        <member name="M:Vts.Common.Position.Equals(System.Object)">
            <summary>
            Instance member for equality comparison
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Common.Position.Clone">
            <summary>
            Method to clone position
            </summary>
            <returns>a position</returns>
        </member>
        <member name="M:Vts.Common.Position.GetHashCode">
            <summary>
            Override of GetHashCode to allow the type to work correctly in a hash table
            </summary>
            <returns>The hashcode as an integer</returns>
        </member>
        <member name="T:Vts.Common.Resources.Strings">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ChromophoreCoefficientType_FractionalAbsorptionCoefficient">
            <summary>
              Looks up a localized string similar to vol. frac..
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ChromophoreCoefficientType_MolarAbsorptionCoefficient">
            <summary>
              Looks up a localized string similar to μM.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerGHz">
            <summary>
              Looks up a localized string similar to GHz-1.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerMM">
            <summary>
              Looks up a localized string similar to mm-1.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerMMCubed">
            <summary>
              Looks up a localized string similar to mm-3.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerMMCubedPerGHz">
            <summary>
              Looks up a localized string similar to mm-3 GHz-1.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerMMCubedPerNS">
            <summary>
              Looks up a localized string similar to mm-3 ns-1.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerMMPerGHz">
            <summary>
              Looks up a localized string similar to mm-1 GHz-1.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerMMPerNS">
            <summary>
              Looks up a localized string similar to mm-1 ns-1.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerMMSquared">
            <summary>
              Looks up a localized string similar to mm-2.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerMMSquaredPerGHz">
            <summary>
              Looks up a localized string similar to mm-2 GHz-1.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerMMSquaredPerNS">
            <summary>
              Looks up a localized string similar to mm-2 ns-1.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_PerNS">
            <summary>
              Looks up a localized string similar to ns-1.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.DependentVariableAxisUnits_Unitless">
            <summary>
              Looks up a localized string similar to Unitless.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.FluenceSolutionDomainType_FluenceOfFxAndZ">
            <summary>
              Looks up a localized string similar to Φ(fx,z).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.FluenceSolutionDomainType_FluenceOfFxAndZAndFt">
            <summary>
              Looks up a localized string similar to Φ(fx,z,ft).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.FluenceSolutionDomainType_FluenceOfFxAndZAndTime">
            <summary>
              Looks up a localized string similar to Φ(fx,z,t).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.FluenceSolutionDomainType_FluenceOfRhoAndZ">
            <summary>
              Looks up a localized string similar to Φ(ρ,z).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.FluenceSolutionDomainType_FluenceOfRhoAndZAndFt">
            <summary>
              Looks up a localized string similar to Φ(ρ,z,ft).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.FluenceSolutionDomainType_FluenceOfRhoAndZAndTime">
            <summary>
              Looks up a localized string similar to Φ(ρ,z,t).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardAnalysisType_dRdG">
            <summary>
              Looks up a localized string similar to ∂R/∂g.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardAnalysisType_dRdIV">
            <summary>
              Looks up a localized string similar to ∂R/∂IV.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardAnalysisType_dRdMua">
            <summary>
              Looks up a localized string similar to ∂R/∂μa.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardAnalysisType_dRdMusp">
            <summary>
              Looks up a localized string similar to ∂R/∂μs&apos;.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardAnalysisType_dRdN">
            <summary>
              Looks up a localized string similar to ∂R/∂n.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardAnalysisType_R">
            <summary>
              Looks up a localized string similar to R.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardSolverType_DeltaPOne">
            <summary>
              Looks up a localized string similar to δ-P1 (Analytic).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardSolverType_DistributedGaussianSourceSDA">
            <summary>
              Looks up a localized string similar to Standard Diffusion (Analytic: Distributed Gaussian Source).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardSolverType_DistributedPointSourceSDA">
            <summary>
              Looks up a localized string similar to Standard Diffusion (Analytic: Distributed Point Source).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardSolverType_MonteCarlo">
            <summary>
              Looks up a localized string similar to Scaled Monte Carlo: Basic (g=0.8, n=1.4).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardSolverType_Nurbs">
            <summary>
              Looks up a localized string similar to Scaled Monte Carlo: NURBS (g=0.8, n=1.4).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardSolverType_PointSourceSDA">
            <summary>
              Looks up a localized string similar to Standard Diffusion (Analytic: Isotropic Point Source).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ForwardSolverType_TwoLayerSDA">
            <summary>
              Looks up a localized string similar to Two Layer SDA.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.IndependentVariableAxis_Ft">
            <summary>
              Looks up a localized string similar to ft.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.IndependentVariableAxis_Fx">
            <summary>
              Looks up a localized string similar to fx.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.IndependentVariableAxis_Rho">
            <summary>
              Looks up a localized string similar to ρ.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.IndependentVariableAxis_Time">
            <summary>
              Looks up a localized string similar to t.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.IndependentVariableAxis_Wavelength">
            <summary>
              Looks up a localized string similar to λ.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.IndependentVariableAxisUnits_GHz">
            <summary>
              Looks up a localized string similar to GHz.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.IndependentVariableAxisUnits_InverseMM">
            <summary>
              Looks up a localized string similar to 1/mm.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.IndependentVariableAxisUnits_MM">
            <summary>
              Looks up a localized string similar to mm.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.IndependentVariableAxisUnits_NM">
            <summary>
              Looks up a localized string similar to nm.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.IndependentVariableAxisUnits_NS">
            <summary>
              Looks up a localized string similar to ns.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.InverseFitType_Mua">
            <summary>
              Looks up a localized string similar to μa Only.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.InverseFitType_MuaMusp">
            <summary>
              Looks up a localized string similar to μa and μs&apos;.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.InverseFitType_MuaMuspG">
            <summary>
              Looks up a localized string similar to μa, μs&apos; and g.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.InverseFitType_Musp">
            <summary>
              Looks up a localized string similar to μs&apos; Only.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.MapType_AbsorbedEnergy">
            <summary>
              Looks up a localized string similar to A (Absorbed Energy).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.MapType_Fluence">
            <summary>
              Looks up a localized string similar to Φ (Fluence).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.MapType_PhotonHittingDensity">
            <summary>
              Looks up a localized string similar to phd (Photon Hitting Density).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.OptimizerType_LevenbergMarquardt">
            <summary>
              Looks up a localized string similar to Levenberg Marquardt.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.OptimizerType_MPFitLevenbergMarquardt">
            <summary>
              Looks up a localized string similar to Levenberg Marquardt (mpfit).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.OptimizerType_SimulatedAnnealing">
            <summary>
              Looks up a localized string similar to Simulated Annealing.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.PlotNormalizationType_None">
            <summary>
              Looks up a localized string similar to None.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.PlotNormalizationType_RelativeToCurve">
            <summary>
              Looks up a localized string similar to Curve.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.PlotNormalizationType_RelativeToMax">
            <summary>
              Looks up a localized string similar to Max.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ScalingType_Linear">
            <summary>
              Looks up a localized string similar to Linear.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ScalingType_Log">
            <summary>
              Looks up a localized string similar to Log10.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ScatteringType_Intralipid">
            <summary>
              Looks up a localized string similar to Intralipid [vol. frac.].
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ScatteringType_Mie">
            <summary>
              Looks up a localized string similar to Mie Particle.
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.ScatteringType_PowerLaw">
            <summary>
              Looks up a localized string similar to Power Law [A*λ^(-b)].
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.SolutionDomainType_ROfFx">
            <summary>
              Looks up a localized string similar to R(fx).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.SolutionDomainType_ROfFxAndFt">
            <summary>
              Looks up a localized string similar to R(fx,ft).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.SolutionDomainType_ROfFxAndTime">
            <summary>
              Looks up a localized string similar to R(fx,t).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.SolutionDomainType_ROfRho">
            <summary>
              Looks up a localized string similar to R(ρ).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.SolutionDomainType_ROfRhoAndFt">
            <summary>
              Looks up a localized string similar to R(ρ,ft).
            </summary>
        </member>
        <member name="P:Vts.Common.Resources.Strings.SolutionDomainType_ROfRhoAndTime">
            <summary>
              Looks up a localized string similar to R(ρ,t).
            </summary>
        </member>
        <member name="T:Vts.AbsorptionCoefficientUnit">
            <summary>
            Enum to represent the possible absorption coefficient inputs
            </summary>
        </member>
        <member name="F:Vts.AbsorptionCoefficientUnit.InverseMillimeters">
            <summary>
            [1/mm]
            </summary>
        </member>
        <member name="F:Vts.AbsorptionCoefficientUnit.InverseMeters">
            <summary>
            [1/m]
            </summary>
        </member>
        <member name="F:Vts.AbsorptionCoefficientUnit.InverseCentimeters">
            <summary>
            [1/cm]
            </summary>
        </member>
        <member name="F:Vts.AbsorptionCoefficientUnit.InverseMicrometers">
            <summary>
            [1/um]
            </summary>
        </member>
        <member name="T:Vts.AbsorptionWeightingType">
            <summary>
            Absorption weighting type used within Monte Carlo code
            </summary>
        </member>
        <member name="F:Vts.AbsorptionWeightingType.Analog">
            <summary>
            analog absorption weighting
            </summary>
        </member>
        <member name="F:Vts.AbsorptionWeightingType.Discrete">
            <summary>
            discrete absorption weighting
            </summary>
        </member>
        <member name="F:Vts.AbsorptionWeightingType.Continuous">
            <summary>
            continuous absorption weighting
            </summary>
        </member>
        <member name="T:Vts.AnalyzerType">
            <summary>
            Analyzer types
            </summary>
        </member>
        <member name="F:Vts.AnalyzerType.Numeric">
            <summary>
            numeric analyzer type 
            </summary>
        </member>
        <member name="F:Vts.AnalyzerType.AnalyticSDA">
            <summary>
            analyzer type that comes from analytic solution
            </summary>
        </member>
        <member name="T:Vts.BloodConcentrationUnit">
            <summary>
            units allowed for blood concentration
            </summary>
        </member>
        <member name="F:Vts.BloodConcentrationUnit.OxyPlusDeoxy">
            <summary>
            oxy-hemoglobin + deoxy-hemoglobin
            </summary>
        </member>
        <member name="F:Vts.BloodConcentrationUnit.HbTPlusStO2">
            <summary>
            total hemoglobin + oxygen saturation
            </summary>
        </member>
        <member name="F:Vts.BloodConcentrationUnit.VbPlusOxygenation">
            <summary>
            blood volume + oxygenation
            </summary>
        </member>
        <member name="T:Vts.ChromophoreCoefficientType">
            <summary>
            chromophore coefficient types
            </summary>
        </member>
        <member name="F:Vts.ChromophoreCoefficientType.FractionalAbsorptionCoefficient">
            <summary>
            Absorption coefficients per unit distance in [1/mm] 
            (i.e. 2.303 * Absorbance)
            </summary>
        </member>
        <member name="F:Vts.ChromophoreCoefficientType.MolarAbsorptionCoefficient">
            <summary>
            Extinction coefficients per unit distance per concentration [(1/mm)*(1/microMoloar)]
            (i.e. Absorbance / [Concentration * Path-length])
            </summary>
        </member>
        <member name="T:Vts.ChromophoreType">
            <summary>
            chromophore types
            </summary>
        </member>
        <member name="F:Vts.ChromophoreType.HbO2">
            <summary>
            deoxy-hemoglobin
            </summary>
        </member>
        <member name="F:Vts.ChromophoreType.Hb">
            <summary>
            hemoglobin
            </summary>
        </member>
        <member name="F:Vts.ChromophoreType.H2O">
            <summary>
            water
            </summary>
        </member>
        <member name="F:Vts.ChromophoreType.Fat">
            <summary>
            fat
            </summary>
        </member>
        <member name="F:Vts.ChromophoreType.Melanin">
            <summary>
            melanin
            </summary>
        </member>
        <member name="F:Vts.ChromophoreType.Nigrosin">
            <summary>
            nigrosin
            </summary>
        </member>
        <member name="F:Vts.ChromophoreType.Baseline">
            <summary>
            baseline chromophore
            </summary>
        </member>
        <member name="T:Vts.ColormapType">
            <summary>
            Available choices for mapping grayscale intensity.  These names taken from matlab.
            </summary>
        </member>
        <member name="F:Vts.ColormapType.Hot">
            <summary>
            varies smoothly from black through shades of red, orange, and yellow, to white
            </summary>
        </member>
        <member name="F:Vts.ColormapType.Jet">
            <summary>
            ranges from blue to red, and passes through the colors cyan, yellow, and orange
            </summary>
        </member>
        <member name="F:Vts.ColormapType.Gray">
            <summary>
            linear grayscale
            </summary>
        </member>
        <member name="F:Vts.ColormapType.HSV">
            <summary>
            varies the hue component of the hue-saturation-value color model
            </summary>
        </member>
        <member name="F:Vts.ColormapType.Bone">
            <summary>
            grayscale colormap with a higher value for the blue component
            </summary>
        </member>
        <member name="F:Vts.ColormapType.Copper">
            <summary>
            varies smoothly from black to bright copper
            </summary>
        </member>
        <member name="F:Vts.ColormapType.Binary">
            <summary>
            map is digitize to two colors (white and black)
            </summary>
        </member>
        <member name="T:Vts.ConcentrationUnits">
            <summary>
            concentration units
            </summary>
        </member>
        <member name="F:Vts.ConcentrationUnits.microMolar">
            <summary>
            [uM] concentraction units
            </summary>
        </member>
        <member name="F:Vts.ConcentrationUnits.percent">
            <summary>
            percent concentration units
            </summary>
        </member>
        <member name="T:Vts.DependentVariableAxisUnits">
            <summary>
            dependent variable axis unit types
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerMMSquared">
            <summary>
            per millimeter squared [1/(mm * mm)], inverse area
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerMMSquaredPerNS">
            <summary>
            per millimeter squared per nanosecond [1/(mm * mm * ns)]
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerMMSquaredPerGHz">
            <summary>
            per millimiter squared per giga-Hertz [1/(mm * mm * GHz)]
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.Unitless">
            <summary>
            unitless dependent variance axis units
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerNS">
            <summary>
            per nanosecond [1/ns]
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerGHz">
            <summary>
            per giga-Hertz [1/GHz]
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerMMCubed">
            <summary>
            per millimeter cubed [1/(mm * mm * mm)]
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerMMCubedPerNS">
            <summary>
            per millimeter cubed per nanosecond [1/(mm * mm * mm * ns)]
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerMMCubedPerGHz">
            <summary>
            per millimeter cubed per giga-Hertz [1/(mm * mm * mm * GHz)]
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerMM">
            <summary>
            per millimeter [1/mm]
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerMMPerNS">
            <summary>
            per millimeter per nanosecond [1/(mm * ns)]
            </summary>
        </member>
        <member name="F:Vts.DependentVariableAxisUnits.PerMMPerGHz">
            <summary>
            per millimeter per giga-Hertz [1/(mm * GHz)]
            </summary>
        </member>
        <member name="T:Vts.FluenceSolutionDomainType">
            <summary>
            fluence solution domain types 
            </summary>
        </member>
        <member name="F:Vts.FluenceSolutionDomainType.FluenceOfRhoAndZ">
            <summary>
            fluence as a function or source-detector separation (rho) and tissue depth (z)
            </summary>
        </member>
        <member name="F:Vts.FluenceSolutionDomainType.FluenceOfFxAndZ">
            <summary>
            fluence as a function of spatial-frequency (fx) and tissue depth (z)
            </summary>
        </member>
        <member name="F:Vts.FluenceSolutionDomainType.FluenceOfRhoAndZAndTime">
            <summary>
            fluence as a function or source-detector separation (rho), tissue depth (z) and time (t)
            </summary>
        </member>
        <member name="F:Vts.FluenceSolutionDomainType.FluenceOfFxAndZAndTime">
            <summary>
            fluence as a function of spatial-frequency (fx), tissue depth (z) and time (t)
            </summary>
        </member>
        <member name="F:Vts.FluenceSolutionDomainType.FluenceOfRhoAndZAndFt">
            <summary>
            fluence as a function of source-detector separation (rho), tissue depth (z) and temporal-frequency (ft)
            </summary>
        </member>
        <member name="F:Vts.FluenceSolutionDomainType.FluenceOfFxAndZAndFt">
            <summary>
            fluence as a function of spatial-frequency (fx), tissue depth (z) and temporal-frequency (ft)
            </summary>
        </member>
        <member name="T:Vts.ForwardAnalysisType">
            <summary>
            forward analysis types
            </summary>
        </member>
        <member name="F:Vts.ForwardAnalysisType.R">
            <summary>
            reflectance forward analysis type
            </summary>
        </member>
        <member name="F:Vts.ForwardAnalysisType.dRdMua">
            <summary>
            the derivative of reflectance (R) with respect to absorption coefficient (mua)
            </summary>
        </member>
        <member name="F:Vts.ForwardAnalysisType.dRdMusp">
            <summary>
            the derivative of reflectance (R) with respect to reduced scattering coefficient (musp)
            </summary>
        </member>
        <member name="F:Vts.ForwardAnalysisType.dRdG">
            <summary>
            the derivative of reflectance (R) with respect to anisotropy coefficient (g)
            </summary>
        </member>
        <member name="F:Vts.ForwardAnalysisType.dRdN">
            <summary>
            the derivative of reflectance (R) with respect to refractive index (n)
            </summary>
        </member>
        <member name="T:Vts.ForwardSolverType">
            <summary>
            Types of Forward solvers in our gui
            </summary>
        </member>
        <member name="F:Vts.ForwardSolverType.PointSourceSDA">
            <summary>
            Standard Diffusion Approximation (SDA) with point source forward solver
            </summary>
        </member>
        <member name="F:Vts.ForwardSolverType.DistributedPointSourceSDA">
            <summary>
            Standard Diffusion Approximation (SDA) with distributed point source forward solver
            </summary>
        </member>
        <member name="F:Vts.ForwardSolverType.DistributedGaussianSourceSDA">
            <summary>
            Standard Diffusion Approximation (SDA) with Gaussian distributed source forward solver
            </summary>
        </member>
        <member name="F:Vts.ForwardSolverType.DeltaPOne">
            <summary>
            delta-P1 forward solver
            </summary>
        </member>
        <member name="F:Vts.ForwardSolverType.MonteCarlo">
            <summary>
            scaled Monte Carlo forward solver
            </summary>
        </member>
        <member name="F:Vts.ForwardSolverType.Nurbs">
            <summary>
            scaled Monte Carlo forward solver with non-uniform rational b-splines forward solver
            </summary>
        </member>
        <member name="F:Vts.ForwardSolverType.TwoLayerSDA">
            <summary>
            two-layer forward solver based on standard diffusion
            </summary>
        </member>
        <member name="T:Vts.IndependentVariableAxis">
            <summary>
            independent variable axis tyeps
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxis.Rho">
            <summary>
            source-detector separation (rho)
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxis.Time">
            <summary>
            time (t)
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxis.Fx">
            <summary>
            spatial-frequency (fx)
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxis.Ft">
            <summary>
            temporal-frequency (ft)
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxis.Z">
            <summary>
            depth in tissue (z)
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxis.Wavelength">
            <summary>
            wavelength (lambda)
            </summary>
        </member>
        <member name="T:Vts.IndependentVariableAxisUnits">
            <summary>
            independent variable axis unit types.  These are the default units used throughout code
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxisUnits.MM">
            <summary>
            millimeter (mm)
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxisUnits.NS">
            <summary>
            nanosecond (ns)
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxisUnits.InverseMM">
            <summary>
            millimeter^(-1)
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxisUnits.GHz">
            <summary>
            giga-Hertz
            </summary>
        </member>
        <member name="F:Vts.IndependentVariableAxisUnits.NM">
            <summary>
            nanometers
            </summary>
        </member>
        <member name="T:Vts.InputParameterType">
            <summary>
            input parameters types used in the Monte Carlo CommandLine application for parameter sweeps
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.XSourcePosition">
            <summary>
            x position of the source definition
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.YSourcePosition">
            <summary>
            y position of the source definition
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.XInclusionPosition">
            <summary>
            x center position of the embedded ellipse
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.YInclusionPosition">
            <summary>
            y center position of the embedded ellipse
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.ZInclusionPosition">
            <summary>
            z center position of the embedded ellipse
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.XInclusionRadius">
            <summary>
            x-axis radius of embedded ellipse
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.YInclusionRadius">
            <summary>
            y-axis radius of embedded ellipse
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.ZInclusionRadius">
            <summary>
            z-axis radius of embedded ellipse
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.Mua1">
            <summary>
            absorption coefficient of top layer of tissue
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.Mua2">
            <summary>
            absorption coefficient of second layer of tissue
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.Mus1">
            <summary>
            scattering coefficient of top layer of tissue
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.Mus2">
            <summary>
            scattering coefficient of second layer of tissue
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.G1">
            <summary>
            anisotropy coefficient of top layer of tissue
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.G2">
            <summary>
            anisotropy coefficient of second layer of tissue
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.N1">
            <summary>
            refractive index of top layer of tissue
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.N2">
            <summary>
            refractive index of second layer of tissue
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.D1">
            <summary>
            thickness of top layer of tissue
            </summary>
        </member>
        <member name="F:Vts.InputParameterType.D2">
            <summary>
            thickness of second layer of tissue
            </summary>
        </member>
        <member name="T:Vts.InverseFitType">
            <summary>
            inverse solution parameter types
            </summary>
        </member>
        <member name="F:Vts.InverseFitType.MuaMusp">
            <summary>
            fit inverse solution using two parameters: mua and musp (mus')
            </summary>
        </member>
        <member name="F:Vts.InverseFitType.Mua">
            <summary>
            fit inverse solution using one parameter: mua
            </summary>
        </member>
        <member name="F:Vts.InverseFitType.Musp">
            <summary>
            fit inverse solution using one parameter: musp (mus')
            </summary>
        </member>
        <member name="F:Vts.InverseFitType.MuaMuspG">
            <summary>
            fit inverse solution using three parameters: mua, musp (mus') and g
            </summary>
        </member>
        <member name="T:Vts.MapType">
            <summary>
            map plot types
            </summary>
        </member>
        <member name="F:Vts.MapType.Fluence">
            <summary>
            fluence map type
            </summary>
        </member>
        <member name="F:Vts.MapType.AbsorbedEnergy">
            <summary>
            absorbed energy map type
            </summary>
        </member>
        <member name="F:Vts.MapType.PhotonHittingDensity">
            <summary>
            photon hitting density map type
            </summary>
        </member>
        <member name="T:Vts.MieScattererType">
            <summary>
            Types of Mie Scatterers
            </summary>
        </member>
        <member name="F:Vts.MieScattererType.PolystyreneSphereSuspension">
            <summary>
            Polystyrene sphere suspension Mie scatterer
            </summary>
        </member>
        <member name="F:Vts.MieScattererType.Other">
            <summary>
            Non-polysytrene sphere suspension Mie scatterer
            </summary>
        </member>
        <member name="T:Vts.MolarUnit">
            <summary>
            molar unit units
            </summary>
        </member>
        <member name="F:Vts.MolarUnit.None">
            <summary>
            no molar unit
            </summary>
        </member>
        <member name="F:Vts.MolarUnit.Molar">
            <summary>
            molar units
            </summary>
        </member>
        <member name="F:Vts.MolarUnit.MilliMolar">
            <summary>
            millimolar units
            </summary>
        </member>
        <member name="F:Vts.MolarUnit.MicroMolar">
            <summary>
            micromolar units
            </summary>
        </member>
        <member name="F:Vts.MolarUnit.NanoMolar">
            <summary>
            nanomolar units
            </summary>
        </member>
        <member name="T:Vts.OptimizerType">
            <summary>
            types of optimization methods
            </summary>
        </member>
        <member name="F:Vts.OptimizerType.MPFitLevenbergMarquardt">
            <summary>
            Levenberg-Marquard from MPFit
            </summary>
        </member>
        <member name="T:Vts.ParameterSweepType">
            <summary>
            Monte Carlo command line parameter sweep types
            </summary>
        </member>
        <member name="F:Vts.ParameterSweepType.Count">
            <summary>
            input of type start,stop,count
            </summary>
        </member>
        <member name="F:Vts.ParameterSweepType.Delta">
            <summary>
            input of type start,stop,delta
            </summary>
        </member>
        <member name="F:Vts.ParameterSweepType.List">
            <summary>
            input of type number,value1,value2,...
            </summary>
        </member>
        <member name="T:Vts.PhaseFunctionType">
            <summary>
            Phase function type used within the Monte Carlo code
            </summary>
        </member>
        <member name="F:Vts.PhaseFunctionType.HenyeyGreenstein">
            <summary>
            Henyey-Greenstein scattering phase function
            </summary>
        </member>
        <member name="F:Vts.PhaseFunctionType.Bidirectional">
            <summary>
            bidirectional scattering phase function
            </summary>
        </member>
        <member name="T:Vts.PlotNormalizationType">
            <summary>
            plot normalization types
            </summary>
        </member>
        <member name="F:Vts.PlotNormalizationType.None">
            <summary>
            no plot normalization
            </summary>
        </member>
        <member name="F:Vts.PlotNormalizationType.RelativeToMax">
            <summary>
            plot normalization relative to plot max
            </summary>
        </member>
        <member name="F:Vts.PlotNormalizationType.RelativeToCurve">
            <summary>
            plot normalization relative to curve
            </summary>
        </member>
        <member name="T:Vts.PlotToggleType">
            <summary>
            plot toggle types
            </summary>
        </member>
        <member name="F:Vts.PlotToggleType.Complex">
            <summary>
            real/imag type
            </summary>
        </member>
        <member name="F:Vts.PlotToggleType.Phase">
            <summary>
            phase type
            </summary>
        </member>
        <member name="F:Vts.PlotToggleType.Amp">
            <summary>
            amplitude plot
            </summary>
        </member>
        <member name="T:Vts.RandomNumberGeneratorType">
            <summary>
            Random number generator types
            </summary>
        </member>
        <member name="F:Vts.RandomNumberGeneratorType.MersenneTwister">
            <summary>
            19937 MT by Matsumoto (implemented by Math.NET Numerics)
            </summary>
        </member>
        <member name="F:Vts.RandomNumberGeneratorType.DynamicCreatorMersenneTwister">
            <summary>
            Dynamic creator for parallel processing 
            (http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/DC/dc.html)
            </summary>
        </member>
        <member name="F:Vts.RandomNumberGeneratorType.SerializableMersenneTwister">
            <summary>
            MathNet Numerics random nummber generator, inherited so it can be serialized
            </summary>
        </member>
        <member name="T:Vts.ReflectancePlotType">
            <summary>
            reflectance plot types
            </summary>
        </member>
        <member name="F:Vts.ReflectancePlotType.ForwardSolver">
            <summary>
            forward solver solutions plots
            </summary>
        </member>
        <member name="F:Vts.ReflectancePlotType.InverseSolverMeasuredData">
            <summary>
            measured data plot for inverse solver panel
            </summary>
        </member>
        <member name="F:Vts.ReflectancePlotType.InverseSolverAtInitialGuess">
            <summary>
            forward solver at initial guess for inverse solver panel
            </summary>
        </member>
        <member name="F:Vts.ReflectancePlotType.InverseSolverAtConvergedData">
            <summary>
            forward solver at converged optical properties for inverse solver panel
            </summary>
        </member>
        <member name="F:Vts.ReflectancePlotType.Clear">
            <summary>
            clear plot
            </summary>
        </member>
        <member name="T:Vts.ScalingType">
            <summary>
            scaling types
            </summary>
        </member>
        <member name="F:Vts.ScalingType.Linear">
            <summary>
            linear scaling type
            </summary>
        </member>
        <member name="F:Vts.ScalingType.Log">
            <summary>
            logarithmic scaling type
            </summary>
        </member>
        <member name="T:Vts.ScatteringType">
            <summary>
            ScatteringType used within Modeling\Spectroscopy 
            </summary>
        </member>
        <member name="F:Vts.ScatteringType.PowerLaw">
            <summary>
            ScatteringType used within PwoerLawScatterer class
            </summary>
        </member>
        <member name="F:Vts.ScatteringType.Intralipid">
            <summary>
            ScatteringType used within IntralipidScatterer class
            </summary>
        </member>
        <member name="F:Vts.ScatteringType.Mie">
            <summary>
            ScatteringType used within MieScatterer class
            </summary>
        </member>
        <member name="T:Vts.SolutionDomainType">
            <summary>
            Reflectance solution domain types
            </summary>
        </member>
        <member name="F:Vts.SolutionDomainType.ROfRho">
            <summary>
            reflectance as a function of source-detector separation (rho)
            </summary>
        </member>
        <member name="F:Vts.SolutionDomainType.ROfFx">
            <summary>
            reflectance as a function of spatial-frequency (fx)
            </summary>
        </member>
        <member name="F:Vts.SolutionDomainType.ROfRhoAndTime">
            <summary>
            reflectance as a function of source-detector separation (rho) and time (t)
            </summary>
        </member>
        <member name="F:Vts.SolutionDomainType.ROfFxAndTime">
            <summary>
            reflectance as a function of spatial-frequency (fx) and time (t)
            </summary>
        </member>
        <member name="F:Vts.SolutionDomainType.ROfRhoAndFt">
            <summary>
            reflectance as a function source-detector separation (rho) and temporal-frequency (ft)
            </summary>
        </member>
        <member name="F:Vts.SolutionDomainType.ROfFxAndFt">
            <summary>
            reflectance as a function of spatial-frequency (fx) and temporal-frequency (ft)
            </summary>
        </member>
        <member name="T:Vts.SolverType">
            <summary>
            solver type. Added to determine which panel is in context LMM 
            </summary>
        </member>
        <member name="F:Vts.SolverType.Forward">
            <summary>
            forward solver
            </summary>
        </member>
        <member name="F:Vts.SolverType.Fluence">
            <summary>
            fluence solver
            </summary>
        </member>
        <member name="F:Vts.SolverType.Inverse">
            <summary>
            inverse solver
            </summary>
        </member>
        <member name="T:Vts.SpatialDomainType">
            <summary>
            spatial-frequency domain types
            </summary>
        </member>
        <member name="F:Vts.SpatialDomainType.Real">
            <summary>
            real spatial-frequency domain type
            </summary>
        </member>
        <member name="F:Vts.SpatialDomainType.SpatialFrequency">
            <summary>
            spatial-frequncy domain type
            </summary>
        </member>
        <member name="T:Vts.TimeDomainType">
            <summary>
            temporal-frequency domain types
            </summary>
        </member>
        <member name="F:Vts.TimeDomainType.SteadyState">
            <summary>
            steady-state temporal-frequency domain type
            </summary>
        </member>
        <member name="F:Vts.TimeDomainType.TimeDomain">
            <summary>
            time-domain temporal-frequency domain type
            </summary>
        </member>
        <member name="F:Vts.TimeDomainType.FrequencyDomain">
            <summary>
            frequency-domain temporal-frequency domain type
            </summary>
        </member>
        <member name="T:Vts.TissueType">
            <summary>
            tissue types
            </summary>
        </member>
        <member name="F:Vts.TissueType.Skin">
            <summary>
            skin tissue type
            </summary>
        </member>
        <member name="F:Vts.TissueType.Liver">
            <summary>
            liver tissue type 
            </summary>
        </member>
        <member name="F:Vts.TissueType.BrainGrayMatter">
            <summary>
            grey matter of brain tissue type
            </summary>
        </member>
        <member name="F:Vts.TissueType.BrainWhiteMatter">
            <summary>
            white matter of brain tissue type
            </summary>
        </member>
        <member name="F:Vts.TissueType.BreastPreMenopause">
            <summary>
            pre-menopausal breast tissue type
            </summary>
        </member>
        <member name="F:Vts.TissueType.BreastPostMenopause">
            <summary>
            post-menopausal breast tissue type
            </summary>
        </member>
        <member name="F:Vts.TissueType.IntralipidPhantom">
            <summary>
            intralipid tissue phantom 
            </summary>
        </member>
        <member name="F:Vts.TissueType.PolystyreneSpherePhantom">
            <summary>
            polystyrene sphere suspension tissue phantom
            </summary>
        </member>
        <member name="F:Vts.TissueType.Custom">
            <summary>
            custom tissue 
            </summary>
        </member>
        <member name="T:Vts.WavelengthUnit">
            <summary>
            Enum to represent the possible wavelength and wavenumber inputs
            </summary>
        </member>
        <member name="F:Vts.WavelengthUnit.Nanometers">
            <summary>
            [nm]
            </summary>
        </member>
        <member name="F:Vts.WavelengthUnit.Micrometers">
            <summary>
            [um] microns
            </summary>
        </member>
        <member name="F:Vts.WavelengthUnit.Meters">
            <summary>
            [m] meters
            </summary>
        </member>
        <member name="F:Vts.WavelengthUnit.InverseMeters">
            <summary>
            [1/m]
            </summary>
        </member>
        <member name="F:Vts.WavelengthUnit.InverseCentimeters">
            <summary>
            [1/cm]
            </summary>
        </member>
        <member name="T:Vts.Extensions.ArrayExtensions">
            <summary>
            Helper group of extension methods for array-based operations
            </summary>
        </member>
        <member name="M:Vts.Extensions.ArrayExtensions.InitializeTo``1(``0[],``0)">
            <summary>
            method to initialize this Array class with value
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myArray">this array class</param>
            <param name="value">value to initialize with</param>
            <returns>generic array T[]</returns>
        </member>
        <member name="M:Vts.Extensions.ArrayExtensions.Column``1(``0[0:,0:],System.Int32)">
            <summary>
            method to obtain column from array
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myArray">this class array</param>
            <param name="column">integer column identifier</param>
            <returns>IEnumerable[T] column of array</returns>
        </member>
        <member name="M:Vts.Extensions.ArrayExtensions.Columns``1(``0[0:,0:])">
            <summary>
            method to obtain columns from array
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myArray">this class array</param>
            <returns>IEnumerable[IEnumerable[T]] providing columns of array</returns>
        </member>
        <member name="M:Vts.Extensions.ArrayExtensions.Row``1(``0[0:,0:],System.Int32)">
            <summary>
            method to obtain row from array
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myArray">this class array</param>
            <param name="row">integer row identifier</param>
            <returns>IEnumerable[T] row of array</returns>
        </member>
        <member name="M:Vts.Extensions.ArrayExtensions.Rows``1(``0[0:,0:])">
            <summary>
            method to obtain rows from array
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myArray">this class array</param>
            <returns>IEnumerable[IEnumerable[T]] providing rows of array</returns>
        </member>
        <member name="T:Vts.Extensions.DataExtensions">
            <summary>
            Helper group of extension methods for manipulating data in arrays (e.g. adding noise, etc.)
            </summary>
        </member>
        <member name="M:Vts.Extensions.DataExtensions.AddNoise(System.Double[],System.Double)">
            <summary>
            This extension method (static method "add-on" to the double[] class) adds noise to the input double array
            </summary>
            <param name="myDoubleArray">values to which noise will be added</param>
            <param name="percentNoise">double indicating percent noise to be added
            percentNoise=10 means 10% noise will be added</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Extensions.DataExtensions.AddNoise(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            Static method to add percentage noise given IEnumerable of double values.
            </summary>
            <param name="myValues">IEnumerable list of values</param>
            <param name="percentNoise">double designating percent, percentNoise=10 means 10 percent
            noise added</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Extensions.EnumerableExtensions">
            <summary>
            Helper group of extension methods for adding LINQ functionality
            </summary>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.AsEnumerable``1(``0)">
            <summary>
            Extension method to turn any single item into an IEnumerable (i.e. "yield-returns" the item)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="singleItem"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.Concat``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Extension method to append a single item to an IEnumerable
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="newItem"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.ToDictionary``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Extension method to create a dictionary from key-value pairs
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="keyValuePairs"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.Select``2(``0[0:,0:],System.Func{``0,System.Int32,System.Int32,``1})">
            <summary>
            2D array overload of the LINQ Select operator with x and y indexers
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="my2DArray"></param>
            <param name="myFunc"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            Method for applying an action to any enumerable sequence. 
            This is the analog of Select, but with no output (only "side effects").
            This overload takes in an Action with an additional int parameter that 
            provides the index of the sequence.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="action"></param>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            Method for applying an action to any enumerable sequence. 
            This is the analog of Select, but with no output (only "side effects").
            This overload takes in an Action with an additional int parameter that 
            provides the index of the sequence.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="action"></param>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.To2DArray``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Converts an IEnumerable into a 2D array given a specified width and height
            </summary>
            <typeparam name="T"></typeparam>
            <param name="myArray"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.Zip``4(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Func{``0,``1,``2,``3})">
            <summary>
            method to zip together values using supplied function
            </summary>
            <typeparam name="TFirst">type of 1st list</typeparam>
            <typeparam name="TSecond">type of 2nd list</typeparam>
            <typeparam name="TThird">type of 3rd list</typeparam>
            <typeparam name="TResult">resulting list</typeparam>
            <param name="first">IEnumerable of 1st values</param>
            <param name="second">IEnumerable of 1st values</param>
            <param name="third">IEnumerable of 1st values</param>
            <param name="func">IEnumerable of 1st values</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.Zip``5(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Func{``0,``1,``2,``3,``4})">
            <summary>
            method to zip together values using supplied function
            </summary>
            <typeparam name="TFirst">type of 1st list</typeparam>
            <typeparam name="TSecond">type of 2nd list</typeparam>
            <typeparam name="TThird">type of 3rd list</typeparam>
            <typeparam name="TFourth">type of 4th list</typeparam>
            <typeparam name="TResult">resulting list</typeparam>
            <param name="first">IEnumerable of 1st values</param>
            <param name="second">IEnumerable of 1st values</param>
            <param name="third">IEnumerable of 1st values</param>
            <param name="fourth">IEnumerable of 1st values</param>
            <param name="func">IEnumerable of 1st values</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.Zip``6(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2},System.Collections.Generic.IEnumerable{``3},System.Collections.Generic.IEnumerable{``4},System.Func{``0,``1,``2,``3,``4,``5})">
            <summary>
            method to zip together values using supplied function
            </summary>
            <typeparam name="TFirst">type of 1st list</typeparam>
            <typeparam name="TSecond">type of 2nd list</typeparam>
            <typeparam name="TThird">type of 3rd list</typeparam>
            <typeparam name="TFourth">type of 4th list</typeparam>
            <typeparam name="TFifth">type of 5th list</typeparam>
            <typeparam name="TResult">resulting list</typeparam>
            <param name="first">IEnumerable of 1st values</param>
            <param name="second">IEnumerable of 1st values</param>
            <param name="third">IEnumerable of 1st values</param>
            <param name="fourth">IEnumerable of 1st values</param>
            <param name="fifth">IEnumerable of 1st values</param>
            <param name="func">IEnumerable of 1st values</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.LoopOverVariables``4(System.Func{``0,``1,``2,``3},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>
            extension method to loop over 3D set of values and apply a function
            </summary>
            <typeparam name="T1">type of first dimension</typeparam>
            <typeparam name="T2">type of second dimension</typeparam>
            <typeparam name="T3">type of third dimension</typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="myFunc">function to be evaluated</param>
            <param name="firstValues">first dimension values</param>
            <param name="secondValues">second dimension values</param>
            <param name="thirdValues">third dimension values</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Extensions.EnumerableExtensions.LoopOverVariables``3(System.Func{``0,``1,``2},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            extension method to loop over 2D set of values and apply a function
            </summary>
            <typeparam name="T1">type of first dimension</typeparam>
            <typeparam name="T2">type of second dimension</typeparam>
            <typeparam name="TReturn"></typeparam>
            <param name="myFunc">function to be evaluated</param>
            <param name="firstValues">first dimension values</param>
            <param name="secondValues">second dimension values</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Extensions.IEnumerableArrayExtensions">
            <summary>
            methods enable access to IEnumerableArrays
            </summary>
        </member>
        <member name="M:Vts.Extensions.IEnumerableArrayExtensions.ToEnumerable``1(System.Array)">
            <summary>
            method to convert Array to IEnumerable<typeparamref name="T"/>
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myArray">this array to convert</param>
            <returns>IEnumerable<typeparamref name="T"/></returns>
        </member>
        <member name="M:Vts.Extensions.IEnumerableArrayExtensions.PopulateFromEnumerable``1(System.Array,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            method to populate Array from Enumerable
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myArray">this array to convert</param>
            <param name="enumerable">enumerable to convert</param>
            <returns>Array</returns>
        </member>
        <member name="M:Vts.Extensions.IEnumerableArrayExtensions.PopulateFromEnumerator``1(System.Array,System.Collections.Generic.IEnumerator{``0})">
            <summary>
            method to populate this array from enumerator
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myArray">this array</param>
            <param name="enumerator">enumerator to convert from</param>
        </member>
        <member name="M:Vts.Extensions.IEnumerableArrayExtensions.PopulateFromEnumerable2``2(``1,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            method to populate array from IEnumerable
            </summary>
            <typeparam name="T">generic type</typeparam>
            <typeparam name="TArray">generic array</typeparam>
            <param name="myArray">this class array</param>
            <param name="enumerable">IEnumerable of T</param>
            <returns>TArray</returns>
        </member>
        <member name="M:Vts.Extensions.IEnumerableArrayExtensions.PopulateWithValue``1(``0[],``0)">
            <summary>
            method to populate this array with value
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myArray">this array class</param>
            <param name="value">value to populate</param>
            <returns>generic array T[]</returns>
        </member>
        <member name="T:Vts.Extensions.OpticalPropertiesExtensions">
            <summary>
            extension methods for optical properties class
            </summary>
        </member>
        <member name="M:Vts.Extensions.OpticalPropertiesExtensions.GetScatterLength(Vts.OpticalProperties,Vts.AbsorptionWeightingType)">
            <summary>
            Method to determine scattering length given the absorption weighting type 
            </summary>
            <param name="op">optical properties</param>
            <param name="awt">absorption weighting type</param>
            <returns>scatter length</returns>
        </member>
        <member name="T:Vts.Extensions.RNGExtensions">
            <summary>
            Class for adding functionality to the .NET Random base class
            </summary>
        </member>
        <member name="M:Vts.Extensions.RNGExtensions.NextDouble(System.Random,System.Double,System.Double)">
            <summary>
            Extension method to generate a random number within a specified range
            </summary>
            <param name="rng"></param>
            <param name="minValue"></param>
            <param name="maxValue"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.Extensions.TypeExtensions">
            <summary>
            extension methods for type
            </summary>
        </member>
        <member name="M:Vts.Extensions.TypeExtensions.Implements``1(System.Type,``0)">
            <summary>
            Checks to see if a type implements a specified interface
            </summary>
            <typeparam name="T">The interface type</typeparam>
            <param name="type">The type to verify</param>
            <param name="interface">The interface implementation</param>
            <returns>True or false</returns>
        </member>
        <member name="T:Vts.EnumExtensions">
            <summary>
            methods to ease access to enums
            </summary>
        </member>
        <member name="M:Vts.EnumExtensions.GetInternationalizedString(System.Enum)">
            <summary>
            Returns a string in the correct language representing the enum 
            </summary>
            <param name="enumType">The enum type</param>
            <returns>A string representing the enum</returns>
        </member>
        <member name="M:Vts.EnumExtensions.GetCoefficientType(Vts.ChromophoreType)">
            <summary>
            Factory method to return ChromophoreCoefficientType given a ChromophoreType
            </summary>
            <param name="chromophoreType">e.g. HbO2,Hb,Melanin,H2O,Fat</param>
            <returns>The ChromophoreCoefficientType associated with the input</returns>
        </member>
        <member name="M:Vts.EnumExtensions.Add``1(System.Enum,``0)">
            <summary>
            Method 'Add' turns on this bit
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="type">Enum type</param>
            <param name="value">value to add</param>
            <returns></returns>
        </member>
        <member name="M:Vts.EnumExtensions.Remove``1(System.Enum,``0)">
            <summary>
            Method 'Remove' turns off this bit (does nothing if flag not present)
            </summary>
            <typeparam name="T"></typeparam>
            <param name="type">Enum type</param>
            <param name="value">value to remove</param>
            <returns></returns>
        </member>
        <member name="T:Vts.GlobalConstants">
            <summary>
            Class of global constants
            </summary>
        </member>
        <member name="F:Vts.GlobalConstants.C">
            <summary>
            speed of light
            </summary>
        </member>
        <member name="F:Vts.GlobalConstants.Pi">
            <summary>
            Pi
            </summary>
            <remarks>Verified using math.com and Wikipedia</remarks>
        </member>
        <member name="T:Vts.EnumHelper">
            <summary>
            helper functions for enums
            </summary>
        </member>
        <member name="M:Vts.EnumHelper.GetValues``1">
            <summary>
            method to get values from generic type
            </summary>
            <typeparam name="T">generic type</typeparam>
            <returns></returns>
        </member>
        <member name="M:Vts.EnumHelper.GetNames``1">
            <summary>
            method to get names from generic type
            </summary>
            <typeparam name="T">generic type</typeparam>
            <returns>array of name strings</returns>
        </member>
        <member name="M:Vts.EnumHelper.GetValues(System.Type)">
            <summary>
            method to get values of enum
            </summary>
            <param name="enumType">enum</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Range`1">
            <summary>
            Immutable class that specifies a range of values and allows enumeration
            </summary>
            <typeparam name="T">The type of the values in the range</typeparam>
            <remarks>Explicit data contract necessary for JSON.Net: http://stackoverflow.com/questions/19231367/serializing-poco-class-derived-from-baseclass-with-datacontract </remarks>
        </member>
        <member name="M:Vts.Range`1.#ctor(`0,`0,System.Int32)">
            <summary>
            Defines the range
            </summary>
            <param name="start">The start of the range</param>
            <param name="stop">The end of the range</param>
            <param name="number">The number of values in the range, inclusive of the endpoints</param>
        </member>
        <member name="M:Vts.Range`1.#ctor">
            <summary>
            The only reason this is here is to satisfy the DataContractSerializer
            </summary>
        </member>
        <member name="P:Vts.Range`1.Start">
            <summary>
            The start of the range
            </summary>
        </member>
        <member name="P:Vts.Range`1.Stop">
            <summary>
            The end of the range
            </summary>
        </member>
        <member name="P:Vts.Range`1.Delta">
            <summary>
            The increment between successive numbers
            </summary>
        </member>
        <member name="P:Vts.Range`1.Count">
            <summary>
            The number of values in the range, inclusive of the endpoints
            </summary>
        </member>
        <member name="M:Vts.Range`1.GetIncrement">
            <summary>
            An abstract method to get the increment value. To be defined by the subclass
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.Range`1.GetDelta">
            <summary>
            An abstract method to get the delta value. To be defined by the subclass
            </summary>
            <returns>A value of type Time</returns>
        </member>
        <member name="M:Vts.Range`1.ToString">
            <summary>
            Returns a string that represents the range
            </summary>
            <returns>A string that represents the current range</returns>
        </member>
        <member name="M:Vts.Range`1.AsEnumerable">
            <summary>
            Returns an IEnumerable of type Time that represents the range
            </summary>
            <returns>An IEnumerable of type Time that represents the range</returns>
        </member>
        <member name="T:Vts.IChangeTracking">
            <summary>
            Interface to enable change tracking in POCO classes
            </summary>
        </member>
        <member name="P:Vts.IChangeTracking.SettingsChanged">
            <summary>
            Status indicating whether any settings have changed
            </summary>
        </member>
        <member name="M:Vts.IChangeTracking.Reset">
            <summary>
            Method to reset all changes once they have been handled
            </summary>
        </member>
        <member name="T:Vts.IForwardSolver">
            <summary>
            Defines contract for a forward solver 
            </summary>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRho(Vts.IOpticalPropertyRegion[],System.Double)">
            <summary>
            Determines reflectance at source-detector separation rho
            </summary>
            <param name="regions">optical and geometrical properties of the medium for each sub-region</param>
            <param name="rho">source-detector separation (mm)</param>
            <returns>reflectance at source-detector separation rho</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRho(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances at tissue regions and source-detector separations 'rhos'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRho(Vts.IOpticalPropertyRegion[],System.Double[])">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances given tissue regions and source-detector separations 'rhos'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRho(Vts.IOpticalPropertyRegion[][],System.Double[])">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances given tissue regions and source-detector separations 'rhos'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            Determines reflectance at source-detector separation rho and time
            </summary>
            <param name="regions">optical and geometrical properties of the medium for each sub-region</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at source-detector separation rho</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances at tissue regions, source-detector 
            separations 'rhos', and times 'times'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.IOpticalPropertyRegion[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances given tissue regions, source-detector 
            separations 'rhos', and times 'times'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.IOpticalPropertyRegion[],System.Double[],System.Double)">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances given tissue regions, source-detector 
            separations 'rhos', and time 'time'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="time">time (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.IOpticalPropertyRegion[],System.Double,System.Double[])">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances given tissue regions, source-detector 
            separation 'rho', and times 'times'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rho">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances given tissue regions, source-detector 
            separations 'rhos', and times 'times'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            Determines reflectance at source-detector separation rho and temporal frequency ft
            </summary>
            <param name="regions">optical and geometrical properties of the medium for each sub-region</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="ft">temporal frequency</param>
            <returns>reflectance at source-detector separation rho</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances at tissue regions, source-detector 
            separations 'rhos' and temporal frequencies fts
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">temporal frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.IOpticalPropertyRegion[],System.Double,System.Double[])">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances given tissue regions, source-detector 
            separations 'rhos'and temporal frequencies fts
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="fts">temporal frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.IOpticalPropertyRegion[],System.Double[],System.Double)">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances given tissue regions, source-detector 
            separations 'rhos'and temporal frequencies fts
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separation (mm)</param>
            <param name="ft">temporal frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.IOpticalPropertyRegion[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances given tissue regions, source-detector 
            separations 'rhos'and temporal frequencies fts
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">temporal frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances given tissue regions, source-detector 
            separations 'rhos', and temporal frequencies fts
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">temporal frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFx(Vts.IOpticalPropertyRegion[],System.Double)">
            <summary>
            Determines reflectance at spatial frequency 
            </summary>
            <param name="regions">optical and geometrical properties of the medium for each sub-region</param>
            <param name="fx">spatial frequency</param>
            <returns>reflectance at spatial frequency fx</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFx(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances at tissue regions and source-detector separations 'rhos'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="fxs">spatial frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFx(Vts.IOpticalPropertyRegion[],System.Double[])">
            <summary>
            Overload of scalar ROfFx function. Determines reflectances given tissue regions and spatia freqs 'fxs'
            </summary>
            <param name="regions">medium optical and geometrical properties for each sub-region</param>
            <param name="fxs">spatial frequencies</param>
            <returns>reflectance at sptail frequency</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFx(Vts.IOpticalPropertyRegion[][],System.Double[])">
            <summary>
            Overload of scalar ROfFx function. Determines reflectances given tissue regions and spatia freqs 'fxs'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="fxs">spatial frequencies</param>
            <returns>reflectance at sptail frequency</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            Determines reflectance at spatial frequency and time
            </summary>
            <param name="regions">optical and geometrical properties of the medium for each sub-region</param>
            <param name="fx">spatial frequency</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at spatial frequency fx</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfFxAndTim function. Determines reflectances at tissue regions, spatial freqs 'fxs', 
            and times 'times'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="fxs">spatial frequencies</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at spatial freq and time</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.IOpticalPropertyRegion[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances given tissue regions, spatial freqs 'fxs', 
            and times 'times'
            </summary>
            <param name="regions">medium optical and geometrical properties for each sub-region</param>
            <param name="fxs">spatial frequencies</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at spatial freq. and time</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.IOpticalPropertyRegion[],System.Double,System.Double[])">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances given tissue regions, spatial freq 'fx',
            and times 'times'
            </summary>
            <param name="regions">medium optical and geometrical properties for each sub-region</param>
            <param name="fx">spatial frequency</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.IOpticalPropertyRegion[],System.Double[],System.Double)">
            <summary>
            Overload of scalar ROfFxAndTime function.  Determines reflectances given tissue regions, spatial freqs 'fxs',
            and time 'time'
            </summary>
            <param name="regions">medium optical and geometrical properties for each sub-reion</param>
            <param name="fxs">spatial frequencies</param>
            <param name="time">time (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances given tissue regions, spatial freqs 'fxs', 
            and times 'times'
            </summary>
            <param name="regions">medium optical and geometrical properties for each sub-region</param>
            <param name="fxs">spatial frequencies</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at spatial freq. and time</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            Determines reflectance at spatial frequnecy fx and temporal frequency ft
            </summary>
            <param name="regions">optical and geometrical properties of the medium for each sub-region</param>
            <param name="fx">spatial frequency</param>
            <param name="ft">temporal frequency</param>
            <returns>reflectance at spatial freq. and temporal freq.</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances at tissue regions, spatial freqs 'fxs' and 
            temporal frequencies fts
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="fxs">spatial frequencies</param>
            <param name="fts">temporal frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.IOpticalPropertyRegion[],System.Double,System.Double[])">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances given tissue regions, source-detector 
            separations 'rhos'and temporal frequencies fts
            </summary>
            <param name="regions">medium optical and geometrical properties for each sub-region</param>
            <param name="fx">spatial-frequency</param>
            <param name="fts">temporal frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.IOpticalPropertyRegion[],System.Double[],System.Double)">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances given tissue regions, spatial freqs 
            'fs'and temporal frequencies fts
            </summary>
            <param name="regions">medium optical and geometrical properties for each sub-region</param>
            <param name="fxs">spatial freqs</param>
            <param name="ft">temporal frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.IOpticalPropertyRegion[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances given tissue regions, spatial 
            frequencies 'fxs'and temporal frequencies fts
            </summary>
            <param name="regions">medium optical and geometrical properties for each sub-region</param>
            <param name="fxs">spatial frequencies</param>
            <param name="fts">temporal frequencies</param>
            <returns>reflectance at spatial freq. and temporal freq.</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances given tissue regions, spatial 
            frequencies 'fxs', and temporal frequencies fts
            </summary>
            <param name="regions">sets of medium optical and geometrical properties for each sub-region</param>
            <param name="fxs">spatial frequencies</param>
            <param name="fts">temporal frequencies</param>
            <returns>reflectance at spatial freq. and temporal freq.</returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfRhoAndZ(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[])">
            <summary>
             Overload of scalar FluenceOfRhoAndZ function. Determines fluence of tissue 'regions' and source-detector separations 'rhos' and 'zs'
            </summary>
            <param name="regions">tissue regions</param>
            <param name="rhos">source-detector separations</param>
            <param name="zs">depth bins</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfRhoAndZ(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
             Overload of scalar FluenceOfRhoAndZ function. Determines fluence of tissue 'regions' and source-detector separations 'rhos' and 'zs'
            </summary>
            <param name="regions">tissue regions</param>
            <param name="rhos">source-detector separations</param>
            <param name="zs">depth bins</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfRhoAndZAndFt(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[],System.Double[])">
            <summary>
             Overload of scalar FluenceOfRhoAndZ function. Determines fluence of tissue 'regions' and source-detector separations 'rhos' and 'zs'
             at temporal frequencies fts
            </summary>
            <param name="regions">tissue regions</param>
            <param name="rhos">source-detector separations</param>
            <param name="zs">depth bins</param>
            <param name="fts">temporal frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfRhoAndZAndFt(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
             Overload of scalar FluenceOfRhoAndZAndFt function. Determines fluence of tissue 'regions' and source-detector separations 'rhos' and 'zs'
             at temporal frequencies fts
            </summary>
            <param name="regions">tissue regions</param>
            <param name="rhos">source-detector separations</param>
            <param name="zs">depth bins</param>
            <param name="fts">temporal frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRho(Vts.OpticalProperties,System.Double)">
            <summary>
            Determines reflectance at source-detector separation rho
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="rho">source-detector separation (mm)</param>
            <returns>reflectance at source-detector separation rho</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Determines reflectance at source-detector separation rho and time
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at source-detector separation rho and time</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Determines reflectance at source-detector separation rho and modulation frequency ft
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at source-detector separation rho and modulation frequency ft</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFx(Vts.OpticalProperties,System.Double)">
            <summary>
            Determines reflectance at spatial frequency fx
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <returns>reflectance at spatial frequency fx</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Determines reflectance at spatial frequency fx and time
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at spatial frequency fx and time</returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Determines reflectance at spatial frequency fx and modulation frequency ft
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at spatial frequency fx and modulation frequency ft</returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfRhoAndZ(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfRhoAndZ function. Determines fluence at optical properties 'ops' and source-detector separations 'rhos' and 'zs'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfRhoAndZAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndTime function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and times 
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfRhoAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndFt function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfFxAndZ(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfFxAndZ function. Determines reflectances at optical properties 'ops' and spatial frequencies 'fxs'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfFxAndZAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfFxAndZAndTime function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and times 
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfFxAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfFxAndZAndFt function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRho(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances at optical properties 'ops' and source-detector separations 'rhos'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfRhoAndTime function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and times 
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfRhoAndFt function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFx(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfFx function. Determines reflectances at optical properties 'ops' and spatial frequencies 'fxs'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and times 
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="P:Vts.IForwardSolver.BeamDiameter">
            <summary>
            Beam Diameter
            </summary>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRho(Vts.OpticalProperties,System.Double[])">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances at optical properties 'op' and source-detector separations 'rhos'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRho(Vts.OpticalProperties[],System.Double[])">
            <summary>
            Overload of scalar ROfRho function. Determines reflectances at optical properties 'ops' and source-detector separations 'rhos'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.OpticalProperties,System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfRhoAndTime function. Determines reflectances at optical properties 'op', source-detector separations 'rhos' and times 
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfRhoAndTime function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and times 
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.OpticalProperties,System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfRhoAndFt function. Determines reflectances at optical properties 'op', source-detector separations 'rhos' and time frequencies 'fts'
            </summary>
            <param name="op">optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfRhoAndFt function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFx(Vts.OpticalProperties,System.Double[])">
            <summary>
            Overload of scalar ROfFx function. Determines reflectances at optical properties 'op' and spatial frequencies 'fxs'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFx(Vts.OpticalProperties[],System.Double[])">
            <summary>
            Overload of scalar ROfFx function. Determines reflectances at optical properties 'ops' and spatial frequencies 'fxs'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.OpticalProperties,System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances at optical properties 'op', spatial frequencies 'fxs' and times 
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and times 
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="times"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.OpticalProperties,System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances at optical properties 'op', spatial frequencies 'fxs' and time frequencies 'fts'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRho(Vts.OpticalProperties[],System.Double)">
            <summary>
            Overload of ROfRho. Determines reflectances at optical properties 'ops', and source-detector separation 'rho'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.OpticalProperties[],System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'ops', source-detector separation 'rho' and times 
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.OpticalProperties[],System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and time
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="time">time (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.OpticalProperties,System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'op', source-detector separation 'rho' and times 
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.OpticalProperties,System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'op', source-detector separations 'rhos' and time 't'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rhos">source-detector separation (mm)</param>
            <param name="time">time (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndTime(Vts.OpticalProperties[],System.Double,System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'ops', source-detector separation 'rho' and times 't'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="time">time (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.OpticalProperties[],System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at optical properties 'ops', source-detector separation 'rho' and modulation frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.OpticalProperties[],System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and modulation frequency 'ft'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.OpticalProperties,System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at optical properties 'op', source-detector separation 'rho' and modulation frequencies 'fts'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.OpticalProperties,System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at optical properties 'op', source-detector separations 'rhos' and modulation frequency 'ft'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfRhoAndFt(Vts.OpticalProperties[],System.Double,System.Double)">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at optical properties 'ops', source-detector separation 'rho' and modulation frequency 'ft'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFx(Vts.OpticalProperties[],System.Double)">
            <summary>
            Overload of scalar ROfFx function. Determines reflectances at optical properties 'ops' and spatial frequency 'fx'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.OpticalProperties[],System.Double,System.Double[])">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances at optical properties 'ops', spatial frequency 'fx' and times 
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.OpticalProperties[],System.Double[],System.Double)">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and time 
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="time">time (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.OpticalProperties,System.Double,System.Double[])">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances at optical properties 'op', spatial frequency 'fx' and times 
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.OpticalProperties,System.Double[],System.Double)">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances at optical properties 'op', spatial frequencies 'fxs' and time 't'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fxs">spatial frequency (1/mm)</param>
            <param name="time">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndTime(Vts.OpticalProperties[],System.Double,System.Double)">
            <summary>
            Overload of scalar ROfFxAndTime function. Determines reflectances at optical properties 'ops', spatial frequency 'fx' and time 't'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="time">time (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.OpticalProperties[],System.Double,System.Double[])">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances at optical properties 'ops', spatial frequency 'fx' and modulation frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.OpticalProperties[],System.Double[],System.Double)">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances at optical properties 'ops', spatial frequency 'fxs' and modulation frequency 'ft'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.OpticalProperties,System.Double,System.Double[])">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances at optical properties 'op', spatial frequency 'fx' and modulation frequencies 'fts'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.OpticalProperties,System.Double[],System.Double)">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances at optical properties 'op', spatial frequency 'fxs' and modulation frequency 'ft'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.ROfFxAndFt(Vts.OpticalProperties[],System.Double,System.Double)">
            <summary>
            Overload of scalar ROfFxAndFt function. Determines reflectances at optical properties 'ops', spatial frequency 'fx' and modulation frequencies 'ft'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfRhoAndZ(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar FluenceOfRhoAndZ function. Determines fluence at optical properties 'ops' and source-detector separations 'rhos' and 'zs'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfRhoAndZAndTime(Vts.OpticalProperties[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndTime function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos', z values 'zs' and times 
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfRhoAndZAndFt(Vts.OpticalProperties[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndTime function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos', z values 'zs' and modulation frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfFxAndZ(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndTime function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and z values 'zs'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfFxAndZAndTime(Vts.OpticalProperties[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndTime function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs', z values 'zs' and times 
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IForwardSolver.FluenceOfFxAndZAndFt(Vts.OpticalProperties[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndTime function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs', z values 'zs' and modulation frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="T:Vts.ILayerOpticalPropertyRegion">
            <summary>
            layer optical property region
            </summary>
        </member>
        <member name="P:Vts.ILayerOpticalPropertyRegion.ZRange">
            <summary>
            extent of z layer
            </summary>
        </member>
        <member name="T:Vts.INotifyPropertyChangedPlus">
            <summary>
            An adaptation of the INotifyPropertyChanged interface to include
            OnPropertyChanged method.
            </summary>
        </member>
        <member name="M:Vts.INotifyPropertyChangedPlus.OnPropertyChanged(System.String)">
            <summary>
            Method to raises the property changed event
            </summary>
            <param name="propertyName">The property that changed</param>
        </member>
        <member name="T:Vts.IOpticalPropertyRegion">
            <summary>
            interface for region optical properties
            </summary>
        </member>
        <member name="P:Vts.IOpticalPropertyRegion.RegionOP">
            <summary>
            Optical properties of tissue region.
            </summary>
        </member>
        <member name="T:Vts.IOptimizer">
            <summary>
            This is the contract for the inverse solver
            </summary>
        </member>
        <member name="M:Vts.IOptimizer.Solve(System.Double[],System.Boolean[],System.Double[],System.Double[],System.Func{System.Double[],System.Object[],System.Double[]},System.Object[])">
            <summary>
            Standard interface for all optimization libraries
            </summary>
            <param name="a">optimization parameter initial guess</param>
            <param name="ia">accompanying array to <paramref name="a"/> that specifies which parameters to fit (held constant otherwise)</param>
            <param name="y">"measured" values</param>
            <param name="ey">standard deviation values of <paramref name="y"/></param>
            <param name="forwardFunc">delegate function that evaluates the objective function given a parameter optimization array and (optional) constant variables</param>
            <param name="forwardVariables"></param>
        </member>
        <member name="M:Vts.IOptimizer.SolveWithConstraints(System.Double[],System.Boolean[],System.Double[],System.Double[],System.Double[],System.Double[],System.Func{System.Double[],System.Object[],System.Double[]},System.Object[])">
            <summary>
            Standard interface for all optimization libraries
            </summary>
            <param name="a">optimization parameter initial guess</param>
            <param name="ia">accompanying array to <paramref name="a"/> that specifies which parameters to fit (held constant otherwise)</param>
            <param name="lowerBounds">accompanying array that specifies lower bounds</param>
            <param name="upperBounds">accompanying array that specifies upper bounds</param>
            <param name="y">"measured" values</param>
            <param name="ey">standard deviation values of <paramref name="y"/></param>
            <param name="forwardFunc">delegate function that evaluates the objective function given a parameter optimization array and (optional) constant variables</param>
            <param name="forwardVariables"></param>
        </member>
        <member name="T:Vts.OpticalProperties">
            <summary>
            Describes optical properties needed as input for various 
            forward solver models.
            </summary>
        </member>
        <member name="M:Vts.OpticalProperties.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Definition of optical properties
            </summary>
            <param name="mua">absorption coefficient = probability of absorption per unit distance traveled</param>
            <param name="musp">scattering coefficient = probability of having scattered per unit distance traveled</param>
            <param name="g">anisotropy coefficient = cosine of an average scattering angle (where the angle is relative to the incoming and outgoing unit direction vectors)</param>
            <param name="n">refractive index mismatch</param>
        </member>
        <member name="M:Vts.OpticalProperties.#ctor">
            <summary>
            Creates optical properties with values 0.01, 1.0, 0.8, 1.4 for mua, musp, g and n respectively
            </summary>
        </member>
        <member name="M:Vts.OpticalProperties.#ctor(Vts.OpticalProperties)">
            <summary>
            Creates a new instance based on values from a previous instance
            </summary>
            <param name="op">optical properties of the medium</param>
        </member>
        <member name="M:Vts.OpticalProperties.#ctor(System.Double[])">
            <summary>
            Creates a new instance based on values in an array [mua, musp, g, n]
            </summary>
            <param name="op">optical properties of the medium</param>
        </member>
        <member name="P:Vts.OpticalProperties.Mua">
            <summary>
            absorption coefficient = probability of absorption per unit distance traveled
            </summary>
        </member>
        <member name="P:Vts.OpticalProperties.Mus">
            <summary>
            scattering coefficient = probability of having scattered per unit distance traveled
            </summary>
            <remarks>Warning - Setting this value also modifies Musp!</remarks>
        </member>
        <member name="P:Vts.OpticalProperties.G">
            <summary>
            anisotropy coefficient = cosine of an average scattering angle (where the angle is relative to the incoming and outgoing unit direction vectors)
            </summary>
            <remarks>Warning - Setting this value also modifies Mus!</remarks>
        </member>
        <member name="P:Vts.OpticalProperties.N">
            <summary>
            refractive index mismatch
            </summary>
        </member>
        <member name="P:Vts.OpticalProperties.Musp">
            <summary>
            reduced scattering coefficient = probability of having scattered per unit distance traveled
            </summary>
            <remarks>
            Warning - Setting this value also modifies Mus!
            Warning - This must be defined AFTER Mus and G to deserialize correctly
                      (or alternatively, we should use [IgnoreDataMember] either here or for Mus)
            </remarks>
        </member>
        <member name="M:Vts.OpticalProperties.ToString">
            <summary>
            Writes the optical properties to a string in the order Mua, Musp, G and N
            </summary>
            <returns>String of optical properties</returns>
        </member>
        <member name="T:Vts.OpticalPropertiesConverter">
            <summary>
            Describes optical properties Converter for deserializing OPs based on (mua, mus, g, n)
            not on (mua, musp, g, n)
            ref: https://stackoverflow.com/questions/23017716/json-net-how-to-deserialize-without-using-the-default-constructor/23017892#23017892
            </summary>
        </member>
        <member name="M:Vts.OpticalPropertiesConverter.CanConvert(System.Type)">
            <summary>
            method to determine if can convert object
            </summary>
            <param name="objectType">type of object</param>
            <returns>boolean indicating whether can convert</returns>
        </member>
        <member name="M:Vts.OpticalPropertiesConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            method to read json
            </summary>
            <param name="reader">JsonReader</param>
            <param name="objectType">object type</param>
            <param name="existingValue">object</param>
            <param name="serializer">JsonSerializer</param>
            <returns></returns>
        </member>
        <member name="P:Vts.OpticalPropertiesConverter.CanWrite">
            <summary>
            method to determine if can write
            </summary>
        </member>
        <member name="M:Vts.OpticalPropertiesConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            method to write to json
            </summary>
            <param name="writer">JsonWriter</param>
            <param name="value">object to be written</param>
            <param name="serializer">JsonSerializer</param>
        </member>
        <member name="T:Vts.PropertyDependencyManager">
            <summary>
            Class to manage dependencies of INotifyPropertyChanged objects,
            as suggested by Tomas Elison here:
            http://neilmosafi.blogspot.com/2008/07/is-inotifypropertychanged-anti-pattern.html
            This class builds a dependency graph the "right" way. It knows for example
            that if Quantity is changed, TotalPrice has asked to be informed about this.
            The PropertyDependencyManager listens to the PropertyChanged event for any
            class that is registered with it and uses the dependency graph to propagate
            the events the right way.
            </summary>
        </member>
        <member name="M:Vts.PropertyDependencyManager.Register(Vts.INotifyPropertyChangedPlus)">
            <summary>
            Registers the class to notify changes to properties and their dependencies
            </summary>
            <param name="target">The target class that implements INotifyPropertyChangedPlus</param>
        </member>
        <member name="T:Vts.Factories.ComputationFactory">
            <summary>
            Class that composes forward and optimization calculations based on high-level inputs
            </summary>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.IsSolverWithConstantValues(Vts.SolutionDomainType)">
            <summary>
            method to determine if forward solver is solver with constant values
            </summary>
            <param name="solutionDomainType">SolutionDomainType</param>
            <returns>boolean indicating if solver with constant values</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.IsSolverWithConstantValues(Vts.FluenceSolutionDomainType)">
            <summary>
            method to determine if forward solver is solver with constant values
            </summary>
            <param name="solutionDomainType">FluenceSolutionDomainType</param>
            <returns>boolean indicating if solver with constant values</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.IsComplexSolver(Vts.SolutionDomainType)">
            <summary>
            method to indicate whether forward solver is a complex solver
            </summary>
            <param name="solutionDomainType">SolutionDomainType</param>
            <returns>boolean indicating whether forward solver is complex or not</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.IsComplexSolver(Vts.FluenceSolutionDomainType)">
            <summary>
            method to indicate whether forward solver is a complex solver
            </summary>
            <param name="solutionDomainType">FluenceSolutionDomainType</param>
            <returns>boolean indicating whether forward solver is complex or not</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.FlattenRealAndImaginary(System.Numerics.Complex[])">
            <summary>
            method to flatten the real and imaginary parts of an array of complex values
            </summary>
            <param name="values">complex values to flatten</param>
            <returns>1D array of real (1st half) and imaginary (2nd half) </returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeReflectance(Vts.ForwardSolverType,Vts.SolutionDomainType,Vts.ForwardAnalysisType,System.Object[])">
            <summary>
            ComputeReflectance determines reflectance.  It uses the first parameter
            forwardSolverType to determine appropriate IForwardSolver and then calls the method overload with that value.
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum (e.g. PointSourceSDA, DistributedPointSourceSDA, etc.)</param>
            <param name="solutionDomainType">SolutionDomainType enum (e.g. RofRho, RofRx, etc.)</param>
            <param name="forwardAnalysisType">ForwardAnalysisType enum (e.g. R, dRdMua, dRdMusp, etc.)</param>
            <param name="independentValues">an array of objects: first element = OpticalProperties,
            second element = double[] of xaxis values, for example:
            new object[]{ new[]{ new OpticalProperties(0.01, 1, 0.8, 1.4) }, new double[] { 1, 2, 3 } })</param>
            <returns>double[] of resulting reflectance values</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeReflectance(Vts.IForwardSolver,Vts.SolutionDomainType,Vts.ForwardAnalysisType,System.Object[])">
            <summary>
            ComputeReflectance overload determines reflectance.  It uses the first parameter
            IForwardSolver instead of ForwardSolverType.
            </summary>
            <param name="forwardSolver">forward solver class</param>
            <param name="solutionDomainType">SolutionDomainType enum (e.g. RofRho, RofRx, etc.)</param>
            <param name="forwardAnalysisType">ForwardAnalysisType enum (e.g. R, dRdMua, dRdMusp, etc.)</param>
            <param name="independentValues">an array of objects: first element = OpticalProperties,
            second element = double[] of xaxis values, for example:
            new object[]{ new[]{ new OpticalProperties(0.01, 1, 0.8, 1.4) }, new double[] { 1, 2, 3 } })</param>
            <returns>double[] of resulting reflectance values</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeFluence(Vts.ForwardSolverType,Vts.FluenceSolutionDomainType,Vts.IndependentVariableAxis[],System.Double[][],Vts.OpticalProperties[],System.Double[])">
            <summary>
            ComputeFluence determines fluence. It uses the first parameter forwardSolverType to determine appropriate
            IForwardSolver and then calls the method overload with that value.
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum (e.g. PointSourceSDA, DistributedPointSourceSDA, etc.)</param>
            <param name="solutionDomainType">SolutionDomainType enum (e.g. RofRho, RofRx, etc.)</param>
            <param name="independentAxesTypes">IndependentVariableAxis enum (Rho, Time, Fx, Ft, Z)</param>
            <param name="independentValues">double array of independent type axis values</param>
            <param name="opticalProperties">array of optical properties</param>
            <param name="constantValues">double array of variable length with the constant values</param>
            <returns>double[] of resulting reflectance values</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeFluence(Vts.ForwardSolverType,Vts.FluenceSolutionDomainType,Vts.IndependentVariableAxis[],System.Double[][],Vts.OpticalProperties,System.Double[])">
            <summary>
            ComputeFluence overload determines fluence which uses the first parameter ForwardSolverType to determine
            appropriate IForwardSolver and then calls overload.
            This overload also has a single set of OpticalProperties parameter rather than an array.
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum (e.g. PointSourceSDA, DistributedPointSourceSDA, etc.)</param>
            <param name="solutionDomainType">FluenceSolutionDomainType enum (e.g. FluenceOfRhoAndZ, FluenceOfFxAndZ etc.)</param>
            <param name="independentAxesTypes">IndependentVariableAxis enum (Rho, Time, Fx, Ft, Z)</param>
            <param name="independentValues">double array of independent axis type values</param>
            <param name="opticalProperties">single set of optical properties</param>
            <param name="constantValues">double array of variable length with the constant values</param>
            <returns>double[] of resulting reflectance values</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeFluence(Vts.ForwardSolverType,Vts.FluenceSolutionDomainType,Vts.IndependentVariableAxis[],System.Double[][],Vts.IOpticalPropertyRegion[],System.Double[])">
            <summary>
            ComputeFluence overload computes fluence
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum (e.g. PointSourceSDA, DistributedPointSourceSDA, etc.)</param>
            <param name="solutionDomainType">FluenceSolutionDomainType enum (e.g. FluenceOfRhoAndZ, FluenceOfFxAndZ etc.)</param>
            <param name="independentAxesTypes">array of IndependentVariableAxis enum (Rho, Time, Fx, Ft, Z)</param>
            <param name="independentValues"></param>
            <param name="tissueRegions"></param>
            <param name="constantValues">double array of variable length with the constant values</param>
            <returns>double[] of resulting linearized fluence values</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeFluence(Vts.IForwardSolver,Vts.FluenceSolutionDomainType,Vts.IndependentVariableAxis[],System.Double[][],Vts.IOpticalPropertyRegion[],System.Double[])">
            <summary>
            ComputeFluence overload determines fluence given the input parameters.  
            </summary>
            <param name="forwardSolver">forward solver class</param>
            <param name="solutionDomainType">FluenceSolutionDomainType enum (e.g. FluenceOfRhoAndZ, FluenceOfFxAndZ etc.)</param>
            <param name="independentAxesTypes">array of IndependentVariableAxis enum (Rho, Time, Fx, Ft, Z)</param>
            <param name="independentValues">double array of independent type axis values</param>
            <param name="tissueRegions">array of IOpticalPropertyRegion which allows for multi-region tissue</param>
            <param name="constantValues">double array of variable length with the constant values</param>
            <returns>double[] of resulting linearized fluence value</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeFluence(Vts.IForwardSolver,Vts.FluenceSolutionDomainType,Vts.IndependentVariableAxis[],System.Double[][],Vts.OpticalProperties[],System.Double[])">
            <summary>
            ComputeFluence overload computes fluence for specified forward solver.
            </summary>
            <param name="forwardSolver">forward solver class</param>
            <param name="solutionDomainType">FluenceSolutionDomainType enum (e.g. FluenceOfRhoAndZ, FluenceOfFxAndZ etc.)</param>
            <param name="independentAxesTypes">array of IndependentVariableAxis enum (Rho, Time, Fx, Ft, Z)</param>
            <param name="independentValues">double array of independent type axis values</param>
            <param name="opticalProperties">array of optical properties</param>
            <param name="constantValues">double array of variable length with the constant values</param>
            <returns>double[] of resulting linearized fluence value</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeFluence(Vts.IForwardSolver,Vts.FluenceSolutionDomainType,Vts.IndependentVariableAxis[],System.Double[][],Vts.OpticalProperties,System.Double[])">
            <summary>
            ComputeFluence determines fluence.  This overload has a single set of OpticalProperties parameters
            rather than an array.
            </summary>
            <param name="forwardSolver">forward solver class</param>
            <param name="solutionDomainType">FluenceSolutionDomainType enum (e.g. FluenceOfRhoAndZ, FluenceOfFxAndZ etc.)</param>
            <param name="independentAxesTypes">array of IndependentVariableAxis enum (Rho, Time, Fx, Ft, Z)</param>
            <param name="independentValues">double array of independent type axis values</param>
            <param name="opticalProperties">single set of optical properties</param>
            <param name="constantValues">double array of variable length with the constant values</param>
            <returns>double[] of resulting linearized fluence value</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeFluenceComplex(Vts.ForwardSolverType,Vts.FluenceSolutionDomainType,Vts.IndependentVariableAxis[],System.Double[][],Vts.OpticalProperties,System.Double[])">
            <summary>
            ComputeFluenceComplex computes fluence for complex forward solvers.
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum (e.g. PointSourceSDA, DistributedPointSourceSDA, etc.)</param>
            <param name="solutionDomainType">FluenceSolutionDomainType enum (e.g. FluenceOfRhoAndZAndFt, FluenceOfFxAndZAndFt etc.)</param>
            <param name="independentAxesTypes">array of IndependentVariableAxis enum (Rho, Time, Fx, Ft, Z)</param>
            <param name="independentValues">double array of independent type axis values</param>
            <param name="opticalProperties">single set of optical properties</param>
            <param name="constantValues">double array of variable length with the constant values</param>
            <returns>Complex[] of resulting linearized fluence value</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeFluenceComplex(Vts.ForwardSolverType,Vts.FluenceSolutionDomainType,Vts.IndependentVariableAxis[],System.Double[][],Vts.IOpticalPropertyRegion[],System.Double[])">
            <summary>
            ComputeFluenceComplex overload computes fluence for complex forward solvers.
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum (e.g. PointSourceSDA, DistributedPointSourceSDA, etc.)</param>
            <param name="solutionDomainType">FluenceSolutionDomainType enum (e.g. FluenceOfRhoAndZAndFt, FluenceOfFxAndZAndFt etc.)</param>
            <param name="independentAxesTypes">array of IndependentVariableAxis enum (Rho, Time, Fx, Ft, Z)</param>
            <param name="independentValues">double array of independent type axis values</param>
            <param name="tissueRegions">array of IOpticalPropertyRegions</param>
            <param name="constantValues">double array of variable length with the constant values</param>
            <returns>Complex[] of resulting linearized fluence value</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeFluenceComplex(Vts.IForwardSolver,Vts.FluenceSolutionDomainType,Vts.IndependentVariableAxis[],System.Double[][],Vts.OpticalProperties,System.Double[])">
            <summary>
            ComputeFluenceComplex overload computes fluence for complex forward solvers.
            </summary>
            <param name="forwardSolver">forward solver class</param>
            <param name="solutionDomainType">FluenceSolutionDomainType enum (e.g. FluenceOfRhoAndZAndFt, FluenceOfFxAndZAndFt etc.)</param>
            <param name="independentAxesTypes">array of IndependentVariableAxis enum (Rho, Time, Fx, Ft, Z)</param>
            <param name="independentValues">double array of independent type axis values</param>
            <param name="opticalProperties">single set of optical properties</param>
            <param name="constantValues">double array of variable length with the constant values</param>
            <returns>Complex[] of resulting linearized fluence value</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.ComputeFluenceComplex(Vts.IForwardSolver,Vts.FluenceSolutionDomainType,Vts.IndependentVariableAxis[],System.Double[][],Vts.IOpticalPropertyRegion[],System.Double[])">
            <summary>
            ComputeFluenceComplex overload computes fluence for complex forward solvers. Overload
            parameter specifies tissue regions using IOpticalPropertyRegion[] instead of a single set of
            optical properties.
            </summary>
            <param name="forwardSolver">forward solver class</param>
            <param name="solutionDomainType">FluenceSolutionDomainType enum (e.g. FluenceOfRhoAndZAndFt, FluenceOfFxAndZAndFt etc.)</param>
            <param name="independentAxesTypes">array of IndependentVariableAxis enum (Rho, Time, Fx, Ft, Z)</param>
            <param name="independentValues">double array of independent type axis values</param>
            <param name="tissueRegions">array of IOpticalPropertyRegions</param>
            <param name="constantValues">double array of variable length with the constant values</param>
            <returns>Complex[] of resulting linearized fluence value</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.GetPHD(Vts.ForwardSolverType,System.Double[],System.Double,Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Overload of GetPHD that uses internal DI framework-supplied solver singletons
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum (e.g. PointSourceSDA, DistributedPointSourceSDA, etc.)</param>
            <param name="fluence">linearized fluence to be used to generate PHD, column major</param>
            <param name="sdSeparation">source detector separation (in mm)</param>
            <param name="ops">optical properties</param>
            <param name="rhos">detector locations (in mm)</param>
            <param name="zs">z values (in mm)</param>
            <returns>double[] of resulting linearized PHD values</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.GetPHD(Vts.IForwardSolver,System.Double[],System.Double,Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Method to generate Photon Hitting Density (PHD) Map 
            </summary>
            <param name="forwardSolver">forward solver class</param>
            <param name="fluence">linearized fluence used to generate PHD, column major</param>
            <param name="sdSeparation">source detector separation (in mm)</param>
            <param name="ops">optical properties</param>
            <param name="rhos">detector locations (in mm)</param>
            <param name="zs">z values (in mm)</param>
            <returns>double[] of resulting linearized PHD values</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.GetPHD(Vts.ForwardSolverType,System.Numerics.Complex[],System.Double,System.Double,Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Overload of GetPHD that uses internal DI framework-supplied solver singletons
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum (e.g. PointSourceSDA, DistributedPointSourceSDA, etc.)</param>
            <param name="fluence">linearized fluence used to generate PHD, column major</param>
            <param name="sdSeparation">source detector separation (in mm)</param>
            <param name="timeModulationFrequency">modulation frequency of Time-Domain fluence</param>
            <param name="ops">optical properties</param>
            <param name="rhos">detector locations (in mm)</param>
            <param name="zs">z values (in mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.GetPHD(Vts.IForwardSolver,System.Numerics.Complex[],System.Double,System.Double,Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Method to generate Photon Hitting Density (PHD) map
            </summary>
            <param name="forwardSolver">forward solver class</param>
            <param name="fluence">linearized fluence used to generate PHD, column major</param>
            <param name="sdSeparation">source detector separation (in mm)</param>
            <param name="modulationFrequency">modulation frequency of Time-Domain fluence</param>
            <param name="ops">optical properties</param>
            <param name="rhos">detector locations (in mm)</param>
            <param name="zs">z values (in mm)</param>
            <returns>double[] of resulting linearized PHD values</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.GetAbsorbedEnergy(System.Collections.Generic.IEnumerable{System.Double},System.Double)">
            <summary>
            Method to generate absorbed energy given fluence and mua.  Note only works for homogeneous tissue.
            </summary>
            <param name="fluence">fluence serialized to a 1D IEnumerable of double</param>
            <param name="mua">absorption coefficient for entire tissue</param>
            <returns>absorbed energy in a 1D IEnumerable of double</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.GetAbsorbedEnergy(System.Collections.Generic.IEnumerable{System.Numerics.Complex},System.Double)">
            <summary>
            Method to generate absorbed energy given fluence and mua.  Note only works for homogeneous tissue.
            </summary>
            <param name="fluence">fluence serialized to a 1D IEnumerable of double</param>
            <param name="mua">absorption coefficient for entire tissue</param>
            <returns>absorbed energy in a 1D IEnumerable of double</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.GetAbsorbedEnergy(System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Method to generate absorbed energy given fluence and mua for heterogeneous tissue.
            </summary>
            <param name="fluence">fluence serialized to a 1D IEnumerable</param>
            <param name="muas">absorption coefficient serialized to a 1D IEnumerable with Count equal to that of fluence</param>
            <returns>absorbed energy in a 1D IEnumerable of double</returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.SolveInverse(Vts.ForwardSolverType,Vts.OptimizerType,Vts.SolutionDomainType,System.Double[],System.Double[],Vts.InverseFitType,System.Object[])">
            <summary>
            Method to provide the inverse solution.
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum (e.g. PointSourceSDA, DistributedPointSourceSDA, etc.)</param>
            <param name="optimizerType">OptimizerType enum (e.g. MPFitLevenbergMarquardt)</param>
            <param name="solutionDomainType">>SolutionDomainType enum (e.g. ROfRho, ROfFx)</param>
            <param name="dependentValues">measured data length = x axis variable count</param>
            <param name="standardDeviationValues">standard deviation of measured data</param>
            <param name="inverseFitType">InverseFitType enum (e.g. Mua, Musp, MuaMusp, MuaMuspG)</param>
            <param name="independentValues">an array of objects: first element = OpticalProperties,
            second element = double[] of x axis values, for example:
            new object[]{ new[]{ new OpticalProperties(0.01, 1, 0.8, 1.4) }, new double[] { 1, 2, 3 } })</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.SolveInverse(Vts.IForwardSolver,Vts.IOptimizer,Vts.SolutionDomainType,System.Double[],System.Double[],Vts.InverseFitType,System.Object[])">
            <summary>
            
            </summary>
            <param name="forwardSolver">forward solver class</param>
            <param name="optimizer">optimizer class</param>
            <param name="solutionDomainType">>SolutionDomainType enum (e.g. ROfRho, ROfFx)</param>
            <param name="dependentValues">measured data length = x axis variable count</param>
            <param name="standardDeviationValues">standard deviation of measured data</param>
            <param name="inverseFitType">InverseFitType enum (e.g. Mua, Musp, MuaMusp, MuaMuspG)</param>
            <param name="independentValues">an array of objects: first element = OpticalProperties,
            second element = double[] of x axis values, for example:
            new object[]{ new[]{ new OpticalProperties(0.01, 1, 0.8, 1.4) }, new double[] { 1, 2, 3 } })</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.SolveInverse(Vts.ForwardSolverType,Vts.OptimizerType,Vts.SolutionDomainType,System.Double[],System.Double[],Vts.InverseFitType,System.Object[],System.Double[],System.Double[])">
            <summary>
            
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum (e.g. PointSourceSDA, DistributedPointSourceSDA, etc.)</param>
            <param name="optimizerType">OptimizerType enum (e.g. MPFitLevenbergMarguardt</param>
            <param name="solutionDomainType">SolutionDomainType enum (e.g. ROfRho, ROfFx)</param>
            <param name="dependentValues">measured data length = x axis variable count</param>
            <param name="standardDeviationValues">standard deviation of measured data</param>
            <param name="inverseFitType">InverseFitType enum (e.g. Mua, Musp, MuaMusp, MuaMuspG)</param>
            <param name="independentValues">an array of objects: first element = OpticalProperties,
            second element = double[] of x axis values, for example:
            new object[]{ new[]{ new OpticalProperties(0.01, 1, 0.8, 1.4) }, new double[] { 1, 2, 3 } })</param>
            <param name="lowerBounds">constrained fit with lower bounds for OPs, size = 4 for all OPs</param>
            <param name="upperBounds">constrained fit with upper bounds for OPs, size = 4 for all OPs</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.SolveInverse(Vts.IForwardSolver,Vts.IOptimizer,Vts.SolutionDomainType,System.Double[],System.Double[],Vts.InverseFitType,System.Object[],System.Double[],System.Double[])">
            <summary>
            
            </summary>
            <param name="forwardSolver">forward solver class</param>
            <param name="optimizer">optimizer class</param>
            <param name="solutionDomainType">>SolutionDomainType enum (e.g. ROfRho, ROfFx)</param>
            <param name="dependentValues">measured data length = x axis variable count</param>
            <param name="standardDeviationValues">standard deviation of measured data</param>
            <param name="inverseFitType">InverseFitType enum (e.g. Mua, Musp, MuaMusp, MuaMuspG)</param>
            <param name="independentValues">an array of objects: first element = OpticalProperties,
            second element = double[] of xaxis values, for example:
            new object[]{ new[]{ new OpticalProperties(0.01, 1, 0.8, 1.4) }, new double[] { 1, 2, 3 } })</param>
            <param name="lowerBounds"></param>
            <param name="upperBounds"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Factories.ComputationFactory.UnFlattenOpticalProperties(System.Double[])">
            <summary>
            method to rehydrate OpticalProperties class from array of doubles
            </summary>
            <param name="ops">array of doubles to unflatten</param>
            <returns>array of OpticalProperties</returns>
        </member>
        <member name="T:Vts.Factories.SolverFactory">
            <summary>
            factory methods for solvers
            </summary>
        </member>
        <member name="M:Vts.Factories.SolverFactory.#cctor">
            <summary>
            constructor for solver factory
            </summary>
        </member>
        <member name="M:Vts.Factories.SolverFactory.RegisterClassesToEnumTypesByConvention``2(System.String)">
            <summary>
            Uses convention to map classes implementing TInterface to enum types
            e.g. ForwardSolverType.Nurbs will register to NurbsForwardSolver 
            This is done for each enum type that correctly matches the interface name
            </summary>
            <typeparam name="TEnum"></typeparam>
            <typeparam name="TInterface"></typeparam>
            <param name="namespaceString"></param>
        </member>
        <member name="M:Vts.Factories.SolverFactory.GetForwardSolver(Vts.ForwardSolverType)">
            <summary>
            method to get forward solver from enum type
            </summary>
            <param name="forwardSolverType">ForwardSolverType enum</param>
            <returns>IForwardSolver</returns>
        </member>
        <member name="M:Vts.Factories.SolverFactory.GetForwardSolver(System.String)">
            <summary>
            method to get forward solver from string name
            </summary>
            <param name="forwardSolverType">string name</param>
            <returns>IForwardSolver</returns>
        </member>
        <member name="M:Vts.Factories.SolverFactory.GetScattererType(Vts.ScatteringType)">
            <summary>
            method to get Scatter from enum
            </summary>
            <param name="scatteringType">ScatteringType enum</param>
            <returns>IScatter</returns>
        </member>
        <member name="M:Vts.Factories.SolverFactory.GetScattererType(System.String)">
            <summary>
            method to get Scatter from scattering name string
            </summary>
            <param name="scatteringType">scattering string name</param>
            <returns>IScatter</returns>
        </member>
        <member name="M:Vts.Factories.SolverFactory.GetOptimizer(Vts.OptimizerType)">
            <summary>
            method to get optimizer from enum
            </summary>
            <param name="type">OptimizerType enum</param>
            <returns>IOptimizer</returns>
        </member>
        <member name="M:Vts.Factories.SolverFactory.GetOptimizer(System.String)">
            <summary>
            method to get optimizer from name string
            </summary>
            <param name="optimizerType">optimizer name string</param>
            <returns>IOptimizer</returns>
        </member>
        <member name="T:Vts.IO.ArrayCustomBinaryReader`1">
            <summary>
            Class that implements the interface ICustomBinaryReader to read different types of Array from a binary stream
            </summary>
            <typeparam name="T">Type of Array to be read</typeparam>
        </member>
        <member name="M:Vts.IO.ArrayCustomBinaryReader`1.#ctor(System.Int32[])">
            <summary>
            Constructor for reading a multi-dimensional Array
            </summary>
            <param name="dims">An array of integers to represent the lengths of a multi-dimensional Array</param>
        </member>
        <member name="M:Vts.IO.ArrayCustomBinaryReader`1.#ctor(System.Int32)">
            <summary>
            Constructor for reading an Array of size length
            </summary>
            <param name="length">Length of the Array</param>
        </member>
        <member name="M:Vts.IO.ArrayCustomBinaryReader`1.ReadFromBinary(System.IO.BinaryReader)">
            <summary>
            Read an Array from a binary stream
            </summary>
            <param name="br">Binary stream reader</param>
            <returns>An Array, read from the binary stream</returns>
        </member>
        <member name="T:Vts.IO.ArrayCustomBinaryWriter">
            <summary>
            Class that implements the interface ICustomBinaryWriter to write different types of Array to a binary stream supported types are double, float, ushort, Complex and byte
            </summary>
        </member>
        <member name="M:Vts.IO.ArrayCustomBinaryWriter.WriteToBinary(System.IO.BinaryWriter,System.Array)">
            <summary>
            Write Array to a binary stream
            </summary>
            <param name="bw">The binary stream in which to write the data</param>
            <param name="input">The Array to write</param>
        </member>
        <member name="T:Vts.IO.BinaryArraySerializer">
            <summary>
            class to write detector arrays to/from binary files
            </summary>
        </member>
        <member name="P:Vts.IO.BinaryArraySerializer.DataArray">
            <summary>
            array to be written or read
            </summary>
        </member>
        <member name="P:Vts.IO.BinaryArraySerializer.Name">
            <summary>
            name of array
            </summary>
        </member>
        <member name="P:Vts.IO.BinaryArraySerializer.FileTag">
            <summary>
            file tag string
            </summary>
        </member>
        <member name="P:Vts.IO.BinaryArraySerializer.Dimensions">
            <summary>
            dimensions of array
            </summary>
        </member>
        <member name="P:Vts.IO.BinaryArraySerializer.WriteData">
            <summary>
            method to write data
            </summary>
        </member>
        <member name="P:Vts.IO.BinaryArraySerializer.ReadData">
            <summary>
            method to read data
            </summary>
        </member>
        <member name="T:Vts.IO.ConventionBasedConverter`1">
            <summary>
            class to deserialize json
            from http://stackoverflow.com/questions/8030538/how-to-implement-custom-jsonconverter-in-json-net-to-deserialize-a-list-of-base
            </summary>
            <typeparam name="TInterface"></typeparam>
        </member>
        <member name="T:Vts.IO.ConventionBasedConverter`1.VtsClassInfo">
            <summary>
            Internal class for holding on to necessary class info for future instantiation
            </summary>
        </member>
        <member name="M:Vts.IO.ConventionBasedConverter`1.#cctor">
            <summary>
            Static constructor for VtsJsonSerializer
            </summary>
        </member>
        <member name="M:Vts.IO.ConventionBasedConverter`1.#ctor(System.Type,System.String,System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Returns an instance of ConventionBasedConverter
            </summary>
            <param name="exampleType">Type</param>
            <param name="typeCategoryString">string describing category</param>
            <param name="classPrefixStrings">IEnumerable of string</param>
            <param name="classBasename">name of base class</param>
        </member>
        <member name="M:Vts.IO.ConventionBasedConverter`1.CreateFromEnum``1(System.Type,System.String)">
            <summary>
            method to create ConventionBasedConverter from enum
            </summary>
            <typeparam name="TEnum">enum</typeparam>
            <param name="exampleType">Type</param>
            <param name="classBasename">name of base class</param>
            <returns>ConventionBasedConverter</returns>
        </member>
        <member name="M:Vts.IO.ConventionBasedConverter`1.Create(System.Type,Newtonsoft.Json.Linq.JObject)">
            <summary>
            method to create TInterface given Type and JObject
            </summary>
            <param name="objectType">Type</param>
            <param name="jObject">JObject</param>
            <returns>TInterface</returns>
        </member>
        <member name="M:Vts.IO.ConventionBasedConverter`1.FieldExists(System.String,Newtonsoft.Json.Linq.JObject)">
            <summary>
            method to determine if field exists
            </summary>
            <param name="fieldName">name of field string</param>
            <param name="jObject">JObject object to check</param>
            <returns>boolean indicating if field exists</returns>
        </member>
        <member name="T:Vts.IO.CustomBinaryStreamWriter`1">
            <summary>
            Class to write specified types to a binary stream
            </summary>
            <typeparam name="T">Type of the data</typeparam>
        </member>
        <member name="M:Vts.IO.CustomBinaryStreamWriter`1.#ctor(System.String,Vts.IO.ICustomBinaryWriter{`0})">
            <summary>
            Constructor
            </summary>
            <param name="fileName">Name of the binary file to write</param>
            <param name="binaryWriter"></param>
        </member>
        <member name="M:Vts.IO.CustomBinaryStreamWriter`1.#ctor(System.String,System.Action{System.IO.BinaryWriter,`0})">
            <summary>
            
            </summary>
            <param name="fileName">Name of the binary file</param>
            <param name="writeMap"></param>
        </member>
        <member name="P:Vts.IO.CustomBinaryStreamWriter`1.IsOpen">
            <summary>
            Value to check if the file is open for writing
            </summary>
        </member>
        <member name="P:Vts.IO.CustomBinaryStreamWriter`1.Count">
            <summary>
            The number of items that have been written
            </summary>
        </member>
        <member name="P:Vts.IO.CustomBinaryStreamWriter`1.PreWriteAction">
            <summary>
            Optional code that will be run before the database begins writing (after call to Open())
            </summary>
        </member>
        <member name="P:Vts.IO.CustomBinaryStreamWriter`1.PostWriteAction">
            <summary>
            Optional code that will be run after the database has completed writing (on call to Close() or Dispose())
            </summary>
        </member>
        <member name="M:Vts.IO.CustomBinaryStreamWriter`1.OpenStream">
            <summary>
            Opens the filestream for subsequent calls to WriteDataPoint or WriteDataPoints
            </summary>
        </member>
        <member name="M:Vts.IO.CustomBinaryStreamWriter`1.Write(`0)">
            <summary>
            Writes a single data point to the underlying filestream
            </summary>
            <param name="item">Single data point to be written</param>
        </member>
        <member name="M:Vts.IO.CustomBinaryStreamWriter`1.Write(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Writes an enumerable list of data points to the underlying filestream
            </summary>
            <param name="items">A list of data points to be written</param>
        </member>
        <member name="M:Vts.IO.CustomBinaryStreamWriter`1.Close">
            <summary>
            Closes the filestream and writes the accompanying .xml
            </summary>
        </member>
        <member name="M:Vts.IO.CustomBinaryStreamWriter`1.Dispose">
            <summary>
            Closes the file and writes the accompanying .xml
            </summary>
        </member>
        <member name="M:Vts.IO.CustomBinaryStreamWriter`1.Finalize">
            <summary>
            Custom binary stream writer
            </summary>
        </member>
        <member name="T:Vts.IO.FileIO">
            <summary>
            This class includes methods for saving and loading JSON text and binary data
            It uses custom iterators for saving (unfortunately, nothing as useful for reading value types)
            Currently, float, double and ushort are supported (and they're processed in that order)
            </summary>
        </member>
        <member name="M:Vts.IO.FileIO.FileExists(System.String)">
            <summary>
            Static method to check if a file exists
            </summary>
            <param name="fileName">Name of the file</param>
        </member>
        <member name="M:Vts.IO.FileIO.DirectoryExists(System.String)">
            <summary>
            Static method to check if a directory exists
            </summary>
            <param name="folder">Name of the directory</param>
        </member>
        <member name="M:Vts.IO.FileIO.FileDelete(System.String)">
            <summary>
            Static method to delete a file
            </summary>
            <param name="fileName">Name of the file to delete</param>
        </member>
        <member name="M:Vts.IO.FileIO.DeleteDirectory(System.String)">
            <summary>
            Static method to delete a directory
            </summary>
            <param name="folder">Name of the directory to delete</param>
        </member>
        <member name="M:Vts.IO.FileIO.Clone``1(``0)">
            <summary>
            Static method to clone an object
            </summary>
            <typeparam name="T">Type of the object</typeparam>
            <param name="myObject">The object to clone</param>
            <returns>A clone of the object</returns>
        </member>
        <member name="M:Vts.IO.FileIO.CopyStream(System.IO.Stream,System.IO.Stream)">
            <summary>
            Copies one stream to the other
            </summary>
            <param name="input"></param>
            <param name="output"></param>
            <remarks>See http://stackoverflow.com/questions/230128/best-way-to-copy-between-two-stream-instances-c </remarks>
        </member>
        <member name="M:Vts.IO.FileIO.CreateDirectory(System.String)">
            <summary>
            Platform-agnostic directory creation
            </summary>
            <param name="folderPath">Path for new directory</param>
        </member>
        <member name="M:Vts.IO.FileIO.ClearDirectory(System.String)">
            <summary>
            Platform-agnostic directory
            </summary>
            <param name="folderPath">Path for new directory</param>
        </member>
        <member name="M:Vts.IO.FileIO.CreateEmptyDirectory(System.String)">
            <summary>
            Platform-agnostic call to create an empty directory (deleting files if they exist)
            </summary>
            <param name="folderPath">Path for new directory</param>
        </member>
        <member name="M:Vts.IO.FileIO.WriteToXMLStream``1(``0,System.IO.Stream)">
            <summary>
            Static method to write an object to a stream
            </summary>
            <typeparam name="T">Type of the object to be written</typeparam>
            <param name="myObject">Object to be written</param>
            <param name="stream">Stream to which to write the object</param>
        </member>
        <member name="M:Vts.IO.FileIO.WriteJsonToStream``1(``0,System.IO.Stream)">
            <summary>
            Static method to write an object to a stream
            </summary>
            <typeparam name="T">Type of the object to be written</typeparam>
            <param name="myObject">Object to be written</param>
            <param name="stream">Stream to which to write the object</param>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromStream``1(System.IO.Stream)">
            <summary>
            Static method to read a specified type from a stream
            </summary>
            <typeparam name="T">Type of the data to be read</typeparam>
            <param name="stream">Stream from which to read</param>
            <returns>The data as the specified type</returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromJsonStream``1(System.IO.Stream)">
            <summary>
            Static method to read a specified type from a stream
            </summary>
            <typeparam name="T">Type of the data to be read</typeparam>
            <param name="stream">Stream from which to read</param>
            <returns>The data as the specified type</returns>
        </member>
        <member name="M:Vts.IO.FileIO.WriteTextToStream(System.String,System.IO.Stream)">
            <summary>
            Writes the string to a stream
            </summary>
            <param name="text">Text to write to the file</param>
            <param name="stream">Name of the stream</param>
        </member>
        <member name="M:Vts.IO.FileIO.WriteToTextFile(System.String,System.String)">
            <summary>
            Writes the string to a text file
            </summary>
            <param name="text">Text to write to the file</param>
            <param name="filename">Name of the text file to write </param>
        </member>
        <member name="M:Vts.IO.FileIO.WriteToXML``1(``0,System.String)">
            <summary>
            Writes data of a specified type to an XML file
            </summary>
            <typeparam name="T">Type of the data to be written</typeparam>
            <param name="myObject">Object to be written</param>
            <param name="filename">Name of the XML file to write</param>
        </member>
        <member name="M:Vts.IO.FileIO.WriteToJson``1(``0,System.String)">
            <summary>
            Writes data of a specified type to an JSON file
            </summary>
            <typeparam name="T">Type of the data to be written</typeparam>
            <param name="myObject">Object to be written</param>
            <param name="filename">Name of the JSON file to write</param>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromXML``1(System.String)">
            <summary>
            Reads data of a specified type from an XML file
            </summary>
            <typeparam name="T">Type of the data</typeparam>
            <param name="filename">Name of the XML file to be read</param>
            <returns>The data as the specified type</returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromJson``1(System.String)">
            <summary>
            Reads data of a specified type from a JSON file
            </summary>
            <typeparam name="T">Type of the data</typeparam>
            <param name="filename">Name of the JSON file to be read</param>
            <returns>The data as the specified type</returns>
        </member>
        <member name="M:Vts.IO.FileIO.CopyFileFromResources(System.String,System.String,System.String)">
            <summary>
            Copy a file from resources to an external location
            </summary>
            <example>FileIO.CopyFileFromResources("Resources/resourcesfile.txt", Path.Combine(resultsFolder, "resourcefile.txt"), "Vts.Desktop.Test");</example>
            <param name="sourceFileName">Path and filename of the file in resources</param>
            <param name="destinationFileName">Path and filename of the destination location</param>
            <param name="projectName">The name of the project where the file in resources is located</param>
        </member>
        <member name="M:Vts.IO.FileIO.CopyFileFromEmbeddedResources(System.String,System.String,System.String)">
            <summary>
            Copy a file from embedded resources in the project assembly and 
            copies to an external location
            </summary>
            <param name="sourceFileName">Path and filename of the file in resources</param>
            <param name="destinationFileName">Path and filename of the destination location</param>
            <param name="projectName">The name of the project where the file is located</param>
        </member>
        <member name="M:Vts.IO.FileIO.CopyFolderFromEmbeddedResources(System.String,System.String,System.String,System.Boolean)">
            <summary>
            Copy a folder and its contents to an external location.
            Due to the file and folder delimeters being a dot, there are 
            some assumptions with this method. The file extension must be 
            only 3 characters and a file without an extension must have a 
            name with more than 3 characters.
            </summary>
            <param name="folderName">Name of the folder to copy</param>
            <param name="destinationFolder">Name of the destination folder to copy the folder</param>
            <param name="projectName">Name of the project where the file is located</param>
            <param name="includeFolder">Boolean value to determine whether to include the containing folder</param>
            <returns>Returns a list of the copied files</returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromXMLInResources``1(System.String,System.String)">
            <summary>
            Reads data of a specified type from an XML file in resources
            </summary>
            <typeparam name="T">Type of the data</typeparam>
            <param name="fileName">Name of the XML file to be read</param>
            <param name="projectName">Project name for the location of resources</param>
            <returns>The data as the specified type</returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromJsonInResources``1(System.String,System.String)">
            <summary>
            Reads data of a specified type from an JSON file in resources
            </summary>
            <typeparam name="T">Type of the data</typeparam>
            <param name="fileName">Name of the JSON file to be read</param>
            <param name="projectName">Project name for the location of resources</param>
            <returns>The data as the specified type</returns>
        </member>
        <member name="M:Vts.IO.FileIO.WriteScalarValueToBinary``1(``0,System.String,System.Action{System.IO.BinaryWriter,``0})">
            <summary>
            Writes a scalar value to a binary file
            </summary>
            <typeparam name="T">Type of the data to be written</typeparam>
            <param name="dataIN">Data to be written</param>
            <param name="filename">Name of the binary file to write</param>
            <param name="writeMap"></param>
        </member>
        <member name="M:Vts.IO.FileIO.ReadScalarValueFromBinary``1(System.String,System.Func{System.IO.BinaryReader,``0})">
            <summary>
            Reads a scalar value from a binary file
            </summary>
            <typeparam name="T">Type of data to be read</typeparam>
            <param name="filename">Name of the binary file</param>
            <param name="readMap"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.IO.FileIO.WriteArrayToBinary(System.Array,System.String,System.Boolean)">
            <summary>
            Writes an array to a binary file and optionally accompanying .xml file 
            (to store array dimensions) if includeMetaData = true
            </summary>
            <param name="dataIN">Array to be written</param>
            <param name="filename">Name of the file where the data is written</param>
            <param name="includeMetaData">Boolean to determine whether to include meta data, if set to true, an accompanying XML file will be created with the same name</param>
        </member>
        <member name="M:Vts.IO.FileIO.WriteArrayToBinary(System.Array,System.String)">
            <summary>
            Writes an array to a binary file, as well as an accompanying .txt (JSON) file to store array dimensions
            </summary>
            <param name="dataIN">Array to be written</param>
            <param name="filename">Name of the file to which the array is written</param>
        </member>
        <member name="M:Vts.IO.FileIO.ReadArrayFromBinary``1(System.String)">
            <summary>
            Reads array from a binary file, using the accompanying .txt file to specify dimensions
            </summary>
            <typeparam name="T">Type of the array being read</typeparam>
            <param name="filename">Name of the file from which to read the array</param>
            <returns>Array from the file</returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadArrayFromBinary``1(System.String,System.Int32[])">
            <summary>
            Reads array from a binary file using explicitly-set dimensions
            </summary>
            <typeparam name="T">Type of the array being read</typeparam>
            <param name="filename">Name of the file from which to read the array</param>
            <param name="dims">Dimensions of the array</param>
            <returns>Array from the file</returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadArrayFromBinaryInResources``1(System.String,System.String)">
            <summary>
            Reads array from a binary file in resources, using the accompanying .txt (JSON) file to specify dimensions
            </summary>
            <typeparam name="T">Type of the array being read</typeparam>
            <param name="filename">Name of the JSON file containing the meta data</param>
            <param name="projectname">Project name for the location of resources</param>
            <returns>Array from the file</returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadArrayFromBinaryInResources``1(System.String,System.String,System.Int32[])">
            <summary>
            Reads array from a binary file in resources using explicitly-set dimensions
            </summary>
            <typeparam name="T">Type of the array being read</typeparam>
            <param name="filename">Name of the JSON (text) file containing the meta data</param>
            <param name="projectname">Project name for the location of resources</param>
            <param name="dims">Dimensions of the array</param>
            <returns>Array from the file</returns>
        </member>
        <member name="M:Vts.IO.FileIO.WriteToBinaryCustom``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Action{System.IO.BinaryWriter,``0})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="data"></param>
            <param name="fileName">Name of the binary file to write</param>
            <param name="writerMap"></param>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromBinaryCustom``1(System.String,System.Func{System.IO.BinaryReader,``0})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fileName">Name of the binary file to read</param>
            <param name="readerMap"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromBinaryInResourcesCustom``1(System.String,System.String,System.Func{System.IO.BinaryReader,``0})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="fileName">Name of the binary file to read</param>
            <param name="projectName">Project name where resources is located</param>
            <param name="readerMap"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadStreamFromBinaryCustom``1(System.IO.Stream,System.Func{System.IO.BinaryReader,``0})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="s"></param>
            <param name="readerMap"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromBinary``1(System.String)">
            <summary>
            Read from a binary stream
            </summary>
            <typeparam name="T"></typeparam>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromBinaryInResources``1(System.String,System.String)">
            <summary>
            Read an object of type T from a binary file in resources
            </summary>
            <typeparam name="T">Type of the object</typeparam>
            <param name="filename">Name of the binary file in resources</param>
            <param name="projectName">Name of the project where the resources are located</param>
            <returns>The object of type T</returns>
        </member>
        <member name="M:Vts.IO.FileIO.WriteToBinary``1(``0,System.String)">
            <summary>
            Write an object of type T to a binary file
            </summary>
            <typeparam name="T">Type of the object</typeparam>
            <param name="myObject">Object</param>
            <param name="filename">Name of the binary file</param>
        </member>
        <member name="M:Vts.IO.FileIO.ReadFromBinaryStream``1(System.IO.Stream)">
            <summary>
            Deserializes a stream into an object
            </summary>
            <typeparam name="T">Type of the object</typeparam>
            <param name="s">Stream to deserialize</param>
            <returns>The object of type T</returns>
        </member>
        <member name="M:Vts.IO.FileIO.WriteToBinaryStream``1(``0,System.IO.Stream)">
            <summary>
            Serializes an object of type T to the given stream
            </summary>
            <typeparam name="T">Type of the object</typeparam>
            <param name="myObject">Object</param>
            <param name="s">Stream to which to write the object</param>
        </member>
        <member name="T:Vts.IO.ICustomBinaryReader`1">
            <summary>
            General interface to read a specified type from binary
            </summary>
            <typeparam name="T">Type to read</typeparam>
        </member>
        <member name="M:Vts.IO.ICustomBinaryReader`1.ReadFromBinary(System.IO.BinaryReader)">
            <summary>
            Reads the specified type
            </summary>
            <param name="br">The binary stream</param>
            <returns>The type to read</returns>
        </member>
        <member name="T:Vts.IO.ICustomBinaryWriter`1">
            <summary>
            General interface to write a specified type to binary
            </summary>
            <typeparam name="T">Type to write</typeparam>
        </member>
        <member name="M:Vts.IO.ICustomBinaryWriter`1.WriteToBinary(System.IO.BinaryWriter,`0)">
            <summary>
            Writes the specified type
            </summary>
            <param name="bw">Binary stream to which to write</param>
            <param name="item">The type to write</param>
        </member>
        <member name="T:Vts.IO.JsonCreationConverter`1">
            <summary>
            class JsonCreationConverter
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Vts.IO.JsonCreationConverter`1.Create(System.Type,Newtonsoft.Json.Linq.JObject)">
            <summary>
            Create an instance of objectType, based properties in the JSON object
            </summary>
            <param name="objectType">type of object expected</param>
            <param name="jObject">contents of JSON object that will be deserialized</param>
            <returns></returns>
        </member>
        <member name="M:Vts.IO.JsonCreationConverter`1.CanConvert(System.Type)">
            <summary>
            method to identify whether object can be converted
            </summary>
            <param name="objectType">object to be converted</param>
            <returns>boolean indicating whether object can be converted</returns>
        </member>
        <member name="M:Vts.IO.JsonCreationConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            method to read json
            </summary>
            <param name="reader">JsonReader</param>
            <param name="objectType">Type</param>
            <param name="existingValue">object: current type</param>
            <param name="serializer">JsonSerializer</param>
            <returns>object read</returns>
        </member>
        <member name="M:Vts.IO.JsonCreationConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
            <summary>
            method to write json
            </summary>
            <param name="writer">JsonWriter</param>
            <param name="value">object to be written</param>
            <param name="serializer">JsonSerializer</param>
        </member>
        <member name="T:Vts.IO.KnownTypes">
            <summary>
            Class created to work-around the issues with the DataContractSerializer in Mono
            </summary>
        </member>
        <member name="P:Vts.IO.KnownTypes.CurrentKnownTypes">
            <summary>
            Gets a dictionary of the current known types
            </summary>
        </member>
        <member name="M:Vts.IO.KnownTypes.Add(System.Type)">
            <summary>
            Adds a new type to the list of known types
            </summary>
            <param name="t">The type to add</param>
        </member>
        <member name="T:Vts.IO.LibraryIO">
            <summary>
            This class includes methods for dynamically loading DLLs
            </summary>
        </member>
        <member name="M:Vts.IO.LibraryIO.EnsureDllIsLoaded(System.String)">
            <summary>
            Static method to check that an assemly is loaded
            </summary>
            <param name="assemblyName">Name of the assembly</param>
        </member>
        <member name="M:Vts.IO.LibraryIO.LoadFromDLL(System.String)">
            <summary>
            Loads an assembly from a dll
            </summary>
            <param name="fileName">Path and name of the dll</param>
        </member>
        <member name="T:Vts.IO.MetaData">
            <summary>
            This class will create metadata objects that will aid in the reading of binary files created 
            with the BinaryWriter tools
            </summary>
        </member>
        <member name="F:Vts.IO.MetaData.dims">
            <summary>
            The dimensions of the array
            </summary>
        </member>
        <member name="F:Vts.IO.MetaData.datetime">
            <summary>
            Current data and time
            </summary>
        </member>
        <member name="F:Vts.IO.MetaData.ObjectType">
            <summary>
            The type of the array
            </summary>
        </member>
        <member name="F:Vts.IO.MetaData.filename">
            <summary>
            Name of the file
            </summary>
        </member>
        <member name="M:Vts.IO.MetaData.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Vts.IO.MetaData.#ctor(System.Array)">
            <summary>
            Constructor that passes the array and sets the object type and dimensions
            </summary>
            <param name="myArray">Array for which meta data is needed</param>
        </member>
        <member name="T:Vts.IO.StreamFinder">
            <summary>
            Implements static functions for returning streams from various locations (resources, file system, etc)
            </summary>
        </member>
        <member name="M:Vts.IO.StreamFinder.GetFileStreamFromResources(System.String,System.String)">
            <summary>
            Returns a stream from resources,
            given a file name and an assembly (project) name
            </summary>
            <param name="fileName">Name of the file in resources</param>
            <param name="projectName">Project name where the resources are located</param>
            <returns>Stream of data</returns>
        </member>
        <member name="M:Vts.IO.StreamFinder.GetFileStream(System.String,System.IO.FileMode)">
            <summary>
            Returns a stream from the local file system.
            </summary>
            <param name="filename">Name of the file</param>
            <param name="fileMode">The FileMode to use when accessing the file</param>
            <returns>Stream of data</returns>
        </member>
        <member name="T:Vts.IO.VtsJsonSerializer">
            <summary>
            json serializer methods for the VTS
            </summary>
        </member>
        <member name="M:Vts.IO.VtsJsonSerializer.WriteToJson``1(``0)">
            <summary>
            method to write to json
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myObject">object to write</param>
            <returns>written json</returns>
        </member>
        <member name="M:Vts.IO.VtsJsonSerializer.WriteToJsonFile``1(``0,System.String)">
            <summary>
            method to write json to file
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myObject">object to write</param>
            <param name="filename">json file written to</param>
        </member>
        <member name="P:Vts.IO.VtsJsonSerializer.KnownConverters">
            <summary>
            list of known converters - one of each type of Monte Carlo class that is written to json
            </summary>
        </member>
        <member name="M:Vts.IO.VtsJsonSerializer.ReadFromJson``1(System.String)">
            <summary>
            method to read form json
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="myString">string identifying json</param>
            <returns>deserialized object</returns>
        </member>
        <member name="M:Vts.IO.VtsJsonSerializer.ReadFromJsonFile``1(System.String)">
            <summary>
            method to read json from file
            </summary>
            <typeparam name="T">generic type</typeparam>
            <param name="filename">name of file to be read</param>
            <returns>json</returns>
        </member>
        <member name="T:Vts.Modeling.NumericalDerivativeExtensions">
            <summary>
            extension methods to determine derivatives of forward solvers
            </summary>
        </member>
        <member name="M:Vts.Modeling.NumericalDerivativeExtensions.SetDelta(System.Double)">
            <summary>
            method to set the delta value used in the finite difference determination of the derivative
            </summary>
            <param name="delta"></param>
        </member>
        <member name="M:Vts.Modeling.NumericalDerivativeExtensions.GetDerivativeFunc(System.Func{System.Object[],System.Double[]},Vts.ForwardAnalysisType)">
            <summary>
            method to get derivative function
            </summary>
            <param name="myFunc">function for derivative</param>
            <param name="analysisType">ForwardAnalysisType enum</param>
            <returns>derivative function</returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.BSplinesCoefficients">
            <summary>
            This class holds the coefficients of the non vanishing B-slines
            over a single knot span and the upper and lower limit of the knot span
            mapped to the non parametric space.
            This values are used to evaluate analitically the steady state reflectance
            for the real domain and for the spatial frequancy domain through the integration of 
            the time resolved curves at the required locations.
            The effect of the linear mapping from the original space to the parametric space
            is embedded within this coefficients.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.BSplinesCoefficients.Coefficients">
            <summary>
            Gets or sets the coefficients of the non vanishing B-splines
            coefficients over a single knot span.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.BSplinesCoefficients.LowerLimit">
            <summary>
            Gets or sets the lower limit of the knot span,mapped to the non parametric space. 
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.BSplinesCoefficients.UpperLimit">
            <summary>
            Gets or sets the upper limit of the knot span,mapped to the non parametric space.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.BSplinesCoefficients.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.BSplinesCoefficients.#ctor(Vts.Modeling.ForwardSolvers.NurbsValues,System.Int32)">
            <summary>
            Constructor used to evaluate the coefficients of the non vanishing
            B-splines over the knot span, and to evaluate the limits of the knot span,
            mapped to the non parametric space.
            </summary>
            <param name="nurbsValues">NurbsValues class with the NURBS charachteristic values</param>
            <param name="knotIndex">Index of the lower limit knot</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.BSplinesCoefficients.GetKnotSpanMidTime">
            <summary>
            Returns the middle time of a knot span mapped to the reference space.
            </summary>
            <returns>middle time coordinate</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.BSplinesCoefficients.GetKnotSpanDeltaT">
            <summary>
            Returns the time span of a knot span mapped to the reference space.
            </summary>
            <returns>delta time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.BSplinesCoefficients.ModifyIfNotValid(System.Double)">
            <summary>
            If the input value is NaN or Inf it changes it to zero,as defined in the recursive
            formula used to evaluate the B-splines coefficients.'The NURBS Book' page 51.
            </summary>
            <param name="num">multypling values of the recursive formula</param>
            <returns>0 or the input value</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.BSplinesCoefficients.Normalize(System.Double[0:,0:],System.Double)">
            <summary>
            Adjusts the B-splines coefficients to take into account the mapping from the
            original space to the parametric space, dividing by the maximum value of the 
            original space elevated to the same degree of each coefficient.
            </summary>
            <param name="coefficients">B-spline coefficients</param>
            <param name="max">max value of the original space</param>
            <returns>B-splines coefficients devided by the maximal value of the original space elevated to the same power of the coefficients</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.BSplinesCoefficients.EvaluateMuliplyingValues(System.Double@,System.Double@,System.Double@,System.Double@,Vts.Modeling.ForwardSolvers.NurbsValues,System.Int32,System.Int32)">
            <summary>
            Computes the coefficients of the B-spline recursive formula.
            Based on the Cox - De Boor algorithm. 'The NURBS Book' page 50.
            </summary>
            <param name="a">u_j / (u_j - u_(j+p))</param>
            <param name="b">u_(j+p+1) / (u_(j+p+1) - u_(j+1))</param>
            <param name="c">1 / (u_(j+p) - u_j)</param>
            <param name="d">1 / (u_(j+1) - u_(j+p+1))</param>
            <param name="nurbsValues">NurbsValues class with the knots vector and degree</param>
            <param name="degree">degree of the iteration of the recursive formula</param>
            <param name="j">knot index</param>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver">
            <summary>
            delta-P1 forward solver class
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.#ctor(Vts.Modeling.ForwardSolvers.SourceConfiguration,System.Double)">
            <summary>
            delta-P1 forward solver solution
            </summary>
            <param name="sourceConfiguration">flat or Gaussian</param>
            <param name="beamRadius">radius of source</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.StationaryReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            stationary (time-independent) reflectance
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns>reflectance at rho</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.StationaryFluence(System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters)">
            <summary>
            stationary (time-independent) fluence
            </summary>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="dp">diffusion parameters</param>
            <returns>fluence value at (rho,z)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.TemporalReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            temporally-resolved reflectance
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="t">time</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.TemporalFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            temporally-resolved fluence
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="t">time</param>
            <returns>fluence at (rho,z,t)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.ROfRhoAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            reflectance as a function of s-d separation and temporal-frequency
            </summary>
            <param name="op">optical properties</param>
            <param name="rho">s-d separation</param>
            <param name="ft">temporal frequency</param>
            <returns>R(rho,ft)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.ROfFx(Vts.OpticalProperties,System.Double)">
            <summary>
            reflectance as a function of spatial-frequency
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial frequency</param>
            <returns>R(fx)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.ROfFxAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            reflectance as a function of spatial-frequency and time
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial frequency</param>
            <param name="time">time</param>
            <returns>R(fx,t)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.ROfFxAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            reflectance as a function of spatial-frequency and temporal-frequency
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial frequency</param>
            <param name="ft">temporal frequency</param>
            <returns>R(fx,ft)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.FluenceOfRhoAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as a function of s-d separation and z and temporal-frequency
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">s-d separations</param>
            <param name="zs">depths</param>
            <param name="fts">temporal-frequencies</param>
            <returns>Fluence(rho,z,ft)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.TemporalFrequencyReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Numerics.Complex,System.Double,System.Double)">
            <summary>
            reflectance as a function of s-d separation
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="k"></param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DeltaPOneForwardSolver.TemporalFrequencyFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Numerics.Complex)">
            <summary>
            fluence as a function of temporal-frequency
            </summary>
            <param name="dp">diffuse parameters</param>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.SourceConfiguration">
            <summary>
            SourceConfiguration enum
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.SourceConfiguration.Point">
            <summary>
            point source
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.SourceConfiguration.Distributed">
            <summary>
            source distributed along line within tissue
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.SourceConfiguration.Gaussian">
            <summary>
            Gaussian source
            </summary>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.ForwardModel">
            <summary>
            ForwardModel enum
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.ForwardModel.SDA">
            <summary>
            standard diffusion approximation
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.ForwardModel.DeltaPOne">
            <summary>
            delta-P1 approximation
            </summary>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase">
            <summary>
            diffusion based forward solvers class
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.#ctor(Vts.Modeling.ForwardSolvers.SourceConfiguration,System.Double)">
            <summary>
            diffusion forward solver base
            </summary>
            <param name="sourceConfiguration">source configuration</param>
            <param name="beamDiameter">diameter of source [mm]</param>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ForwardModel">
            <summary>
            forward model enum
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfRho(Vts.OpticalProperties,System.Double)">
            <summary>
            reflectance as a function of s-d separation
            </summary>
            <param name="op">optical properties</param>
            <param name="rho">s-d separation</param>
            <returns>R(rho)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfRho(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            reflectance as a function of rhos 
            </summary>
            <param name="ops">IEnumerable of optical properties</param>
            <param name="rhos">IEnumerable of rho values</param>
            <returns>R(rhos)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfRhoAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            reflectance as a function of s-d separation and time
            </summary>
            <param name="op">optical properties</param>
            <param name="rho">s-d separation</param>
            <param name="time">time [ns]</param>
            <returns>R(rho,time)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfRhoAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            reflectance as a function of rhos and times
            </summary>
            <param name="ops">IEnumerable of optical properties</param>
            <param name="rhos">s-d separations</param>
            <param name="times">times</param>
            <returns>R(rhos,times)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfRhoAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            reflectance as a function of s-d separation and temporal-frequency
            </summary>
            <param name="op">optical properties</param>
            <param name="rho">s-d separation</param>
            <param name="ft">temporal-frequency</param>
            <returns>R(rho,ft)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfRhoAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            reflectance as a function of s-d separations and temporal-frequencies
            </summary>
            <param name="ops">IEnumerable of optical properties</param>
            <param name="rhos">s-d separations</param>
            <param name="fts">temporal-frequencies</param>
            <returns>R(rhos,fts)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfFx(Vts.OpticalProperties,System.Double)">
            <summary>
            ROfFx, solves SDA using Cuccia et al JBO, March/April 2009 
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfFx(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vectorized ROfFx. Solves SDA using Cuccia et al JBO, March/April 2009 
            </summary>
            <param name="ops">set of optical properties of the medium</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfFxAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            reflectance as a function of spatial-frequency and time
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial-frequency</param>
            <param name="time">time [ns]</param>
            <returns>R(fx,time)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfFxAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            reflectance as a function of spatial-frequencies and times
            </summary>
            <param name="ops">IEnumerable of optical properties</param>
            <param name="fxs">spatial-frequencies</param>
            <param name="times">times</param>
            <returns>R(fxs,times)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.ROfFxAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Modulation frequency-dependent reflectance. Modified from Pham et al, Appl. Opt. Sept 2000 
            to include spatial modulation, as described in Cuccia et al, J. Biomed. Opt. March/April 2009
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="fx">spatial frequency</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.GetBackwardHemisphereIntegralDiffuseReflectance(System.Double,System.Double,System.Double)">
            <summary>
            Calculates the reflectance based on the integral of the radiance over the backward hemisphere...
            </summary>
            <param name="surfaceFluence">diffuse fluence at the surface</param>
            <param name="surfaceFlux">diffuse flux at the surface</param>
            <param name="mediaRefractiveIndex">refractive index of the medium</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.GetBackwardHemisphereIntegralDiffuseReflectance(System.Numerics.Complex,System.Numerics.Complex,System.Double)">
            <summary>
            Calculates the reflectance based on the integral of the radiance over the backward
            hemisphere for complex fluence
            </summary>
            <param name="surfaceFluence">complex diffuse fluence at the surface</param>
            <param name="surfaceFlux">complex diffuse flux at the surface</param>
            <param name="mediaRefractiveIndex">refractive index of the medium</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.GetBackwardHemisphereIntegralDiffuseReflectance(System.Double,System.Double,System.Double,System.Double)">
            <param name="fluence">Fluence</param>
            <param name="flux">Flux</param>
            <param name="fr1">1st moment of Fresnel Reflection</param>
            <param name="fr2">2nd moment of Fresnel Reflection</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.GetBackwardHemisphereIntegralDiffuseReflectance(System.Numerics.Complex,System.Numerics.Complex,System.Double,System.Double)">
            <summary>
            get backward hemisphere integral for diffuse reflectance
            </summary>
            <param name="fluence">fluence term</param>
            <param name="flux">flux term</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.FluenceOfRhoAndZ(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as function of s-d separations and depths
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">s-d separations</param>
            <param name="zs">depths</param>
            <returns>fluence(rhos,zs)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.FluenceOfRhoAndZAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as function of s-d separations, depths and times
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">s-d separations</param>
            <param name="zs">depths</param>
            <param name="times">times</param>
            <returns>fluence(rhos,zs,times)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.FluenceOfRhoAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as a function of s-d separations, depth z and temporal-frequencies
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">s-d separations</param>
            <param name="zs">depths</param>
            <param name="fts">temporal-frequencies</param>
            <returns>fluence(rhos,zs,fts)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.FluenceOfFxAndZ(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as a function of spatial-frequency and depth z
            </summary>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial-frequencies</param>
            <param name="zs">depths</param>
            <returns>fluence(fxs,zs)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.FluenceOfFxAndZAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as a function of spatial-frequency and depth z and time
            </summary>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial-frequencies</param>
            <param name="zs">depths</param>
            <param name="times">times</param>
            <returns>fluence(fxs,zs,times)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.FluenceOfFxAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as a function of spatial-frequency and temporal-frequency
            </summary>
            <param name="ops">IEnumerable of optical properties</param>
            <param name="fxs">spatial frequencies</param>
            <param name="zs">depths</param>
            <param name="fts">temporal-frequencies</param>
            <returns>fluence(fxs,z,fts)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.StationaryReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            time-independent reflectance
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns>R(rho)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.TemporalReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            time-dependent reflectance
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="t">time [ns]</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns>R(rho,time)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.TemporalFrequencyReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Numerics.Complex,System.Double,System.Double)">
            <summary>
            reflectance as a function of s-d separation and temporal-frequency
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="k">temporal-frequency</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.StationaryFluence(System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters)">
            <summary>
            time-independent fluence 
            </summary>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="dp">diffusion parameters</param>
            <returns>fluence(rho,z)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.TemporalFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            temporal fluence
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="t">time</param>
            <returns>fluence(rho,z,time)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionForwardSolverBase.TemporalFrequencyFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Numerics.Complex)">
            <summary>
            fluence as a function of s-d separation, z depth and temporal-frequency
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="k">temporal frequency</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions">
            <summary>
            This class contains Green's functions based on the infinite media diffusion case. 
            Source-sink(image) configurations are then composed for the semi-infinite half-space too.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.StationaryPointSourceGreensFunction(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double)">
            <summary>
            Infinite Media Diffusion Greens Functions Definitions
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="r">radial value</param>
            <returns>evaluation of the Green's function</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.TemporalPointSourceGreensFunction(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double)">
            <summary>
            Infinite media diffusion Green's functions for space and time for an
            origin of r = 0 and t = 0.
            </summary>
            <param name="dp">diffusion parameters object</param>
            <param name="r">radial location</param>
            <param name="t">time</param>
            <returns>evaluation of the Green's function</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.TemporalFrequencyPointSourceGreensFunction(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Numerics.Complex)">
            <summary>
            Infinte media diffusion Green's function for space and temporal frequency
            </summary>
            <param name="dp">diffusion parameters object</param>
            <param name="r">radial location</param>
            <param name="k"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.StationaryPointSourceGreensFunctionZFlux(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double)">
            <summary>
            time-independent Green's function zflux from point source
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="r"></param>
            <param name="zr"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.TemporalPointSourceGreensFunctionZFlux(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            time-dependent Green's function solution for point source
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="r"></param>
            <param name="zr"></param>
            <param name="t">time</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.TemporalFrequencyPointSourceGreensFunctionZFlux(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Numerics.Complex)">
            <summary>
            temporal-frequency Green's function for point source
            <param name="dp">diffusion parameters</param>
            <param name="r">source location (rho)</param>
            <param name="zr">source location (z)</param>
            <param name="k">complex value</param>
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.StationaryPointSourceImageGreensFunction(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double)">
            <summary>
            Green's function composition
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rSource">source location</param>
            <param name="rImage">source image location</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.TemporalPointSourceImageGreensFunction(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            time-dependent Green's function
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rSource">source location</param>
            <param name="rImage">image source location</param>
            <param name="t">time</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.TemporalFrequencyPointSourceImageGreensFunction(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Numerics.Complex)">
            <summary>
            time-dependent Green's function for point source complex
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rSource">source location</param>
            <param name="rImage">source image location</param>
            <param name="k">complex value</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.StationaryPointSourceImageGreensFunctionZFlux(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            infinite media Green's function zflux for planar media
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rSource">source location (rho)</param>
            <param name="zSource">source location (z)</param>
            <param name="rImage">source image location (rho)</param>
            <param name="zImage">source image location (z)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.TemporalPointSourceImageGreensFunctionZFlux(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            infinite media Green's function zflux for planar media complex
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rSource">source location (rho)</param>
            <param name="zSource">source location (z)</param>
            <param name="rImage">source image location (rho)</param>
            <param name="zImage">source image location (z)</param>
            <param name="t">time</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionGreensFunctions.TemporalFrequencyPointSourceImageGreensFunctionZFlux(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double,System.Double,System.Numerics.Complex)">
            <summary>
            temporal-frequency Green's function for planar media complex
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rSource">source location (rho)</param>
            <param name="zSource">source location (z)</param>
            <param name="rImage">source image location (rho)</param>
            <param name="zImage">source image location (z)</param>
            <param name="k">complex value</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.DiffusionParameters">
            <summary>
            This class allows creation and copying of a diffusion parameters object, which contains fields
            necessary for solution of diffusion models. The creation is made by passing a opticalproperties
            object.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionParameters.Create(Vts.OpticalProperties,Vts.Modeling.ForwardSolvers.ForwardModel)">
            <summary>
            Create a DiffusionParameters object from OpticalProperties object and a ForwardModel
            choice.
            </summary>
            <param name="op">OpticalProperties object</param>
            <param name="fm">ForwardModel enum</param>
            <returns>new DiffusionParameters object</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiffusionParameters.Copy(Vts.Modeling.ForwardSolvers.DiffusionParameters)">
            <summary>
            Create a new copy of a DiffusionParameters object
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <returns>new copy of DiffusionParameters object</returns>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.A">
            <summary>
            Diffusion boundary parameter A = (1 + R2)/(1 - R1)
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.mueff">
            <summary>
            effective attenuation coefficient = sqrt(mua / D)
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.zb">
            <summary>
            extrapolated boundary distance
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.zp">
            <summary>
            ??? z0, better explain
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.mutTilde">
            <summary>
            mean reduced tranport length as a function of the phase function, if Eddington: = mutr, 
            if delta-Eddington = mutStar
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.mutr">
            <summary>
            mean reduced transport length
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.musTilde">
            <summary>
            reduced scattering length as a function of the phase function, if Eddington: = musPrime, 
            if delta-Eddington = musStar
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.gTilde">
            <summary>
            1st moment of the scattering phase function, if Eddington = g, if delta-Eddington = g/(g+1)
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.D">
            <summary>
            diffusion coefficient = 1/3/mutr
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.cn">
            <summary>
            speed of light adjusted according to the refractive index of the media cn = c / n, where
            n is the media refractive index
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.DiffusionParameters.mua">
            <summary>
            absorption coefficient
            </summary>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.DiscreteOrdinates.DOMethods">
            <summary>
            discrete ordinates methods class
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiscreteOrdinates.DOMethods.GaussLegendre(System.Int32)">
            <summary>
            method to determine Gauss Legendre coefficients
            </summary>
            <param name="N">order</param>
            <returns>GaussLegendreCoefficients</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiscreteOrdinates.DOMethods.GenFokkerPlanckEddington(System.Double[],System.Double[],System.Double[],System.Int32)">
            <summary>
            method to generate FokkerPlanckEddington matrix
            </summary>
            <param name="f"></param>
            <param name="mu">cosine theta?</param>
            <param name="wt">Gauss Legendre weights</param>
            <param name="N">order</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiscreteOrdinates.DOMethods.LaplaceBelTrami(System.Double[],System.Double[],System.Int32)">
            <summary>
            method to determine Laplace-Beltrami matrix
            </summary>
            <param name="mu">cosine theta?</param>
            <param name="wt">expansion weights</param>
            <param name="N">order</param>
            <returns>matrix</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiscreteOrdinates.DOMethods.PWHalfSpace(System.Double,System.Double,System.Double[],System.Double[],Meta.Numerics.Matrices.SquareMatrix,System.Int32)">
            <summary>
            method to determine the PW half space
            </summary>
            <param name="mu_a">absorption coefficient [/mm]</param>
            <param name="mu_s">scattering coefficient [/mm]</param>
            <param name="mu"></param>
            <param name="wt"></param>
            <param name="L"></param>
            <param name="N">order</param>
            <returns>double array</returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.DiscreteOrdinates.GaussLegendreCoefficients">
            <summary>
            Gauss Legendre coefficients
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.DiscreteOrdinates.GaussLegendreCoefficients.mu">
            <summary>
            cosine theta?
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.DiscreteOrdinates.GaussLegendreCoefficients.wt">
            <summary>
            weights
            </summary>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.DiscreteOrdinatesForwardSolver">
            <summary>
            discrete ordinates forward solver
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiscreteOrdinatesForwardSolver.ROfTheta(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            reflectance as a function of theta
            </summary>
            <param name="ops">optical properties</param>
            <param name="thetas">thetas</param>
            <returns>R(thetas)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DiscreteOrdinatesForwardSolver.ROfTheta(Vts.OpticalProperties,System.Double)">
            <summary>
            reflectance as a function of theta
            </summary>
            <param name="op">optical properties</param>
            <param name="theta">theta angle</param>
            <returns>R(theta)</returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.DistributedGaussianSourceSDAForwardSolver">
            <summary>
            Evaluation of the distributed Gaussian diffusion forward solver. This model is a specific
            mathematical derivation in the stationary case for semi-infinite media.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedGaussianSourceSDAForwardSolver.#ctor">
            <summary>
            distributed line Gaussian Source Standard Diffusion approximation default constructor
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedGaussianSourceSDAForwardSolver.#ctor(System.Double)">
            <summary>
            distributed line Gaussian Source Standard Diffusion approximation default constructor
            with parameter for beam diameter
            </summary>
            <param name="diameter">beam diameter</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedGaussianSourceSDAForwardSolver.StationaryReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            Evaluation of the reflectance according to Carp et al. FILL IN (2004).
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="rho">radial location</param>
            <param name="fr1">First Fresnel Reflection Moment, not applied here</param>
            <param name="fr2">Second Fresnel Reflection Moment, not applied here</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedGaussianSourceSDAForwardSolver.SteadyStateGaussianBeamSurfaceFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double)">
            <summary>
            time-independent fluence 
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="diam">diameter of Gaussian beam</param>
            <param name="rho">s-d separation</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedGaussianSourceSDAForwardSolver.StationaryFluence(System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters)">
            <summary>
            time-independent fluence
            </summary>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="dp">diffusion parameters</param>
            <returns>fluence(rho,z)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedGaussianSourceSDAForwardSolver.TemporalReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            reflectance as a function of time
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="t">time</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedGaussianSourceSDAForwardSolver.TemporalFrequencyReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Numerics.Complex,System.Double,System.Double)">
            <summary>
            temporal-frequency reflectance
            </summary>
            <param name="dp"></param>
            <param name="rho">s-d separation</param>
            <param name="k">temporal-frequency</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedGaussianSourceSDAForwardSolver.TemporalFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            time-dependent fluence
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="t">time</param>
            <returns>fluence(rho,z,time)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedGaussianSourceSDAForwardSolver.TemporalFrequencyFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Numerics.Complex)">
            <summary>
            fluence as a function of s-d separation, depth and temporal-frequency
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="k">temporal-frequency</param>
            <returns>fluence(rho,z,ft)</returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.DistributedPointSourceSDAForwardSolver">
            <summary>
            Contains distributed point source solutions for the diffusion point source-image solution in the
            semi-infinite domain.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedPointSourceSDAForwardSolver.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedPointSourceSDAForwardSolver.StationaryReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            Evaluation of the radially resolved stationary reflectance for the distribution of point sources in
            the source-image configuration.
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="rho">radial position</param>
            <param name="fr1">Fresnel Reflection Moment 1</param>
            <param name="fr2">Fresnel Reflection Moment 2</param>
            <returns>reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedPointSourceSDAForwardSolver.StationaryFluence(System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters)">
            <summary>
            Evaluation of the radially resolved stationary fluence for the distribution of point
            sources under the source-image configuration.
            </summary>
            <param name="rho">radial position</param>
            <param name="z">depth position</param>
            <param name="dp">DiffusionParameters object</param>
            <returns>fluence</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedPointSourceSDAForwardSolver.TemporalReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Evaulation of the temporally resolved radial reflectance using the distribution of
            source-image point sources.
            </summary>
            <param name="dp">DiffusionParamters object</param>
            <param name="rho">radial location</param>
            <param name="t">time</param>
            <param name="fr1">Fresnel Moment 1</param>
            <param name="fr2">Fresnel Moment 2</param>
            <returns>reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedPointSourceSDAForwardSolver.TemporalFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            Evaluation of the temporally and radially resolved fluence rate using the distribution of
            source-image point sources.
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="rho">radial location</param>
            <param name="z">depth location</param>
            <param name="t">time</param>
            <returns>fluence rate</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedPointSourceSDAForwardSolver.TemporalFrequencyReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Numerics.Complex,System.Double,System.Double)">
            <summary>
            Evaluates the temporal frequency radially resolved reflectance using the distribution of
            the source-image point source configuration.
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="rho">radial location</param>
            <param name="k">wavevector</param>
            <param name="fr1">Fresnel Moment 1</param>
            <param name="fr2">Fresnel Moment 2</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.DistributedPointSourceSDAForwardSolver.TemporalFrequencyFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Numerics.Complex)">
            <summary>
            Evaluate the temporal frequency - radially resolved fluence with the distribution
            of point sources in the source-image configuration
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="rho">radial location</param>
            <param name="z">depth location</param>
            <param name="k">wavevector</param>
            <returns>fluence rate</returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.ForwardSolverBase">
            <summary>
            This is a base class for all forward solvers. It contains default (virtual) vectorization methods such that only the scalar solver methods 
            must be implemented to create a new IForwardSolver-implementing class. Override these virtual methods to impose optimizations possible through vectorization.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.#ctor(Vts.Modeling.ForwardSolvers.SourceConfiguration,System.Double)">
            <summary>
            Constructor for the forward solver base class
            </summary>
            <param name="sourceConfiguration">source configuration</param>
            <param name="beamDiameter">beam diameter</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.ForwardSolverBase.BeamDiameter">
            <summary>
            beam diameter
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.ForwardSolverBase.SourceConfiguration">
            <summary>
            source configuration - point, distributed or gaussian
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRho(Vts.OpticalProperties,System.Double)">
            <summary>
            Scalar ROfRho function.  Determines reflectance at source-detector separation rho - must be implemented in child class
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="rho">source-detector separation (mm)</param>
            <returns>reflectance at given single set of optical properties and single rho</returns>     
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRho(Vts.IOpticalPropertyRegion[],System.Double)">
            <summary>
            Scalar ROfRho function.  Determines reflectance at source-detector separation rho - must be implemented in child class
            </summary>
            <param name="regions">tissue regions of the medium</param>
            <param name="rho">source-detector separation (mm)</param>
            <returns>reflectance at given tissue regions and single rho</returns>     
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfTheta(Vts.OpticalProperties,System.Double)">
            <summary>
            Scalar ROfTheta function.  Determines reflectance at polar angle theta
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="theta">polar angle of reflected photon</param>
            <returns>reflectance at given single set of optical properties and single polar angle theta</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Scalar ROfRhoAndTime function.  Determines reflectance at source-detector separation rho and time t - must be implemented in child class
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given single set of optical properties, single rho and single time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            Scalar ROfRhoAndTime function.  Determines reflectance for tissue with regions, at
            source-detector separation rho and time t - must be implemented in child class
            </summary>
            <param name="regions">medium regions</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given single set of optical properties, single rho and single time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Scalar ROfRhoAndFt function.  Determines reflectance at source-detector separation rho and modulation frequency ft - must be implemented in child class
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at given single set of optical properties, single rho and single modulation frequency ft</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            Scalar ROfRhoAndFt function.  Determines reflectance at source-detector separation rho and modulation frequency ft - must be implemented in child class
            </summary>
            <param name="regions">tissue regions of the medium</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at given single set of optical properties, single rho and single modulation frequency ft</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFx(Vts.OpticalProperties,System.Double)">
            <summary>
            Scalar ROfFx function.  Determines reflectance at spatial frequency fx - must be implemented in child class
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <returns>reflectance at given single set of optical properties and single spatial frequency fx</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFx(Vts.IOpticalPropertyRegion[],System.Double)">
            <summary>
            Scalar ROfFx function.  Determines reflectance at spatial frequency fx - must be implemented in child class
            </summary>
            <param name="regions">regions of the medium</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <returns>reflectance at given tissue regions and single spatial frequency fx</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Scalar ROfFxAndTime function.  Determines reflectance at spatial frequency fx and time t - must be implemented in child class
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given single set of optical properties, single spatial frequency fx and single time t</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            Scalar ROfFxAndTime function.  Determines reflectance at spatial frequency fx and time t - must be implemented in child class
            </summary>
            <param name="regions">regions of the medium</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given tissue regions, single spatial frequency fx and single time t</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Determines reflectance at spatial frequency fx and modulation frequency ft - must be implemented in child class
            </summary>
            <param name="op">optical properties of the medium</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at given single set of optical properties, single spatial frequency fx and single modulation frequency ft</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            Determines reflectance at spatial frequency fx and modulation frequency ft - must be implemented in child class
            </summary>
            <param name="regions">regions of the medium</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at given tissue regions, single spatial frequency fx and single modulation frequency ft</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRho(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfRho function. Determines reflectances at optical properties 'ops' and source-detector separations 'rhos'
            Override these in child classes to take advantage of optimization strategies.
            </summary>
            <param name="ops">sets of optical properties of the medium</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns>reflectance at given optical properties and rhos</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRho(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfRho function. Determines reflectances at regions and source-detector separations 'rhos'
            Override these in child classes to take advantage of optimization strategies.
            </summary>
            <param name="regions">sets of optical and geometrical properties of the medium</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns>reflectance at given optical properties and rhos</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfTheta(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            reflectance as function of theta
            </summary>
            <param name="ops">optical properties</param>
            <param name="thetas">thetas</param>
            <returns>R(thetas)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfRhoAndTime function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and times 'times'
            Override these in child classes to take advantage of optimization strategies.
            </summary>
            <param name="ops">sets of optical properties of the medium</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfRhoAndTime function. Determines reflectances of tissue with 'regions', source-detector separations 'rhos' and times 'times'
            Override these in child classes to take advantage of optimization strategies.
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance of tissue regions, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfRhoAndFt function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and time frequencies 'fts'
            Override these in child classes to take advantage of optimization strategies.
            </summary>
            <param name="ops">sets of optical properties of the medium</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given optical properties, rhos and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfRhoAndFt function. Determines reflectances at tissue regions 'regions', source-detector separations 'rhos' and time frequencies 'fts'
            Override these in child classes to take advantage of optimization strategies.
            </summary>
            <param name="regions">tissue regions of the medium</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given optical properties, rhos and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFx(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfFx function. Determines reflectances at optical properties 'ops' and spatial frequencies 'fxs'
            </summary>
            <param name="ops">sets of optical properties of the medium</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <returns>reflectance at given optical properties and spatial frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFx(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfFx function. Determines reflectances at optical properties 'ops' and spatial frequencies 'fxs'
            </summary>
            <param name="regions">sets tissue regions of medium</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <returns>reflectance at given optical properties and spatial frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfFxAndTime function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and times 'times'
            Override these in child classes to take advantage of optimization strategies.
            </summary>
            <param name="ops">sets of optical properties of the medium</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, spatial frequencies and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfFxAndTime function. Determines reflectances of tissue regions, spatial frequencies 'fxs' and times 'times'
            Override these in child classes to take advantage of optimization strategies.
            </summary>
            <param name="regions">sets of tissue regions of the medium</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance of tissue regions, spatial frequencies and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfFxAndFt function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and time frequencies 'fts'
            Override these in child classes to take advantage of optimization strategies.
            </summary>
            <param name="ops">sets of optical properties of the medium</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given optical properties, spatial frequencies and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Vector ROfFxAndFt function. Determines reflectances of tissue 'regions', spatial frequencies 'fxs' and time frequencies 'fts'
            Override these in child classes to take advantage of optimization strategies.
            </summary>
            <param name="regions">sets of tissue regions of the medium</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance of given tissue regions, spatial frequencies and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRho(Vts.OpticalProperties[],System.Double[])">
            <summary>
            Convenience array overload of ROfRho. Determines reflectances at optical properties 'ops' and source-detector separations 'rhos'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns>Reflectance at given optical properties and rhos</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRho(Vts.IOpticalPropertyRegion[][],System.Double[])">
            <summary>
            Convenience array overload of ROfRho. Determines reflectances at optical properties 'ops' and source-detector separations 'rhos'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties of each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns>Reflectance at given optical properties and rhos</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfTheta(Vts.OpticalProperties[],System.Double[])">
            <summary>
            Convenience array overload of ROfTheta.  Determines reflectances at optical properties 'ops' and polar angle 'thetas'
            </summary>
            <param name="ops">sets of optical properties</param>
            <param name="thetas">polar angles</param>
            <returns>reflectance at given optical properties and polar angles</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Convenience array overload of ROfRhoAndTime. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and times 'times'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[])">
            <summary>
            Convenience array overload of ROfRhoAndTime. Determines reflectances at regions, source-detector separations 'rhos' and times 'times'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Convenience array overload of ROfRhoAndFt. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given optical properties, rhos and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[])">
            <summary>
            Convenience array overload of ROfRho. Determines reflectances of tissue 'regions', source-detector 
            separations 'rhos', and temporal frequencies 'fts'
            </summary>
            <param name="regions">sets of medium optical and geometrical properties of each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">temporal-frequencies</param>
            <returns>Reflectance at given optical properties and rhos</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFx(Vts.OpticalProperties[],System.Double[])">
            <summary>
            Convenience array overload of ROfFx. Determines reflectances at optical properties 'ops' and spatial frequencies 'fxs'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies</param>
            <returns>reflectance at given optical properties and spatial frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFx(Vts.IOpticalPropertyRegion[][],System.Double[])">
            <summary>
            Convenience array overload of ROfFx. Determines reflectances of tissue 'regions' and spatial frequencies 'fxs'
            </summary>
            <param name="regions">sets of medium tissue regions</param>
            <param name="fxs">spatial frequencies</param>
            <returns>reflectance of given tissue regions and spatial frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Convenience array overload of ROfFxAndTime. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and times 'times'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, spatial frequencies and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[])">
            <summary>
            Convenience array overload of ROfFxAndTime. Determines reflectances of tissue 'regions', spatial frequencies 'fxs' and times 'times'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="fxs">spatial frequencies</param>
            <param name="times">times (ns)</param>
            <returns>reflectance of given tissue region, spatial frequencies and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Convenience array overload of ROfFxAndFt. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given optical properties, spatial frequencies and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[])">
            <summary>
            Convenience array overload of ROfFxAndFt. Determines reflectances of tissue 'regions', spatial frequencies 'fxs' and time frequencies 'fts'
            </summary>
            <param name="regions">sets of medium tissue regions</param>
            <param name="fxs">spatial frequencies</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance of given tissue regions, spatial frequencies and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRho(Vts.OpticalProperties,System.Double[])">
            <summary>
            Overload of ROfRho. Determines reflectances at optical properties 'op' and source-detector separations 'rhos'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns>reflectance at given optical properties and rhos</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRho(Vts.IOpticalPropertyRegion[],System.Double[])">
            <summary>
            Overload of ROfRho. Determines reflectances at optical properties 'op' and source-detector separations 'rhos'
            </summary>
            <param name="regions">medium optical and geometrical properties of each sub-region</param>
            <param name="rhos">source-detector separations (mm)</param>
            <returns>reflectance at given optical properties and rhos</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRho(Vts.OpticalProperties[],System.Double)">
            <summary>
            Overload of ROfRho. Determines reflectances at optical properties 'ops' and source-detector separation 'rho'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rho">source-detector separations (mm)</param>
            <returns>reflectance at given optical properties and rhos</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRho(Vts.IOpticalPropertyRegion[][],System.Double)">
            <summary>
            Overload of ROfRho. Determines reflectances at optical properties 'ops' and source-detector separation 'rho'
            </summary>
            <param name="regions">sets of medium optical properties</param>
            <param name="rho">source-detector separations (mm)</param>
            <returns>reflectance at given optical properties and rhos</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfTheta(Vts.OpticalProperties,System.Double[])">
            <summary>
            Overload of ROFTheta.  Determines reflectances at optical properties 'ops' and polar angles 'thetas'
            </summary>
            <param name="op">optical properties</param>
            <param name="thetas">polar angles</param>
            <returns>reflectance at given optical properties and polar angles</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfTheta(Vts.OpticalProperties[],System.Double)">
            <summary>
            Overload of ROFTheta.  Determines reflectances at optical properties 'ops' and polar angles 'thetas'
            </summary>
            <param name="ops">optical properties</param>
            <param name="theta">polar angles</param>
            <returns>reflectance at given optical properties and polar angles</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.OpticalProperties,System.Double[],System.Double[])">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'op', source-detector separations 'rhos' and times 'times'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.IOpticalPropertyRegion[],System.Double[],System.Double[])">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances of tissue regions 'regions', source-detector 
            separations 'rhos' and times 'times'
            </summary>
            <param name="regions">medium regions</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.OpticalProperties[],System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'ops', source-detector separation 'rho' and times 'times'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.IOpticalPropertyRegion[][],System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances of tissue with regions 'regions', source-detector 
            separation 'rho' and times 'times'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.OpticalProperties[],System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and time 't'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given optical properties, rhos and times </returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances of tissue with 'regions', source-detector 
            separations 'rhos' and time 't'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given optical properties, rhos and times </returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.OpticalProperties,System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'op', source-detector separation 'rho' and times 'times'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.IOpticalPropertyRegion[],System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances of tissue with 'regions', source-detector 
            separation 'rho' and times 'times'
            </summary>
            <param name="regions">medium regions</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.OpticalProperties,System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'op', source-detector separations 'rhos' and time 't'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given optical properties, rhos and time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.IOpticalPropertyRegion[],System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at tissue regions 'regions', source-detector separations 'rhos' and time 't'
            </summary>
            <param name="regions">medium regions</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given optical properties, rhos and time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.OpticalProperties[],System.Double,System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'ops', source-detector separation 'rho' and time 't'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given optical properties, rho and time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndTime(Vts.IOpticalPropertyRegion[][],System.Double,System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances of tissue with 'regions', source-detector 
            separation 'rho' and time 't'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given optical properties, rho and time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.OpticalProperties,System.Double[],System.Double[])">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at optical properties 'op', source-detector separations 'rhos' and time frequencies 'fts'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given single set of optical properties, rhos and modulation frequencies </returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.IOpticalPropertyRegion[],System.Double[],System.Double[])">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at tissue regions 'regions', source-detector 
            separations 'rhos' and time frequencies 'fts'
            </summary>
            <param name="regions">medium regions</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given single set of optical properties, rhos and modulation frequencies </returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.OpticalProperties[],System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at optical properties 'ops', source-detector separation 'rho' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given optical properties, single rho, and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.IOpticalPropertyRegion[][],System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at tissue regions 'regions', source-detector separation 'rho' and time frequencies 'fts'
            </summary>
            <param name="regions">tissue regions</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given optical properties, single rho, and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.OpticalProperties[],System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at optical properties 'ops', source-detector separations 'rhos' and time frequency 'ft'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at given optical properties, rhos and single modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances of tissue 'regions', source-detector separations 'rhos' and time frequency 'ft'
            </summary>
            <param name="regions">sets of tissue regions</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance of given tissue regions, rhos and single modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.IOpticalPropertyRegion[],System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances of tissue 'regions', source-detector separations 'rhos' and time frequency 'ft'
            </summary>
            <param name="regions">tissue regions</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance of given tissue regions, rhos and single modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.OpticalProperties,System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances at optical properties 'op', source-detector separation 'rho' and time frequencies 'fts'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given single set of optical properties, single rho and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.IOpticalPropertyRegion[],System.Double,System.Double[])">
            <summary>
            Overload of ROfRhoAndFt. Determines reflectances of tissue 'regions', source-detector separation 'rho' and time frequencies 'fts'
            </summary>
            <param name="regions">medium regions</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given single set of optical properties, single rho and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.OpticalProperties,System.Double[],System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'op', source-detector separations 'rhos' and time frequency 'ft'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at given single set of optical properties, rhos and single modulation frequency</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfRhoAndFt(Vts.OpticalProperties[],System.Double,System.Double)">
            <summary>
            Overload of ROfRhoAndTime. Determines reflectances at optical properties 'ops', source-detector separation 'rho' and time frequency 'ft'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="rho">source-detector separation (mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at given optical properties, single rho and single modulation frequency</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFx(Vts.OpticalProperties,System.Double[])">
            <summary>
            Overload of ROfFx. Determines reflectances at optical properties 'op' and spatial frequencies 'fxs'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <returns>reflectance at given single set of optical properties and spatial frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFx(Vts.IOpticalPropertyRegion[],System.Double[])">
            <summary>
            Overload of ROfFx. Determines reflectances at tissue 'regions' and spatial frequencies 'fxs'
            </summary>
            <param name="regions">medium optical and geometric properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <returns>reflectance at given single set of optical properties and spatial frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFx(Vts.OpticalProperties[],System.Double)">
            <summary>
            Overload of ROfFx. Determines reflectances at optical properties 'ops' and spatial frequency 'fx'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <returns>reflectance at given optical properties and single spatial frequency</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFx(Vts.IOpticalPropertyRegion[][],System.Double)">
            <summary>
            Overload of ROfFx. Determines reflectances of tissue 'regions' and spatial frequency 'fx'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <returns>reflectance of given tissue regions and single spatial frequency</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.OpticalProperties,System.Double[],System.Double[])">
            <summary>
            Overload of ROfFxAndTime. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and times 'times'
            </summary>
            <param name="op">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given single set of optical properties, spatial frequencies and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.IOpticalPropertyRegion[],System.Double[],System.Double[])">
            <summary>
            Overload of ROfFxAndTime. Determines reflectances of tissue 'regions', spatial frequencies 'fxs' and times 'times'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance of given tissue regions, spatial frequencies and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.OpticalProperties[],System.Double,System.Double[])">
            <summary>
            Overload of ROfFxAndTime. Determines reflectances at optical properties 'ops', spatial frequency 'fx' and times 'times'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, single spatial frequency and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.IOpticalPropertyRegion[][],System.Double,System.Double[])">
            <summary>
            Overload of ROfFxAndTime. Determines reflectances of tissue 'regions', spatial frequency 'fx' and times 'times'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance of given tissue regions, single spatial frequency and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.OpticalProperties[],System.Double[],System.Double)">
            <summary>
            Overload of ROfFxAndTime. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and time 't'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given optical properties, spatial frequencies and single time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.OpticalProperties,System.Double,System.Double[])">
            <summary>
            Overload of ROfFxAndTime. Determines reflectances at optical properties 'op', spatial frequency 'fx' and times 'times'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given single set of optical properties, single spatial frequency and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.IOpticalPropertyRegion[],System.Double,System.Double[])">
            <summary>
            reflectance as a function of spatial-frequency and time
            </summary>
            <param name="regions">tissue region's optical properties</param>
            <param name="fx">spatial-frequency</param>
            <param name="times">times</param>
            <returns>R(fx,times)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.OpticalProperties,System.Double[],System.Double)">
            <summary>
            Overload of ROfFxAndTime. Determines reflectances at optical properties 'op', spatial frequencies 'fxs' and time 't'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given single set of optical properties, spatial frequencies, and single time </returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.OpticalProperties[],System.Double,System.Double)">
            <summary>
            Overload of ROfFxAndTime. Determines reflectances at optical properties 'ops', spatial frequency 'fx' and time 't'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance at given optical properties, single spatial frequency and single time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.OpticalProperties,System.Double[],System.Double[])">
            <summary>
            Overload of ROfFxAndFt. Determines reflectances at optical properties 'op', spatial frequencies 'fxs' and time frequencies 'fts'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given single set of optical properties, spatial frequencies and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.IOpticalPropertyRegion[],System.Double[],System.Double[])">
            <summary>
            Overload of ROfFxAndFt. Determines reflectances of tissue 'regions', spatial frequencies 'fxs' and time frequencies 'fts'
            </summary>
            <param name="regions">medium regions</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given single set of optical properties, spatial frequencies and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.OpticalProperties[],System.Double,System.Double[])">
            <summary>
            Overload of ROfFxAndFt. Determines reflectances at optical properties 'ops', spatial frequency 'fx' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given optical properties, single spatial frequency and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.IOpticalPropertyRegion[],System.Double,System.Double[])">
            <summary>
            Overload of ROfFxAndFt. Determines reflectances of tissue 'regions', spatial frequency 'fx' and time frequencies 'fts'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance of given tissue regions, single spatial frequency and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndTime(Vts.IOpticalPropertyRegion[],System.Double[],System.Double)">
            <summary>
            Overload of ROfFxAndTime. Determines reflectances of tissue 'regions', spatial frequencies 'fxs' and time 't'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="time">time (ns)</param>
            <returns>reflectance of given tissue regions, single spatial frequencies and time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.OpticalProperties[],System.Double[],System.Double)">
            <summary>
            Overload of ROfFxAndFt. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and time frequency 'ft'
            </summary>
            <param name="ops">sets of medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at given optical properties, spatial frequencies and single modulation frequency</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double)">
            <summary>
            Overload of ROfFxAndFt. Determines reflectances of tissue 'regions', spatial frequency 'fx' and time frequencies 'fts'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance of given tissue regions, single spatial frequency and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.OpticalProperties,System.Double,System.Double[])">
            <summary>
            Overload of ROfFxAndFt. Determines reflectances at optical properties 'op', spatial frequency 'fx' and time frequencies 'fts'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given single set of optical properties, single spatial frequency and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.IOpticalPropertyRegion[],System.Double[],System.Double)">
            <summary>
            Overload of ROfFxAndFt. Determines reflectances of tissue 'regions', spatial frequency 'fx' and time frequencies 'fts'
            </summary>
            <param name="regions">sets of medium regions</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance of given tissue regions, single spatial frequency and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.OpticalProperties,System.Double[],System.Double)">
            <summary>
            Overload of ROfFxAndFt. Determines reflectances at optical properties 'op', spatial frequencies 'fxs' and time frequency 'ft'
            </summary>
            <param name="op">medium optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at given single set of optical properties, spatial frequencies and single modulation frequency</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.ROfFxAndFt(Vts.OpticalProperties[],System.Double,System.Double)">
            <summary>
            Overload of ROfFxAndFt. Determines reflectances at optical properties 'ops', spatial frequency 'fx' and time frequency 'ft'
            </summary>
            <param name="ops">medium optical properties</param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="ft">modulation frequency (GHz)</param>
            <returns>reflectance at given optical properteis, single spatial frequency and single modulation frequency</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZ(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfRhoAndZ function. Determines fluences at optical properties 'ops' and source-detector separations 'rhos' and 'zs'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <returns>fluence at given optical properties, rhos and depths (zs)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZ(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfRhoAndZ function. Determines fluences of tissue 'regions' and source-detector separations 'rhos' and 'zs'
            </summary>
            <param name="regions">sets of medium regions </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <returns>fluence of given tissue regions, rhos and depths (zs)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndTime function. Determines fluences at optical properties 'ops', source-detector separations 'rhos', 'zs' and times 'times'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns>fluence at given optical properties, rhos, depths (zs) and times</returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZAndTime(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndTime function. Determines fluences at optical properties 'ops', source-detector separations 'rhos', 'zs' and times 'times'
            </summary>
            <param name="regions">sets of medium regions </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns>fluence at given optical properties, rhos, depths (zs) and times</returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndFt function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos', 'zs' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>fluence at given optical properties, rhos, depths (zs) and modulation frequencies</returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZAndFt(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfRhoAndZAndFt function. Determines reflectances at tissue 'regions', source-detector separations 'rhos', 'zs' and time frequencies 'fts'
            </summary>
            <param name="regions">sets of medium regions </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>fluence at given tissue regions, rhos, depths (zs) and modulation frequencies</returns>
            <remarks>IEnumerables can be one or more values - use the .AsEnumerable() extension method (in Vts.Extensions) on single items</remarks>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfFxAndZ(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfFxAndZ function. Determines fluences at optical properties 'ops' and spatial frequencies 'fxs' and 'zs'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <returns>reflectance at given optical properties, spatial frequencies and depths (zs)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfFxAndZAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfFxAndZAndTime function. Determines fluences at optical properties 'ops', spatial frequencies 'fxs', 'zs' and times 'times'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, spatial frequencies, depths and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfFxAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Overload of scalar FluenceOfFxAndZAndFt function. Determines fluences at optical properties 'ops', spatial frequencies 'fxs' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>fluence at given optical properties, spatial frequencies, z values and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZ(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Overload of FluenceOfRhoAndZ function. Determines fluences at optical properties 'ops', source-detector separations 'rhos' and 'zs'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <returns>fluence at given optical properties, rhos and z values</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZ(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[])">
            <summary>
            Overload of FluenceOfRhoAndZ function. Determines fluences of tissue 'regions', source-detector separations 'rhos' and 'zs'
            </summary>
            <param name="regions">sets of medium regions </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <returns>fluence of given tissue regions, rhos and z values</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZAndTime(Vts.OpticalProperties[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Overload of FluenceOfRhoAndZAndTime function. Determines fluences at optical properties 'ops', source-detector separations 'rhos', 'zs' and times 'times'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns>fluence at given optical properties, rhos, z values (depths) and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZAndTime(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[],System.Double[])">
            <summary>
            Overload of FluenceOfRhoAndZAndTime function. Determines fluences at optical properties 'ops', source-detector separations 'rhos', 'zs' and times 'times'
            </summary>
            <param name="regions">sets of medium regions </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns>fluence at given optical properties, rhos, z values (depths) and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZAndFt(Vts.OpticalProperties[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Overload of FluenceOfRhoAndZAndFt function. Determines reflectances at optical properties 'ops', source-detector separations 'rhos', 'zs' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>fluence at given optical properties, rhos, z values (depths) and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfRhoAndZAndFt(Vts.IOpticalPropertyRegion[][],System.Double[],System.Double[],System.Double[])">
            <summary>
            Overload of FluenceOfRhoAndZAndFt function. Determines reflectances at tissue 'regions', source-detector separations 'rhos', 'zs' and time frequencies 'fts'
            </summary>
            <param name="regions">sets of medium regions </param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>fluence at given tissue regions, rhos, z values (depths) and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfFxAndZ(Vts.OpticalProperties[],System.Double[],System.Double[])">
            <summary>
            Overload of FluenceOfFxAndZ function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs' and 'zs'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <returns>reflectance at given optical properties, spatial frequencies and z values (depths)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfFxAndZAndTime(Vts.OpticalProperties[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Overload of FluenceOfFxAndZAndTime function. Determines reflectances at optical properties 'ops', spatial frequencies 'fxs', 'zs' and times 'times'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at given optical properties, spatial frequencies and z values (depths) and times</returns>        
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.ForwardSolverBase.FluenceOfFxAndZAndFt(Vts.OpticalProperties[],System.Double[],System.Double[],System.Double[])">
            <summary>
            Overload of FluenceOfFxAndZAndFt function. Determines reflectances at optical properties 'ops', spatial frequency 'fx', 'zs' and time frequencies 'fts'
            </summary>
            <param name="ops">sets of medium optical properties </param>
            <param name="fx">spatial frequency (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">modulation frequencies (GHz)</param>
            <returns>reflectance at given optical properties, spatial frequencies z values (depths) and modulation frequencies</returns>        
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.INurbs">
            <summary>
            Defines the methods and properties that need to be implemented by the NurbsGenerator 
            class and by its stub version, StubNurbsGenerator used for Unit Testing.  
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.INurbs.GetMinimumValidTime(System.Double)">
            <summary>
            Defines signature for a method used to consider cousality of the photon migration.
            </summary>
            <param name="rho">source detector separation</param>
            <returns>minimal valid time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.INurbs.ComputeCurvePoint(System.Double,Vts.Modeling.ForwardSolvers.NurbsValuesDimensions)">
            <summary>
            Defines the signature of the method used to compute a point on a NURBS curve.
            </summary>
            <param name="point">physical coordinate of the point</param>
            <param name="dimension">physical dimension represented by the NURBS curve</param>
            <returns>Value of a point on the curve</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.INurbs.ComputeSurfacePoint(System.Double,System.Double)">
            <summary>
            Defines the signature of the method used to compute the point on a NURBS surface.
            </summary>
            <param name="time">time coordinate</param>
            <param name="space">space coordinate(rho or fx)</param>
            <returns>Value of a point  on the surface </returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.INurbs.ComputePointOutOfSurface(System.Double,System.Double,System.Double)">
            <summary>
            Defines the signature of the method used to compute the point outside the surface range.
            </summary>
            <param name="time">time coordinate</param>
            <param name="space">space coordinate(rho or fx)</param>
            <param name="edgeValue">point calculated on a position on the limit of the surface</param>
            <returns>Value of a point outside the surface</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.INurbs.EvaluateNurbsCurveIntegral(System.Double,System.Double)">
            <summary>
            Defines the signature of the method used to calculate the integral value of an
            isoparametric NURBS curve multiplied by an exponential function analitically.
            </summary>
            <param name="space">radial position or spatial frequency mapped to the reference spatial value</param>
            <param name="exponentialTerm">exponential decay due to absorption</param>
            <returns>integral value of an isoparametric NURBS curve</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.INurbs.EvaluateNurbsCurveFourierTransform(System.Double,System.Double,System.Double)">
            <summary>
            Defines the signature for the method used to evaluate the FT of an isoparametric curve.
            </summary>
            <param name="space">spatial coordinate</param>
            <param name="expTerm">exponential coefficient</param>
            <param name="ft">temporal frequency</param>
            <returns>R(ft) at  fixed rho</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.INurbs.EvaluateTensorProductControlPoints(System.Double)">
            <summary>
            Defines the signature of the method used to evaluate the tensor product control points
            necessary to evaluate the integral of an isoparametric curve.
            </summary>
            <param name="space_ref">spatial coordinate mapped to teh reference space</param>
            <returns>Tensor product control points for an isoparametric curve on a surface</returns>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.INurbs.TimeValues">
            <summary>
            Gets the NurbsValues along the time dimension.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.INurbs.SpaceValues">
            <summary>
            Gets the NurbsValues along the space dimension.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.INurbs.TimeKnotSpanPolynomialCoefficients">
            <summary>
            Gets or sets the coefficients of the non vanishing B-splines over each knot span.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.INurbs.NativeTimes">
            <summary>
            native times
            </summary>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver">
            <summary>
            Forward solver based on the Scaled Monte Carlo approach, proposed by Kienle and Patterson,
            used to evaluate the reflectance of a semi-infinite homogenous medium with g = 0.8 and n = 1.4.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.#ctor">
            <summary>
            constructor for scaled Monte Carlo Forward Solver
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfRho(Vts.OpticalProperties,System.Double)">
            <summary>
            Evaluates the steady state reflectance at 
            a single source detector separation rho, for the specified single set of optical properties.
            </summary>
            <param name="op">optical properties</param>
            <param name="rho">source detector separation</param>
            <returns>spatailly resolved reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfRho(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates the steady state reflectance at multipl sets of optical properties and source-detector separations.
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">source detector separations</param>
            <returns>reflectance at specified optical properties and rhos</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfRhoAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Evaluates spatially- and temporally- resolved reflectance at specified optical properties, rho and time
            </summary>
            <param name="op">optical properties</param>
            <param name="rho">source-detector separation</param>
            <param name="time">time</param>
            <returns>reflectance at specified optical properties, rho and time </returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfRhoAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates spatially- and temporally- resolved reflectance at specified optical properties, rhos and times
            </summary>
            <param name="ops">multiple sets of optical properties</param>
            <param name="rhos">rhos</param>
            <param name="times">times</param>
            <returns>reflectance at specified optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfRhoAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Call a method to compute a discrete Fourier Transform on R(rho,t) MC results.
            </summary>
            <param name="op">Optical Properties</param>
            <param name="rho">rho</param>
            <param name="ft">time frequency</param>
            <returns>reflectance at specified optical properties, rho and time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfRhoAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            reflectance as a function of s-d separations and temporal-frequencies
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">s-d separations</param>
            <param name="fts">temporal-frequencies</param>
            <returns>R(rhos,fts)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfFx(Vts.OpticalProperties,System.Double)">
            <summary>
            Evaluates reflectance as a function of spatial frequency
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial frequency</param>
            <returns>reflectance at specified optical properties and spatial frequency</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfFx(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            reflectance as a function of spatial-frequencies
            </summary>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial frequencies</param>
            <returns>R(fxs)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfFxAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Evaluates reflectance as aa function of spatial frequency and time
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial frequency</param>
            <param name="time">time</param>
            <returns>reflectance at specified optical properties, spatial frequency and time</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfFxAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            reflectance as a function of spatial-frequencies and times
            </summary>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial-frequencies</param>
            <param name="times">times</param>
            <returns>R(fxs,times)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfFxAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Evaluates reflectance ay spatial frequency and modulation frequency
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial frequency</param>
            <param name="ft">modulation frequency</param>
            <returns>reflectance at specified optical properties, spatial frequency and modulation frequency</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.ROfFxAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates reflectance as a function of multiple sets of optical properties, spatial frequencies and modulation frequencies
            </summary>
            <param name="ops">multiple sets of optical properties</param>
            <param name="fxs">spatial frequencies</param>
            <param name="fts">modulation frequencies</param>
            <returns>reflectance at specified optical properties, spatial frequencies and modulation frequencies</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.FluenceOfRhoAndZ(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates fluence as a function of optical properties, source-detector separations (rhos) and depths (zs)
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">source-detector separations</param>
            <param name="zs">z values (depths)</param>
            <returns>reflectance at specified optical properties, rhos and depths</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.FluenceOfRhoAndZAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates fluence as a function of optical properties, source-detector separations (rhos) and tines (ts)
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">source-detector separations</param>
            <param name="zs">z values (depths)</param>
            <param name="times">times (ns)</param>
            <returns>reflectance at specified optical properties, rhos and depths</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.FluenceOfRhoAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as a function of s-d separations, depths and temporal-frequencies
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">s-d separations</param>
            <param name="zs">depths</param>
            <param name="fts">temporal-frequencies</param>
            <returns>fluence(rhos,zs,fts)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.FluenceOfFxAndZ(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as a function of spatial-frequencies and depths
            </summary>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial frequencies</param>
            <param name="zs">depths</param>
            <returns>fluence(fxs,zs)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.FluenceOfFxAndZAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as a function of spatial-frequencies, depths and times
            </summary>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial frequencies</param>
            <param name="zs">depths</param>
            <param name="times">times</param>
            <returns>fluence(fxs,zs,times)</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloForwardSolver.FluenceOfFxAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as a function of spatial-frequencies, depths and temporal-frequencies
            </summary>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial-frequencies</param>
            <param name="zs">depths</param>
            <param name="fts">temporal-frequencies</param>
            <returns>fluence(fxs,zs,fts)</returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.MonteCarloLoader">
            <summary>
            class to handle loading of scaled Monte Carlo database
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.MonteCarloLoader.nrReference">
            <summary>
            number of rho bins in reference database
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.MonteCarloLoader.drReference">
            <summary>
            size of rho bins in reference database
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.MonteCarloLoader.ntReference">
            <summary>
            number of time bins in reference database
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.MonteCarloLoader.dtReference">
            <summary>
            size of time bins in reference database
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.MonteCarloLoader.muspReference">
            <summary>
            mus' value used in reference database
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.MonteCarloLoader.nfxReference">
            <summary>
            number of spatial frequency bins in reference 
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.MonteCarloLoader.dfxReference">
            <summary>
            size of spatial frequency bins in reference
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.MonteCarloLoader.RhoReference">
            <summary>
            array of rho bin centers in reference database
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.MonteCarloLoader.TimeReference">
            <summary>
            array of time bin centers in reference database
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.MonteCarloLoader.FxReference">
            <summary>
            array of spatial frequency centers in reference
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.MonteCarloLoader.RReferenceOfRhoAndTime">
            <summary>
            reference database R(rho,time)
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.MonteCarloLoader.RReferenceOfFxAndTime">
            <summary>
            reference database R(fx,time)
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.MonteCarloLoader.folder">
            can't point to N1e7 until writing to isolated storage working for R_fxt code below
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloLoader.#ctor">
            <summary>
            constructor that loads scaled Monte Carlo reference data and database 
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloLoader.InitializeVectorsAndInterpolators">
            <summary>
            InitializeVectorsAndInterpolators reads in reference database and initializes data 
            Note that the reference data is now in mm/ns so no conversion needed
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloLoader.GetAllScaledRhos(Vts.OpticalProperties)">
            <summary>
            method to get all scaled rho values
            </summary>
            <param name="op">optical properties</param>
            <returns>scaled rho values</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloLoader.GetAllScaledTimes(Vts.OpticalProperties)">
            <summary>
            method to get all scaled time values
            </summary>
            <param name="op">optical properties</param>
            <returns>scaled time values</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloLoader.GetAllScaledFxs(Vts.OpticalProperties)">
            <summary>
            method to get all scaled spatial-frequencies
            </summary>
            <param name="op">optical properties</param>
            <returns>scaled fx values</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.MonteCarloLoader.GetFresnel(System.Double,System.Double,System.Double)">
            <summary>
            method to get Fresnel value 
            </summary>
            <param name="nIn">refractive index of incoming ray</param>
            <param name="nOut">refractive index of outgoing ray</param>
            <param name="theta">angle of inception</param>
            <returns>Fresnel value</returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.NurbsForwardSolver">
            <summary>
            Forward solver based on the Scaled Monte Carlo approach, proposed by Kienle and Patterson,
            used to evaluate the reflectance of a semi-infinite homogenous medium with g = 0.8 and n = 1.4.
            The reference time and space resolved reflectance, and the reference spatial frequancy and
            time resolved reflectance are held in a NurbsGenerator class which computes the interpolation
            necessary to evaluate the reflectance in the specific domain.
            The interpolation is based on NURBS surfaces theory. The main reference used to implement
            this forward solver is 'The NURBS Book' by Las Piegl and Wayne Tiller.
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.v">
            <summary>
            speed of light
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.#ctor(Vts.Modeling.ForwardSolvers.INurbs,Vts.Modeling.ForwardSolvers.INurbs)">
            <summary>
            Constructor which creates an istance of NurbsForwardSolver setting
            the NurbsGenerators to the values passed as Input.
            </summary>
            <param name="rdGenerator">real domain NurbsGenerator</param>
            <param name="sfdGenerator">spatial frequancy domain generator</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.#ctor">
            <summary>
            Default class constructor called by solver factory.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.#ctor(Vts.Modeling.ForwardSolvers.INurbs)">
            <summary>
            Constructor used to create an istance of NurbsForwardSolver
            with the same stub NurbsGenerator for all the NurbsGenerators.
            Used for Unit Tests of the class.
            </summary>
            <param name="generator">stub NurbsGenerator</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfRho(Vts.OpticalProperties,System.Double)">
            <summary>
            Calls its vectorized version to evaluate the steady state reflectance at 
            a source detector separation rho, for the specified optical properties.
            </summary>
            <param name="op">optical properties</param>
            <param name="rho">source detector separation</param>
            <returns>space resolved reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfRho(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the steady state reflectance for the specified optical properties
            at source detector separations rhos.
            The radial distance rho is scaled to the reference space to evaluate rho_ref. 
            If rho_ref is on the reference surface the reference rho-time resolved 
            reflectance is scaled and the isoprametric Nurbs curve is integrated
            analitically  over time. To evaluate the integral of the reflectance out of 
            the time range it evaluates the linear approximation of the logarithm of
            the tail of the curve and integrates it from tMax to infinity.
            If rho_ref is out of range the method returns 0.
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">source detector separation</param>
            <returns>space resolved reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfRhoAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Calls its vectorized version to evaluate the time and space resolved reflectance
            at a source detector separation rho and at time t, for the specified optical properties.
            </summary>
            <param name="op">optical properties</param>
            <param name="rho">source detector separation</param>
            <param name="time">time</param>
            <returns>spatial and temporal resolved reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfRhoAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the reflectance at radial distance rho and time t scaling the
            reference rho-time resolved reflectance.
            The returned value is forced to zero if the time t is smaller then the
            minimal time of flight required to reach a detector at a distance rho. 
            If a point of the reference reflectance outside the time range of the
            surface is required, the value is extrapolated using the linear 
            approximation of the logarithm of R for two points placed at the end of
            the time range [Tmax - 0.1ns, Tmax].
            If the required point is outside the radial range a linear extarpolation 
            is used, based on the value of R at [0.95*RhoMax, RhoMax].
            If the required point is outside both ranges a linear combination of the
            two extrapolations is adopted.
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">source detector separation</param>
            <param name="times">time</param>
            <returns>space and time resolved reflectance at rho and t</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfRhoAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
             Calls its vectorized version to evaluate the temporal frequency and space resolved
             reflectance at a source detector separation rho for a modulation frequency ft,
             for the specified optical properties.
            </summary>
            <param name="op">optical properties</param>
            <param name="rho">source detector separation</param>
            <param name="ft">modulation frequency</param>
            <returns>reflectance intensity</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfRhoAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
             Evaluates the temporal frequency and space resolved reflectance at a source 
             detector separation rho for a modulation frequency ft,for the specified 
             optical properties. It calculates the Fourier transform of the NURBS
             curve R(t) at the required source detector separation.
             The used FT is analitycal or discrete according to the boolean value 'analyticIntegration'.
            </summary>
            <param name="ops">optical properties</param>
            <param name="rhos">source detector separation</param>
            <param name="fts">modulation frequency</param>
            <returns>reflectance intensity</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfFx(Vts.OpticalProperties,System.Double)">
            <summary>
            Calls its vectorized version to evaluate the spatial frequency
            resolved reflectance for the spatial frequancy fx, for the 
            specified optical properties. 
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial frequency</param>
            <returns>spatial frequency resolved reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfFx(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the spatial frequancy resolved reflectance at fx applying the scaling on
            the reference fx-time resolved reflectance.
            Than integrates analitically the isoprametric NURBS curve over time if fx is on the
            surface.
            If fx is out of range it returns 0.
            </summary>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial frequency</param>
            <returns>spatial frequency resolved reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfFxAndTime(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Calls its vectorized version to evaluate the time and space resolved reflectance
            for a spatial frequency, fx, and at time, t, for the specified optical properties.
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial frequency</param>
            <param name="time">time</param>
            <returns>spatial frequency and time resolved reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfFxAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Returns the reflectance at spatial frequency, fx, and time, t, scaling the 
            reference fx-time resolved reflectance.
            If a point of the reference reflectance outside the time/spatial frequancy range 
            of the surface is required, the value is extrapolated using the first derivative
            along the time/spatial frequency dimension.
            If the required point is outside both ranges a linear combination of the
            two derivatives is used.
            </summary>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial frequency</param>
            <param name="times">time</param>
            <returns>spatial frequency and time resolved reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfFxAndFt(Vts.OpticalProperties,System.Double,System.Double)">
            <summary>
            Calls its vectorized overload to evaluate the spatial frequency and temporal 
            frequency resolved reflectance.
            </summary>
            <param name="op">optical properties</param>
            <param name="fx">spatial frequency</param>
            <param name="ft">temporal frequancy</param>
            <returns>spatial frequency and temporal frequancy resolved reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ROfFxAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates the spatial frequency and temporal frequency resolved reflectance
            calculating the Fourier transform of the NURBS curve R(t) at the
            required spatial frequency for the specified optical properties. 
            The computed FT is analitycal or discrete according to the boolean value 'analyticIntegration'.
            </summary>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial frequency</param>
            <param name="fts">temporal frequancy</param>
            <returns>spatial frequency and temporal frequancy resolved reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.FluenceOfRhoAndZ(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates the radial resolved fluence.
            <remarks>Not implemented.</remarks>
            </summary>
            <param name="ops">optical properties of the medium</param>
            <param name="rhos">source-detector separation (mm)</param>
            <param name="zs">z values (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.FluenceOfRhoAndZAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates the temporal and radial resolved fluence.
            </summary>
            <remarks>Not implemented.</remarks>
            <param name="ops">set of optical properties for the medium</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.FluenceOfRhoAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates the temporal frequency and radial resolved fluence.
            </summary>
            <remarks>Not implemented.</remarks>
            <param name="ops">set of optical properties for the medium</param>
            <param name="rhos">source-detector separations (mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">temporal frequency (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.FluenceOfFxAndZ(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates the spatial frequancy resolved fluence.
            </summary>
            <remarks>Not implemented.</remarks>
            <param name="ops">optical properties</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.FluenceOfFxAndZAndTime(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates the spatial frequancy and time resolved fluence.
            </summary>
            <remarks>Not implemented.</remarks>
            <param name="ops">set of optical properties for the medium</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="times">times (ns)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.FluenceOfFxAndZAndFt(System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates the spatial frequancy and temporal frequency resolved fluence.
            </summary>
            <remarks>Not implemented.</remarks>
            <param name="ops">set of optical properties for the medium</param>
            <param name="fxs">spatial frequencies (1/mm)</param>
            <param name="zs">z values (mm)</param>
            <param name="fts">temporal frequencies (GHz)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.CheckIfValidOutput(System.Double)">
            <summary>
            Returns zero if the input value is smaller then zero of if it is NaN.
            Negative value are not possible for the measured reflectance.
            The values calculated with the NURBS could be negative when the time
            point is very close to the 'physical' beginning of the curve R(t) due
            to obscilatoions of the interpolations used to capture the ascent of the curve.
            </summary>
            <param name="value">double precision number</param>
            <returns>zero or the input value</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.GetScalingFactor(Vts.OpticalProperties,System.Int32)">
            <summary>
            Returns the constant scaling factor for the different reflectance domain.
            </summary>
            <param name="op">optical properties</param>
            <param name="power">domain dependent scaling factor power</param>
            <returns>scaling factor</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsForwardSolver.ExtrapolateIntegralValueOutOfRange(Vts.Modeling.ForwardSolvers.INurbs,System.Double,Vts.OpticalProperties)">
            <summary>
            Extrapolates the linear decay of the log of the tail of the curve and integrates
            analitically from tMax to infinity to evaluate the steady state signal
            </summary>
            <param name="generator">NurbsGenerator</param>
            <param name="space_ref">spatial coordiante</param>
            <param name="op">optical Properties</param>
            <returns>Integral value of the curve extrapolated outside the time range</returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.NurbsGeneratorType">
            <summary>
            Defines the nurbs surface physical domain.
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.NurbsGeneratorType.RealDomain">
            <summary>
            Radial and temporal generator.
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.NurbsGeneratorType.SpatialFrequencyDomain">
            <summary>
            Spatial frequency and temporal generator.
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.NurbsGeneratorType.Stub">
            <summary>
            Generator used for testing of the methods of the class.
            </summary>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.NurbsGenerator">
            <summary>
            Class that contains the reference NURBS values.
            Its methods are used to evaluate the value of a point 
            on the NURBS surface or curve using B-splines interpolation,
            and to evaluate the integral of a NURBS curve.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsGenerator.GeneratorType">
            <summary>
            Gets or sets the physical domain rapresented by the NURBS surface.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsGenerator.TimeValues">
            <summary>
            Gets or sets the NurbsValues specific to the time dimension.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsGenerator.SpaceValues">
            <summary>
            Gets or sets the NurbsValues specific to the space dimension(rho or fx).
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsGenerator.ControlPoints">
            <summary>
            Gets or sets the NURBS control points.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsGenerator.TimeKnotSpanPolynomialCoefficients">
            <summary>
            List of the non vanishing Bsplines coefficients for each knot span.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsGenerator.NativeTimes">
            <summary>
            temporal coordinate of the native reference points (t_l)
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.#ctor(Vts.Modeling.ForwardSolvers.NurbsGeneratorType)">
            <summary>
            Class constructor which loads the reference values from resources
            based on the generator type.
            </summary>
            <param name="generatorType">NURBS surface physical domain</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.#ctor">
            <summary>
            Default constructor,used for testing. 
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.BinarySearch(Vts.Modeling.ForwardSolvers.NurbsValues,System.Double)">
            <summary>
            Binary search used to determine the span index where the parametric point belongs.
            </summary>
            <param name="nurbsValues">NurbsValues class which contains the knot,degree and control points</param>
            <param name="parametricPoint">parametric point mapped in the interval 0-1</param>
            <returns>index of the knot span where the parametric point belongs</returns>
            <exception cref="T:System.ArgumentException">Thrown when the search has to be performed on missing dimension</exception> 
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.EvaluateBasisFunctions(System.Int32,System.Double,Vts.Modeling.ForwardSolvers.NurbsValues)">
            <summary>
            Computes the non vanishing basis functions on the specific knot span.
            Algorithm 2.2 from 'The NURBS Book' page 70.
            </summary>
            <param name="spanIndex">index of the knot span where the parametric point belongs</param>
            <param name="parametricPoint">parametric variable</param>
            <param name="nurbsValues">NurbsValues class which contains the knot,degree and control points</param>
            <returns>array with the value of the non vanishing basis functions evaluated at the parametric point</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.EvaluateCurvePoint(System.Int32,System.Double[],Vts.Modeling.ForwardSolvers.NurbsValues)">
            <summary>
            Calculates the value of a point on a NURBS curve.
            </summary>
            <param name="spanIndex">index of the knot span where the parametric point belongs</param>
            <param name="basisFunctions">array with the value of the non vanishing basis functions evaluated at a parametric point inside the knot span</param>
            <param name="nurbsValues">NurbsValues class which contains the knot,degree and control points</param>
            <returns>value of a point on a NURBS curve</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.EvaluateSurfacePoint(System.Int32,System.Double[],System.Int32,System.Double[])">
            <summary>
            Calculate the value of a point on a NURBS surface.
            </summary>
            <param name="timeSpanIndex">knot span index along the temporal dimension</param>
            <param name="timeBasisFunctions">array with the value of the non vanishing basis functions along the temporal coordinate</param>
            <param name="spaceSpanIndex">knot span index along the spatial dimension</param>
            <param name="spaceBasisFunctions">array with the value of the non vanishing basis functions along the spatial coordinate(rho or fx)</param>
            <returns>value of a point on a NURBS surface</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.FindSpan(Vts.Modeling.ForwardSolvers.NurbsValues,System.Double)">
            <summary>
            Searches for the knot span where the parametric point lies, with a classic 
            binary search.If the point is larger then the last knot element returns the last span index
            to evaluate the value of a  point on the edge of the surface, which is later used for derivative
            extrapolation.
            Adapted from algorithm 2.1 from 'The NURBS Book' page 68.
            </summary>
            <param name="nurbsValues">NurbsValues class which contains the knot,degree and control points</param>
            <param name="parametricPoint">parametric point</param>
            <returns>knot span where the parametric point belongs</returns>
            <exception cref ="T:System.ArgumentException">Thrown when the input parametric point is negative</exception> 
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.MultiplyControlPointsAndPolynomialCoefficients(System.Double[0:,0:],System.Double[])">
            <summary>
            Multiplies each polynomial coefficient with its corresponding control point.
            'The NURBS Book' page 81.
            </summary>
            <param name="polynomialCoefs">polynmial coefficients</param>
            <param name="controlPoints">control point of the isoparamentric Nurbs curve</param>
            <returns>polynomial coefficients multiplied by the respective control point</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.EvaluateKnotSpanIntegralValue(System.Double,System.Double[0:,0:],System.Double[],System.Double,System.Double,System.Double)">
            <summary>
            Returns the integral of a NURBS curve over a single knotspan.
            If the integral has to be performed to evaluate ROfRho the algorithm checks if the
            lower time limit of the knot span is larger then the minimum time 
            of flight necessary to reach the detector. The integration is analytical
            only for the real domain and only if the time span is larger then a threshold value
            and only if the value of the exponential decay due to absorption is larger then a
            threshold value.
            </summary>
            <param name="exponentialTerm"> exponential decay due to absorption</param>
            <param name="polynomialCoefs">polynomial coefficients of the non null B-splines curves over the knot span</param>
            <param name="controlPoints">tensor product control points of the isoparametric curve</param>
            <param name="lowerLimit">knot span lower limit mapped to the physical value of the parametrized variable</param>
            <param name="upperLimit">knot span upper limit mapped to the physical value of the parametrized variable</param>
            <param name="space">spatial coordiante mapped to the refernce space</param>
            <returns>integral value of a NURBS curve over a single knotspan</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.IntegrateExponentialMultipliedByPolynomial(System.Double,System.Double[],System.Double,System.Double)">
            <summary>
            Evaluates for each term of the polynomial the
            integral value of its multiplication with the
            exponential decay within the lower and upper 
            limit.
            </summary>
            <param name="exponentialTerm">exponential term</param>
            <param name="polynomialCoefficients">polynomial coefficients sorted in degree</param>
            <param name="lowerLimit">lower integration limit</param>
            <param name="upperLimit">upper integration limit</param>
            <returns>integral of the polynomial multiplied by an exponential over the specified range</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.IntegrateExponentialMultipliedByMomomial(System.Int32,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Evaluates the integral value of the multiplication 
            between a monomial function and an exponential 
            function within the lower and upper limit.
            </summary>
            <param name="degree">degree of the monomial term</param>
            <param name="exponentialTerm">exonential term</param>
            <param name="monomialCoefficient">monomial coefficient</param>
            <param name="lowerLimit">lower limit of integration</param>
            <param name="upperLimit">upper limit of ntegration</param>
            <returns>integral value over the range</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.GetIntegralFunction(System.Int32,System.Double)">
            <summary>
            According to the degree of the monomial term and to the value of the exponential
            term returns the analytical integral function.
            </summary>
            <param name="degree">degree of the monomial coefficient</param>
            <param name="exponentialTerm">exponential decay</param>
            <returns>integral function</returns>
            <exception cref="T:System.ArgumentException">Thrown if the degree of the function is too high.</exception> 
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.ComputeCurvePoint(System.Double,Vts.Modeling.ForwardSolvers.NurbsValuesDimensions)">
            <summary>
            Evaluates a point on a NURBS curve.
            </summary>
            <param name="point">coordinate of the point on the NURBS curve, which is mapped to the parametric space</param>
            <param name="dimension">spatial(rho or fx) or temporal dimension identifier</param>
            <returns>value of the NURBS curve at a specific location</returns>
            <exception cref="T:System.ArgumentException">Thrown when the dimension is not valid</exception> 
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.ComputeSurfacePoint(System.Double,System.Double)">
            <summary>
            Evaluates the value of a point on a NURBS surface.
            </summary>
            <param name="time">time point</param>
            <param name="space">space point (rho or fx)</param>
            <returns>value of a point, identified by its spatial and temporal coordinates, on a NURBS surface</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.ComputePointOutOfSurface(System.Double,System.Double,System.Double)">
            <summary>
            Evaluates the value of a point out of the reference nurbs surface using the 
            derivative of the surfece using the derivative generators for the specific domain.
            </summary>
            <param name="time">time value mapped to the reference time</param>
            <param name="space">spatial value (rho or fx) mapped to the reference spatial value</param>
            <param name="edgeValue">reflectance value on the boundary 'edge' of the reference range </param>
            <returns>scaled reflectance value out of reference domain for the specific solution domain</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.EvaluateNurbsCurveIntegral(System.Double,System.Double)">
            <summary>
            Calculates the integral value of an isoparametric NURBS curve.
            </summary>
            <param name="space">radial position or spatial frequency mapped to the reference spatial value</param>
            <param name="exponentialTerm">exponential decay due to absorption</param>
            <returns>integral value of an isoparametric NURBS curve</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.EvaluateNurbsCurveFourierTransform(System.Double,System.Double,System.Double)">
            <summary>
            Evaluates the Fourier transform of an isoparametric Nurbs curve analitically.
            </summary>
            <param name="space">spatial coordinate</param>
            <param name="expTerm">exponential coefficients</param>
            <param name="ft">temporal frequency</param>
            <returns>R(ft) at fixed rho</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.EvaluateTensorProductControlPoints(System.Double)">
            <summary>
            Evaluates the tensor product control points of an isoparametric curve on 
            a NURBS surface. The curve has to be isoparametric in the space dimension.
            </summary>
            <param name="space_ref">spatial coordinate mapped to the reference domain</param>
            <returns>control points effective on a specific isoparametric curve along the time direction</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsGenerator.GetMinimumValidTime(System.Double)">
            <summary>
            Returns the first valid time of a R(t) curve.
            </summary>
            <param name="rho">source detector distance</param>
            <returns>first valid time</returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.NurbsValuesDimensions">
            <summary>
            Specifies the physical dimension of the NURBS characteristic values.
            Space refers to both rho or fx.
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.NurbsValuesDimensions.time">
            <summary>
            Time
            </summary>
        </member>
        <member name="F:Vts.Modeling.ForwardSolvers.NurbsValuesDimensions.space">
            <summary>
            Space refers to both rho and fx
            </summary>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.NurbsValues">
            <summary>
            Class where the reference values read from binary files in resources are stored.
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsValues.ValuesDimensions">
            <summary>
            Physical dimension, space or time
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsValues.KnotVector">
            <summary>
            Knots vector
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsValues.ControlPoints">
            <summary>
            Control Points
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsValues.MaxValue">
            <summary>
            Max value along the physical dimension
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.NurbsValues.Degree">
            <summary>
            Degree
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsValues.#ctor(Vts.Modeling.ForwardSolvers.NurbsValuesDimensions,System.Double[],System.Double,System.Int32)">
            <summary>
            Constructor to instantiate a class to write JSON file.
            </summary>
            <param name="valuesDimension">physical dimension, space or time</param>
            <param name="knots">knots vector</param>
            <param name="max">max value along the physical dimension</param>
            <param name="degree">degree</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsValues.#ctor(System.Double)">
            <summary>
            Constructor used for Unit testing of NurbsGenerator class.
            </summary>
            <param name="max">max value mapped to the interval 0-1</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsValues.#ctor(System.Int32)">
            <summary>
            Constructor used for Unit testing of NurbsGenerator class
            </summary>
            <param name="degree">degree of the NURBS curve</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsValues.#ctor(System.Double[],System.Int32,System.Double,System.Double[])">
            <summary>
            Constructor used for Unit testing of NurbsGenerator class
            </summary>
            <param name="knots">knots vector</param>
            <param name="degree">degree of the NURBS curve</param>
            <param name="max">max value mapped to the interval 0-1</param>
            <param name="controlPoints">control points</param>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.NurbsValues.#ctor">
            <summary>
            Default constructor to permit serialization
            </summary>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.Extensions.PhotonHittingDensityExtensions">
            <summary>
            extension methods for photon hitting density map generation
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.Extensions.PhotonHittingDensityExtensions.TimeFrequencyDomainFluence2SurfacePointPHD(Vts.IForwardSolver,System.Double,System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            temporal-frequency photon hitting density
            </summary>
            <param name="myForwardSolver">forward solver</param>
            <param name="timeModulationFrequency">temporal-frequency</param>
            <param name="ops">optical properties</param>
            <param name="rhoPrimes">s-d separations</param>
            <param name="zs">depths</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.Extensions.PhotonHittingDensityExtensions.SteadyStateFluence2SurfacePointPHD(Vts.IForwardSolver,System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            time-independent fluence for photon hitting density
            </summary>
            <param name="myForwardSolver">forward solver</param>
            <param name="ops">optical properties</param>
            <param name="rhoPrimes">s-d separations</param>
            <param name="zs">depths</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.Extensions.PhotonHittingDensityExtensions.TemporalPointSourceCenterlinePHD(Vts.IForwardSolver,System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            time-dependent photon hitting density from point source
            </summary>
            <param name="myForwardSolver">forward solver</param>
            <param name="ops">optical properties</param>
            <param name="rProbes"></param>
            <param name="rhos">s-d separations</param>
            <param name="zs">depths</param>
            <param name="ts">times</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.Extensions.PhotonHittingDensityExtensions.TemporalFrequencyPointSourceCenterlinePHD(Vts.IForwardSolver,System.Collections.Generic.IEnumerable{Vts.OpticalProperties},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            temporal frequency photon hitting density from point source
            </summary>
            <param name="myForwardSolver">forward solver</param>
            <param name="ops">optical properties</param>
            <param name="rProbes"></param>
            <param name="rhos">s-d separations</param>
            <param name="zs">depths</param>
            <param name="fts">temporal-frequencies</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver">
            <summary>
            Point source standard diffusion approximation forward solver
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver.StationaryReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            Evaluate the stationary radially resolved reflectance with the point source-image configuration
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="rho">radial location</param>
            <param name="fr1">Fresnel moment 1, R1</param>
            <param name="fr2">Fresnel moment 2, R2</param>
            <returns>reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver.StationaryFluence(System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters)">
            <summary>
            Evaluate the stationary radially resolved fluence with the point source-image
            configuration
            </summary>
            <param name="rho">radial location</param>
            <param name="z">depth location</param>
            <param name="dp">DiffusionParameters object</param>
            <returns>fluence</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver.StationaryFlux(System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters)">
            <summary>
            Evaluate the stationary radially resolved z-flux with the point source-image
            configuration
            </summary>
            <param name="rho">radial location</param>
            <param name="z">depth location</param>
            <param name="dp">DiffusionParamters object</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver.TemporalReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Evaluate the temporally-radially resolved reflectance with the point source-image
            configuration
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="rho">radial location</param>
            <param name="t">time</param>
            <param name="fr1">Fresnel Moment 1</param>
            <param name="fr2">Fresnel Moment 2</param>
            <returns>reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver.TemporalFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            Evaluate the temporally-radially resolved fluence using the point source-image configuration
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="rho">radial location</param>
            <param name="z">depth location</param>
            <param name="t">time</param>
            <returns>fluence</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver.TemporalFlux(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Double)">
            <summary>
            Evaluate the temporally-radially resolved z-flux using the point source-image configuration
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="rho">radial location</param>
            <param name="z">depth location</param>
            <param name="t">time</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver.TemporalFrequencyReflectance(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Numerics.Complex,System.Double,System.Double)">
            <summary>
            temporal-frequency reflectance
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="k">temporal-frequency</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver.TemporalFrequencyFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Numerics.Complex)">
            <summary>
            temporal-frequency fluence
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="k">temporal-frequency</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.PointSourceSDAForwardSolver.TemporalFrequencyZFlux(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double,System.Numerics.Complex)">
            <summary>
            temporal-frequency zflux calculation
            </summary>
            <param name="dp">diffusion parameters</param>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="k">temporal-frequency</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.SFDDiffusionForwardSolver">
            <summary>
            Class containing diffusion approximation solutions to the RTE in the
            spatial frequency domain.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.SFDDiffusionForwardSolver.StationaryOneDimensionalSpatialFrequencyFluence(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double)">
            <summary>
            Evaluate the time-independent, one dimensional spatial frequency, depth resolved
            fluence.
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="fx">spatial frequency</param>
            <param name="z">depth</param>
            <returns>fluence</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.SFDDiffusionForwardSolver.StationaryOneDimensionalSpatialFrequencyZFlux(Vts.Modeling.ForwardSolvers.DiffusionParameters,System.Double,System.Double)">
            <summary>
            Evaluates the depth resolved diffuse spatial frequency flux in the z-direction.
            </summary>
            <param name="dp">DiffusionParameters object</param>
            <param name="fx">spatial frequency</param>
            <param name="z">depth</param>
            <returns>z-flux</returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.StubNurbsGenerator">
            <summary>
            Class used for Unit testing of the NurbsGenerator methods and of the NurbsForwardSolver
            class.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.StubNurbsGenerator.GetMinimumValidTime(System.Double)">
            <summary>
            Returns minimum physical time of flight based on speed of light for n = 1,4.
            </summary>
            <param name="rho">source detector separation</param>
            <returns>t</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.StubNurbsGenerator.ComputeCurvePoint(System.Double,Vts.Modeling.ForwardSolvers.NurbsValuesDimensions)">
            <summary>
            Returns always 1, used for testing.
            </summary>
            <param name="point">point coordinate</param>
            <param name="dimension">dimension</param>
            <returns>1</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.StubNurbsGenerator.ComputeSurfacePoint(System.Double,System.Double)">
            <summary>
            Returns always -1, used for testing.
            </summary>
            <param name="time">time coordinate</param>
            <param name="space">space coordinate</param>
            <returns>-1</returns>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.StubNurbsGenerator.TimeValues">
            <summary>
            Gets Nurbs values for the time dimensions with max = 1.0
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.StubNurbsGenerator.SpaceValues">
            <summary>
            Gets Nurbs values for the time dimensions with max = 1.0
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.StubNurbsGenerator.TimeKnotSpanPolynomialCoefficients">
            <summary>
            Not implemented for stub class.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.StubNurbsGenerator.ComputePointOutOfSurface(System.Double,System.Double,System.Double)">
            <summary>
            Not implemented fo stub class.
            </summary>
            <param name="time"></param>
            <param name="space"></param>
            <param name="edgeValue"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.StubNurbsGenerator.EvaluateNurbsCurveIntegral(System.Double,System.Double)">
            <summary>
            Not implemented for stub class.
            </summary>
            <param name="space"></param>
            <param name="exponentialTerm"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.StubNurbsGenerator.EvaluateNurbsCurveFourierTransform(System.Double,System.Double,System.Double)">
            <summary>
            Not implemented for stub class.
            </summary>
            <param name="space"></param>
            <param name="expTerm"></param>
            <param name="ft"></param>
            <returns></returns>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.StubNurbsGenerator.NativeTimes">
            <summary>
            native times
            </summary>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver">
            <summary>
            This implements Kienle's two-layer SDA solutions described in:
            1) Kienle et al., "Noninvasive determination of the optical properties of two-layered
            turbid media", Applied Optics 37(4), 1998.
            2) Kienle et al., "In vivo determination of the optical properties of muscle with time-
            resolved reflectance using a layered model, Phys. Med. Biol. 44, 1999 (in particular, the
            appendix)
            Notes:
            1) this solution assumes that the embedded source is within top layer.
            2) zp = location of embedded isotropic source is determined using layer 1 opt. props.
            3) zb = extrapolated boundary is determined using layer 1 opt. props.
            This currently inherits ForwardSolverBase.  In order to provide fluence of ft type solutions,
            this would need to inherit DiffusionForwardSolverBase however the methods there assume homogeneous
            tissue so not sure best way to implement ft type solutions.
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.#ctor">
            <summary>
            Returns an instance of TwoLayerSDAForwardSolver
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.ROfRho(Vts.IOpticalPropertyRegion[],System.Double)">
            <summary>
            reflectance as a function of s-d separation
            </summary>
            <param name="regions">optical properties</param>
            <param name="rho">s-d separation</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.ROfRhoAndTime(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            reflectance as a function of s-d separation and time
            </summary>
            <param name="regions">optical properties</param>
            <param name="rho">s-d separation</param>
            <param name="time">time</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.ROfRhoAndTime(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates spatially- and temporally- resolved reflectance at sets of tissue regions, rhos and times
            </summary>
            <param name="setsOfRegions">multiple sets of tissue regions</param>
            <param name="rhos">rhos</param>
            <param name="times">times</param>
            <returns>reflectance at specified optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.ROfRhoAndFt(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            reflectance versus rho and temporal-frequency
            </summary>
            <param name="regions">optical properties of two layers</param>
            <param name="rho">source-detector separation</param>
            <param name="ft">temporal-frequency of interest</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.ROfFx(Vts.IOpticalPropertyRegion[],System.Double)">
            <summary>
            reflectance versus spatial-frequency
            </summary>
            <param name="regions">optical properties of two layers</param>
            <param name="fx">spatial frequency of interest</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.ROfFxAndTime(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            reflectance versus spatial-frequency and time
            </summary>
            <param name="regions">optical properties of two layers</param>
            <param name="fx">spatial-frequency of interest</param>
            <param name="time">time point of interest</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.ROfFxAndTime(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            Evaluates spatial-frequency and temporally- resolved reflectance at sets of tissue regions, fs and times
            </summary>
            <param name="setsOfRegions">multiple sets of tissue regions</param>
            <param name="fxs">spatial frequencies</param>
            <param name="times">times</param>
            <returns>reflectance at specified optical properties, rhos and times</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.ROfFxAndFt(Vts.IOpticalPropertyRegion[],System.Double,System.Double)">
            <summary>
            reflectance versus spatial-frequency and temporal-frequency
            </summary>
            <param name="regions">optical properties of two layers</param>
            <param name="fx">spatial-frequency of interest</param>
            <param name="ft">temporal-frequency of interest</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.FluenceOfRhoAndZ(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence versus rho and depth z
            </summary>
            <param name="regions">optical properties of two layers</param>
            <param name="rhos">source-detector separations of interest</param>
            <param name="zs">depths of interest</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.StationaryReflectance(System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters[],System.Double[],System.Double,System.Double)">
            <summary>
            Evaluate the stationary radially resolved reflectance with the point source-image configuration
            </summary>
            <param name="rho">radial location</param>
            <param name="dp">DiffusionParameters object for each tissue region</param>
            <param name="layerThicknesses">layer thickness</param>
            <param name="fr1">Fresnel moment 1, R1</param>
            <param name="fr2">Fresnel moment 2, R2</param>
            <returns>reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.SpatialFrequencyReflectance(System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters[],System.Double[],System.Double,System.Double)">
            <summary>
            reflectance as a function of s-d separation 
            </summary>
            <param name="s">s-d separation</param>
            <param name="dp">diffusion parameters</param>
            <param name="layerThicknesses">layer thickness</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.TemporalFrequencyReflectance(System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters[],System.Double[],System.Double,System.Double)">
            <summary>
            temporal-frequency reflectance
            </summary>
            <param name="rho">s-d separation</param>
            <param name="temporalFrequency">temporal frequency</param>
            <param name="dp">diffusion parameters</param>
            <param name="layerThicknesses">layer thicknesses</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.SpatialAndTemporalFrequencyReflectance(System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters[],System.Double[],System.Double,System.Double)">
            <summary>
            reflectance as a function of s-d separation and temporal-frequency
            </summary>
            <param name="s">s-d separation</param>
            <param name="temporalFrequency">temporal frequency</param>
            <param name="dp">diffusion parameters</param>
            <param name="layerThicknesses">layer thickness</param>
            <param name="fr1"></param>
            <param name="fr2"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.StationaryFluence(System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters[],System.Double[])">
            <summary>
            Evaluate the stationary radially resolved fluence with the point source-image
            configuration
            </summary>
            <param name="rho">radial location</param>
            <param name="z">depth location</param>
            <param name="dp">DiffusionParameters for layer 1 and 2</param>
            <param name="layerThicknesses">in this class, layer thickness</param>
            <returns>fluence</returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.StationaryFlux(System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters[],System.Double[])">
            <summary>
            Evaluate the stationary radially resolved z-flux with the point source-image
            configuration
            </summary>
            <param name="rho">radial location</param>
            <param name="z">depth location</param>
            <param name="dp">DiffusionParameters for layer 1 and 2</param>
            <param name="layerThicknesses">thickness of top layer, array but only need first element</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.TemporalFrequencyFluence(System.Double,System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters[],System.Double[])">
            <summary>
            temporal-frequency fluence
            </summary>
            <param name="rho">s-d separation</param>
            <param name="z">depth</param>
            <param name="temporalFrequency">temporal frequency</param>
            <param name="dp">diffusion parameters</param>
            <param name="layerThicknesses">layer thickness</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.FluenceOfRhoAndZAndFt(System.Collections.Generic.IEnumerable{Vts.IOpticalPropertyRegion[]},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double},System.Collections.Generic.IEnumerable{System.Double})">
            <summary>
            fluence as function of s-d separation, depth and temporal-frequency
            </summary>
            <param name="regions">optical properties</param>
            <param name="rhos">s-d separations</param>
            <param name="zs">depths</param>
            <param name="fts">temporal-frequencies</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.TwoLayerSDAForwardSolver.TemporalFrequencyZFlux(System.Double,System.Double,System.Double,Vts.Modeling.ForwardSolvers.DiffusionParameters[],System.Double[])">
            <summary>
            used to determine temporal frequency reflectance
            </summary>
            <param name="rho"></param>
            <param name="z"></param>
            <param name="temporalFrequency"></param>
            <param name="dp"></param>
            <param name="layerThicknesses"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.Modeling.ForwardSolvers.VectorizedForwardSolverFuncs">
            <summary>
            vectorized forward solver functions
            </summary>
        </member>
        <member name="M:Vts.Modeling.ForwardSolvers.VectorizedForwardSolverFuncs.#ctor(Vts.IForwardSolver)">
            <summary>
            constructor
            </summary>
            <param name="fs"></param>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.VectorizedForwardSolverFuncs.ROfRho">
            <summary>
            reflectance as a function of s-d separation
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.VectorizedForwardSolverFuncs.ROfRhoAndT">
            <summary>
            reflectance as a function of s-d separation and time
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.VectorizedForwardSolverFuncs.ROfRhoAndFt">
            <summary>
            reflectance as a function of s-d separation and temporal-frequency
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.VectorizedForwardSolverFuncs.ROfFx">
            <summary>
            reflectance as a function of spatial-frequency
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.VectorizedForwardSolverFuncs.ROfFxAndT">
            <summary>
            reflectance as a function of spatial-frequency and time
            </summary>
        </member>
        <member name="P:Vts.Modeling.ForwardSolvers.VectorizedForwardSolverFuncs.ROfFxAndFt">
            <summary>
            reflectance as a function of spatial-frequency and temporal-frequency
            </summary>
        </member>
        <member name="T:Vts.Modeling.LinearDiscreteFourierTransform">
            <summary>
            Class used to compute the discrete Fourier transform of a reflectance curve.
            </summary>
        </member>
        <member name="M:Vts.Modeling.LinearDiscreteFourierTransform.GetTime(System.Double,System.Double,System.Double@)">
            <summary>
            method to get times
            </summary>
            <param name="mua">absorption coefficient</param>
            <param name="musp">reduced scattering coefficient</param>
            <param name="dt">delta time</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.LinearDiscreteFourierTransform.GetFourierTransform(System.Double[],System.Double[],System.Double,System.Double)">
            <summary>
            Calculate the Fourier Transform using a discrete Riemann middle sum with uniform dt
            </summary>
            <param name="time">vector of discrete time values</param>
            <param name="ROfTime">vector of discrete R(time) values</param>
            <param name="dt">delta time</param>
            <param name="ft">the temporal frequency at which to evaluate</param>
            <returns>ROfFt</returns>
        </member>
        <member name="M:Vts.Modeling.LinearDiscreteFourierTransform.GetFourierTransform(System.Double[],System.Double[],System.Double[],System.Double)">
            <summary>
            Calculate the Fourier Transform using a discrete Riemann middle sum with non uniform dt
            </summary>
            <param name="time">vector of discrete time values</param>
            <param name="ROfTime">vector of discrete R(time) values</param>
            <param name="dt">delta time</param>
            <param name="ft">the temporal frequency at which to evaluate</param>
            <returns>ROfFt</returns>
        </member>
        <member name="M:Vts.Modeling.LinearDiscreteFourierTransform.GetInverseFourierTransform(System.Double[],System.Numerics.Complex[],System.Double,System.Double)">
            <summary>
            Calculate the inverse Fourier Transform using a discrete Riemann middle sum with uniform frequencies
            </summary>
            <param name="frequencies">vector of discrete frequency values</param>
            <param name="ROfFt">vector of discrete R(ft) values</param>
            <param name="df">delta frequency</param>
            <param name="t">the time at which to evaluate</param>
            <returns>ROfTime</returns>
        </member>
        <member name="T:Vts.Modeling.LinearDiscreteHankelTransform">
            <summary>
            Transforms linearly discrete data via a middle Riemann sum. This method is not mathematically sound, 
            but is a low order approximation.
            </summary>
        </member>
        <member name="M:Vts.Modeling.LinearDiscreteHankelTransform.GetRho(System.Double,System.Double,System.Double@)">
            <summary>
            method to get rho values
            </summary>
            <param name="mua">absorption coefficient</param>
            <param name="musp">reduced scattering coefficient</param>
            <param name="drho">delta rho</param>
            <returns></returns>
        </member>
        <member name="M:Vts.Modeling.LinearDiscreteHankelTransform.GetHankelTransform(System.Double[],System.Double[],System.Double,System.Double)">
            <summary>
            Calculate the Hankel Transform using a discrete Riemann middle sum
            </summary>
            <param name="rho">vector of discrete rho values</param>
            <param name="ROfRho">vector of discrete R(rho) values</param>
            <param name="drho">delta rho</param>
            <param name="fx">the spatial frequency at which to evaluate</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Modeling.Optimizers.OptimizationData">
            <summary>
            Data input to the optimization method Solve.
            ForwardFunc:delegate function that evaluates the objective function given a parameter optimization array and (optional) constant variables
            Y: measured data
            Ey: standard deviation of Y
            </summary>
        </member>
        <member name="P:Vts.Modeling.Optimizers.OptimizationData.ForwardFunc">
            <summary>
            delegate function that evaluates the objective function given a parameter optimization array and (optional) constant variables
            </summary>
        </member>
        <member name="P:Vts.Modeling.Optimizers.OptimizationData.ForwardVariables">
            <summary>
            forward variables
            </summary>
        </member>
        <member name="P:Vts.Modeling.Optimizers.OptimizationData.Y">
            <summary>
            measured data
            </summary>
        </member>
        <member name="P:Vts.Modeling.Optimizers.OptimizationData.Ey">
            <summary>
            standard deviation of Y
            </summary>
        </member>
        <member name="T:Vts.Modeling.Optimizers.MPFitLevenbergMarquardtOptimizer">
            <summary>
            MPFit Levenberg Marquardt least-squares minimization.
            </summary>
        </member>
        <member name="M:Vts.Modeling.Optimizers.MPFitLevenbergMarquardtOptimizer.Solve(System.Double[],System.Boolean[],System.Double[],System.Double[],System.Func{System.Double[],System.Object[],System.Double[]},System.Object[])">
            <summary>
            Optimization method.  This calls MPFit Levenberg Marquardt solver.
            For examples of usage, see TestMPFit.cs:
            https://csmpfit.codeplex.com/SourceControl/latest#src/MPFitLib.Test/TestMPFit.cs
            For an example of a call with the objective function:
            https://csmpfit.codeplex.com/SourceControl/latest#src/MPFitLib.Test/ForwardModels.cs
            </summary>
            <param name="a">optimization parameter initial guess</param>
            <param name="ia">accompanying array to <paramref name="a"/> that specifies which parameters to fit (held constant otherwise)</param>
            <param name="y">"measured" values</param>
            <param name="ey">standard deviation values of <paramref name="y"/></param>
            <param name="forwardFunc">delegate function that evaluates the objective function given a parameter optimization array and (optional) constant variables</param>
            <param name="forwardVariables"></param>
        </member>
        <member name="M:Vts.Modeling.Optimizers.MPFitLevenbergMarquardtOptimizer.SolveWithConstraints(System.Double[],System.Boolean[],System.Double[],System.Double[],System.Double[],System.Double[],System.Func{System.Double[],System.Object[],System.Double[]},System.Object[])">
            <summary>
            Optimization method.  This calls MPFit Levenberg Marquardt solver with constraints.
            </summary>
            <param name="a">optimization parameter initial guess</param>
            <param name="ia">accompanying array to <paramref name="a"/> that specifies which parameters to fit (held constant otherwise)</param>
            <param name="lowerBounds">accompanying array that specifies lower bounds for parameters</param>
            <param name="upperBounds">accompanying array that specifies upper bounds</param>
            <param name="y">"measured" values</param>
            <param name="ey">standard deviation values of <paramref name="y"/></param>
            <param name="forwardFunc">delegate function that evaluates the objective function given a parameter optimization array and (optional) constant variables</param>
            <param name="forwardVariables"></param>
        </member>
        <member name="M:Vts.Modeling.Optimizers.MPFitLevenbergMarquardtOptimizer.MPFitFunc(System.Double[],System.Double[],System.Collections.Generic.IList{System.Double}[],System.Object)">
            <summary>
            Standard function prototype that MPFit knows how to call. Use <paramref name="vars"/> to store information reqired to evaluate any objective function
            </summary>
            <param name="parameters">array of fit parameters</param>
            <param name="dy">array of residuals to be returned</param>
            <param name="dvec">not used</param>
            <param name="vars">private data</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Modeling.CalculatorToolbox">
            <summary>
            Toolbox containing general method for the forward models. Most of these are for diffusion based 
            calculations.
            </summary>
        </member>
        <member name="M:Vts.Modeling.CalculatorToolbox.GetCubicAParameter(System.Double)">
            <summary>
            Implementation of the cubic polynomial via Scott Prahl thesis 1988, Appendix A2.9
            </summary>
            <param name="n">Refractive Index</param>
            <returns>Returns the boundary parameter A</returns>
        </member>
        <member name="M:Vts.Modeling.CalculatorToolbox.GetRadius(System.Double,System.Double)">
            <summary>
            Get the radial location from the system origin to the position rho and z
            </summary>
            <param name="rho">radial location</param>
            <param name="z">depth location</param>
            <returns>distance to (rho,z) coordinate from origin = (0,0)</returns>
        </member>
        <member name="M:Vts.Modeling.CalculatorToolbox.GetRadius(System.Double,System.Double,System.Double)">
            <summary>
            Overload of the (rho,z) dependent calculation for calculation of the radial distance from
            the position (x,y,z) to the origin (0,0,0)
            </summary>
            <param name="x">x location</param>
            <param name="y">y location</param>
            <param name="z">z location (depth)</param>
            <returns>distance from coordinate (x,y,z) from the origin (0,0,0)</returns>
        </member>
        <member name="M:Vts.Modeling.CalculatorToolbox.GetCubicFresnelReflectionMomentOfOrder1(System.Double)">
            <summary>
            Fresnel first reflection moment, via S. Prahl thesis 1988
            Polynomial expression, stated accurate for R1 and R2 better than 0.005.
            These polynomials should probably be replaced by the integral expresion! TO be DONE
            </summary>
            <param name="n">Refractive index</param>
            <returns>1st moment of the Fresnel reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.CalculatorToolbox.GetCubicFresnelReflectionMomentOfOrder2(System.Double)">
            <summary>
            Fresnel second reflection moment, via S. Prahl thesis 1988.
            </summary>
            <param name="n">Refractive index</param>
            <returns>2nd moment of the Fresnel reflectance</returns>
        </member>
        <member name="M:Vts.Modeling.CalculatorToolbox.GetFresnelReflectionMomentOfOrderM(System.Int32,System.Double,System.Double)">
            <summary>
            Fresnel Reflection moment of abritrary integer order M via Gauss-Kronrod 
            numerical integration.
            </summary>
            <param name="M">Moment Order</param>
            <param name="RIinc">Incident Refractive Index</param>
            <param name="RItrans">Transmitted Refractive Index</param>
            <returns>Mth Fresnel Reflection Moment</returns>
        </member>
        <member name="M:Vts.Modeling.CalculatorToolbox.EvaluateDistributedExponentialLineSourceIntegral(System.Func{System.Double,System.Double},System.Double)">
            <summary>
            Allows distribution of any function exponentially in a linear direction
            </summary>
            <param name="func">function to be distributed, input is directional variable</param>
            <param name="muDecay">decay constant</param>
            <returns></returns>
        </member>
        <member name="T:Vts.Modeling.CubicAparameterCalculator">
            <summary>
            cubic polynomial calculator
            </summary>
        </member>
        <member name="M:Vts.Modeling.CubicAparameterCalculator.GetA(System.Double)">
            <summary>
            Implementation of the cubic polynomial via Scott Prahl thesis 1988, Appendix A2.9
            </summary>
            <param name="n">Refractive Index</param>
            <returns>Returns the boundary parameter A</returns>
        </member>
        <member name="T:Vts.Modeling.HankelTransform">
            <summary>
            Evaluate the Hankel transform using a digital fitler method for the quadrature points.
            Necessary to have a continuous function for transformation.
            </summary>
        </member>
        <member name="F:Vts.Modeling.HankelTransform.dataLength">
            <summary>
            Zero order Hankel Transform of Anayltic expression by digital filtering. 
            Based on a Matlab code by Prof. Brian Borcher which is based on a Fortran program by Walt Anderson 
            which was published as
            Anderson, W.L., 1979, Computer Program Numerical Integration of Related Hankel
            Transforms of Orders 0 and 1 by Adaptive Digital Filtering.
            Geophysic, 44(7):1287-1305.
            Actual weights used in this code are from a later updated version of the code
            </summary>
            <returns>IEnumerable corresponding to points being transformed</returns>
        </member>
        <member name="M:Vts.Modeling.HankelTransform.DigitalFilterOfOrderZero(System.Double,System.Func{System.Double,System.Double})">
            <summary>
            digital filter of order 0
            </summary>
            <param name="varInt"></param>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.Modeling.ReffCalculator">
            <summary>
            reff calculator
            </summary>
        </member>
        <member name="M:Vts.Modeling.ReffCalculator.GetReff(System.Double)">
            <summary>
            method to get reff
            </summary>
            <param name="n">refractive index</param>
            <returns></returns>
        </member>
        <member name="T:Vts.SpectralMapping.ChromophoreAbsorber">
            <summary>
            Class to represent a chromophore absorber
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.ChromophoreAbsorber.#ctor(System.String,System.Double,Vts.ChromophoreCoefficientType)">
            <summary>
            Creates a chromophore with a particular value. Name is used to reference the spectral database.
            </summary>
            <param name="name">Name of the chromophore</param>
            <param name="concentration">Concentration</param>
            <param name="chromophoreCoefficientType">Chromophore coefficient type defined by the Enum <see cref="T:Vts.ChromophoreCoefficientType">ChromophoreCoefficientType</see></param>
        </member>
        <member name="M:Vts.SpectralMapping.ChromophoreAbsorber.#ctor(Vts.ChromophoreType,System.Double)">
            <summary>
            Overload for creating chromophore with simple table lookup. Only works for "built-in" chromophore types
            </summary>
            <param name="chromophoreType">Chromophore type as defined by the Enum <see cref="T:Vts.ChromophoreType">ChromophoreType</see></param>
            <param name="concentration">Concentration</param>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreAbsorber.ChromophoreCoefficientType">
            <summary>
            Chromophore coefficient type defined by the Enum <see cref="T:Vts.ChromophoreCoefficientType">ChromophoreCoefficientType</see>
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreAbsorber.Name">
            <summary>
            Name of the chromophore
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreAbsorber.Concentration">
            <summary>
            Concentration
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreAbsorber.ConcentrationUnits">
            <summary>
            Concentration units based on the chromophore coefficient type
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.ChromophoreAbsorber.ToString">
            <summary>
            Returns the name of the chromophore
            </summary>
            <returns>Name of the chromophore</returns>
        </member>
        <member name="M:Vts.SpectralMapping.ChromophoreAbsorber.GetMua(System.Double)">
            <summary>
            Returns Mua (absorption coefficient) for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The absorption coefficient Mua</returns>
        </member>
        <member name="T:Vts.SpectralMapping.ChromophoreSpectrumExtensions">
            <summary>
            chromophore spectrum extension methods
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.ChromophoreSpectrumExtensions.ToDictionary(System.Collections.Generic.IEnumerable{Vts.SpectralMapping.ChromophoreSpectrum})">
            <summary>
            method to put spectrum to dictionary
            </summary>
            <param name="spectra">spectra to put into dictionary</param>
            <returns>dictionary of chromophore spetrum</returns>
        </member>
        <member name="T:Vts.SpectralMapping.ChromophoreSpectrumDictionary">
            <summary>
            A class representing a dictionary of the chromophore spectrum data
            Added a collection data contract to define the node names and namespace 
            when serializing and deserializing the class.
            </summary>
        </member>
        <member name="T:Vts.SpectralMapping.ChromophoreSpectrum">
            <summary>
            A class representing the chromophore spectrum data
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.ChromophoreSpectrum.#ctor(System.String,Vts.ChromophoreCoefficientType,Vts.AbsorptionCoefficientUnit,Vts.MolarUnit,Vts.WavelengthUnit)">
            <summary>
            Constructor to create the chromophore spectrum starting with empty lists
            </summary>
            <param name="name">The name of the chromophore absorber</param>
            <param name="coeffType">The chromophore coefficient type</param>
            <param name="absUnits">The absorption coefficient units</param>
            <param name="molarUnit">The molar units</param>
            <param name="wavelengthUnit">The wavelength units</param>
        </member>
        <member name="M:Vts.SpectralMapping.ChromophoreSpectrum.#ctor(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double},System.String,Vts.ChromophoreCoefficientType,Vts.AbsorptionCoefficientUnit,Vts.MolarUnit,Vts.WavelengthUnit)">
            <summary>
            Constructor to create the chromophore spectrum
            </summary>
            <param name="wavelengths">A list of wavelengths</param>
            <param name="spectrum">A list of spectral values</param>
            <param name="name">The name of the chromophore absorber</param>
            <param name="coeffType">The chromophore coefficient type</param>
            <param name="absUnits">The absorption coefficient units</param>
            <param name="molarUnit">The molar units</param>
            <param name="wavelengthUnit">The wavelength units</param>
        </member>
        <member name="M:Vts.SpectralMapping.ChromophoreSpectrum.#ctor">
            <summary>
            Default constructor to create the chromophore spectrum
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreSpectrum.Spectrum">
            <summary>
            A list of doubles representing the spectral values
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreSpectrum.Wavelengths">
            <summary>
            A list of doubles representing the wavelengths
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreSpectrum.ChromophoreCoefficientType">
            <summary>
            The chromophore coefficient type
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreSpectrum.AbsorptionCoefficientUnit">
            <summary>
            The absorption coefficient units
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreSpectrum.MolarUnit">
            <summary>
            The molar units
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreSpectrum.WavelengthUnit">
            <summary>
            The wavelength units
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ChromophoreSpectrum.Name">
            <summary>
            Name of the chromophore absorber
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.ChromophoreSpectrum.GetSpectralValue(System.Double)">
            <summary>
            Linearly interpolates known spectra to attain spectral value
            </summary>
            <param name="wavelength">the wavelength at which to attain the spectral value</param>
            <returns>the spectral value as a double</returns>
        </member>
        <member name="T:Vts.SpectralMapping.IAbsorber">
            <summary>
            Interface contract for all absorber implementations
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.IAbsorber.GetMua(System.Double)">
            <summary>
            Returns Mua (absorption coefficient) for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The absorption coefficient Mua</returns>
        </member>
        <member name="T:Vts.SpectralMapping.IChromophoreAbsorber">
            <summary>
            A general interface for a chromophore absorber
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.IChromophoreAbsorber.Name">
            <summary>
            The name of the chromophore absorber
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.IChromophoreAbsorber.Concentration">
            <summary>
            The concentration of the chromophore absorber
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.IChromophoreAbsorber.ChromophoreCoefficientType">
            <summary>
            The chromophore coefficient type
            </summary>
        </member>
        <member name="T:Vts.SpectralMapping.IntralipidScatterer">
            <summary>
            An intralipid scatterer, based on Mie theory fit to experimental data by van Staveren et al. 
            For more info, visit http://omlc.ogi.edu/spectra/intralipid/index.html
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.IntralipidScatterer.#ctor(System.Double)">
            <summary>
            Creates an intralipid scatterer with the given volume fraction
            </summary>
            <param name="volumeFraction">Volume fraction</param>
        </member>
        <member name="M:Vts.SpectralMapping.IntralipidScatterer.#ctor">
            <summary>
            Creates an intralipid scatterer with a volume fraction of 0.01
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.IntralipidScatterer.ScattererType">
            <summary>
            Scattering type, set to intralipid
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.IntralipidScatterer.VolumeFraction">
            <summary>
            The volume fraction
            Note: force value to be between [0, 1]
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.IntralipidScatterer.GetG(System.Double)">
            <summary>
            Returns the anisotropy coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The anisotropy coeffient g</returns>
        </member>
        <member name="M:Vts.SpectralMapping.IntralipidScatterer.GetMus(System.Double)">
            <summary>
            Returns the scattering coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The scattering coefficient Mus</returns>
        </member>
        <member name="M:Vts.SpectralMapping.IntralipidScatterer.GetMusp(System.Double)">
            <summary>
            Returns the reduced scattering coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The reduced scattering coefficient Mus'</returns>
        </member>
        <member name="T:Vts.SpectralMapping.IScatterer">
            <summary>
            Interface contract for all Scatterer implementations
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.IScatterer.ScattererType">
            <summary>
            The scatterer type as defined by the Enum <see cref="T:Vts.ScatteringType">ScatteringType</see>
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.IScatterer.GetG(System.Double)">
            <summary>
            Returns the anisotropy coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The anisotropy coeffient g</returns>
        </member>
        <member name="M:Vts.SpectralMapping.IScatterer.GetMus(System.Double)">
            <summary>
            Returns the scattering coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The scattering coefficient Mus</returns>
        </member>
        <member name="M:Vts.SpectralMapping.IScatterer.GetMusp(System.Double)">
            <summary>
            Returns the reduced scattering coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The reduced scattering coefficient Mus'</returns>
        </member>
        <member name="T:Vts.SpectralMapping.ISpectrum">
            <summary>
            General interface for any spectrum (ie. ChromophoreSpectrum or ScatteringSpectrum)
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ISpectrum.Name">
            <summary>
            Name of the spectrum
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.ISpectrum.GetSpectralValue(System.Double)">
            <summary>
            Returns the spectral value for a specific wavelength
            </summary>
            <param name="wavelength">The wavelength value</param>
            <returns>A double representing the spectral value</returns>
        </member>
        <member name="P:Vts.SpectralMapping.ISpectrum.ChromophoreCoefficientType">
            <summary>
            The chromophore coefficient type
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ISpectrum.AbsorptionCoefficientUnit">
            <summary>
            The absorption coefficient unit
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ISpectrum.MolarUnit">
            <summary>
            The molar unit
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.ISpectrum.WavelengthUnit">
            <summary>
            The wavelength unit
            </summary>
        </member>
        <member name="T:Vts.SpectralMapping.MieScatterer">
            <summary>
            This class implements the formulation by Craig F. Bohren, Donald R. Huffman
            "Absorption and Scattering of Light by Small Particles", Wiley Sci., 1983
            Additional information can be found at Oregon Medical Center web-page:
            http://omlc.ogi.edu/classroom/ece532/class3/mie.html
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.MieScatterer.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a MieScatterer with the specified values for particle radius, particle refractive index and medium refractive index
            </summary>
            <param name="particleRadius">Particle radius</param>
            <param name="particleRefractiveIndex">Particle refractive index</param>
            <param name="mediumRefractiveIndex">Medium refractive index</param>
            <param name="volumeFraction">volume fraction of scatterers</param>
        </member>
        <member name="M:Vts.SpectralMapping.MieScatterer.#ctor(Vts.MieScattererType)">
            <summary>
            Creates a MieScatterer with the specified Mie scatterer type
            </summary>
            <param name="scattererType">The Mie scatterer type</param>
        </member>
        <member name="M:Vts.SpectralMapping.MieScatterer.#ctor">
            <summary>
            Creates a MieScatterer with a MieScattererType of PolystyreneSphereSuspension
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.MieScatterer.ScattererType">
            <summary>
            Scatterer type, set to Mie
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.MieScatterer.ParticleRadius">
            <summary>
            Partice radius
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.MieScatterer.ParticleRefractiveIndexMismatch">
            <summary>
            Particle refractive index mismatch
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.MieScatterer.MediumRefractiveIndexMismatch">
            <summary>
            Medium refractive index mismatch
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.MieScatterer.VolumeFraction">
            <summary>
            Volume fraction
            Note: force value to be between [0, 1]
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.MieScatterer.GetG(System.Double)">
            <summary>
            Returns the anisotropy coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The anisotropy coeffient g</returns>
        </member>
        <member name="M:Vts.SpectralMapping.MieScatterer.GetMus(System.Double)">
            <summary>
            Returns the scattering coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The scattering coefficient Mus</returns>
        </member>
        <member name="M:Vts.SpectralMapping.MieScatterer.GetMusp(System.Double)">
            <summary>
            Returns the reduced scattering coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The reduced scattering coefficient Mus'</returns>
        </member>
        <member name="T:Vts.SpectralMapping.PowerLawScatterer">
            <summary>
            Returns scattering values based on Steve Jacques' Skin Optics Summary:
            http://omlc.ogi.edu/news/jan98/skinoptics.html
            This returned reduced scattering follows the approximate formula:
            mus' = A1*lamda(-b1) + A2*lambda(-b2)
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.PowerLawScatterer.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Constructs a power law scatterer; i.e. mus' = a*lamda^-b + c*lambda^-d
            </summary>
            <param name="a">The first prefactor</param>
            <param name="b">The first exponent</param>
            <param name="c">The second prefactor</param>
            <param name="d">The second exponent</param>
        </member>
        <member name="M:Vts.SpectralMapping.PowerLawScatterer.#ctor(System.Double,System.Double)">
            <summary>
            Creates a power law scatterer; i.e. mus' = a*lambda^-b
            </summary>
            <param name="a">The first prefactor</param>
            <param name="b">The first exponent</param>
        </member>
        <member name="M:Vts.SpectralMapping.PowerLawScatterer.#ctor(Vts.TissueType)">
            <summary>
            Creates a power law scatterer using the specified tissue type
            </summary>
            <param name="tissueType">The tissue type as defined by the Enum <see cref="T:Vts.TissueType">TissueType</see></param>
        </member>
        <member name="M:Vts.SpectralMapping.PowerLawScatterer.#ctor">
            <summary>
            Creates a power law scatterer with a tissue type of Custom
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.PowerLawScatterer.SetTissueType(Vts.TissueType)">
            <summary>
            Sets the values for the first prefactor, the first exponent, the second prefactor and the second exponent for the given tissue type
            Skin: 1.2, 1.42, 0.0, 0.0
            Breast (pre-menopause): 0.67, 0.95, 0.0, 0.0
            Breast (post-menopause): 0.72, 0.58, 0.0, 0.0
            Brain (white matter): 3.56, 0.84, 0.0, 0.0
            Brain (grey matter): 0.56, 1.36, 0.0, 0.0
            Liver: 0.84, 0.55, 0.0, 0.0
            Custom: 1.0, 0.1, 0.0, 0.0
            </summary>
            <param name="tissueType">Tissue type</param>
        </member>
        <member name="P:Vts.SpectralMapping.PowerLawScatterer.ScattererType">
            <summary>
            Scattering type, set to power law
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.PowerLawScatterer.A">
            <summary>
            The first prefactor
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.PowerLawScatterer.B">
            <summary>
            The first exponent
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.PowerLawScatterer.C">
            <summary>
            The second prefactor
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.PowerLawScatterer.D">
            <summary>
            The second exponent
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.PowerLawScatterer.GetMusp(System.Double)">
            <summary>
            Returns mus' based on Steve Jacques' Skin Optics Summary:
            http://omlc.ogi.edu/news/jan98/skinoptics.html
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The reduced scattering coefficient Mus'</returns>
        </member>
        <member name="M:Vts.SpectralMapping.PowerLawScatterer.GetG(System.Double)">
            <summary>
            Returns a fixed g (scattering anisotropy) of 0.8
            </summary>
            <param name="wavelength">The wavelength, in nanometers</param>
            <returns>The scattering anisotropy. This is the cosine of the average scattering angle.</returns>
        </member>
        <member name="M:Vts.SpectralMapping.PowerLawScatterer.GetMus(System.Double)">
            <summary>
            Returns mus based on mus' and g 
            </summary>
            <param name="wavelength">The wavelength, in nanometers</param>
            <returns>The scattering coefficient, mus</returns>
        </member>
        <member name="T:Vts.SpectralMapping.SpectralConverter">
            <summary>
            Class to convert imported spectral data to uniform values
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralConverter.ConvertWavelength(System.Double,Vts.WavelengthUnit)">
            <summary>
            Method to convert wavelength values
            </summary>
            <param name="WavelengthValue">The wavelength value to convert</param>
            <param name="Unit">An enum representing the units of the value to convert</param>
            <returns>The converted value as a double</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralConverter.ConvertCoefficient(System.Double,Vts.AbsorptionCoefficientUnit,Vts.MolarUnit)">
            <summary>
            Method to convert coefficient values
            </summary>
            <param name="CoefficientValue">The coefficient value to convert</param>
            <param name="Unit">An enum representing the units of the value to convert</param>
            <param name="MolarUnit">An enum to represent a molar based coefficient</param>
            <returns>The converted value as a double</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralConverter.ConvertCoefficient(System.Double,Vts.AbsorptionCoefficientUnit)">
            <summary>
            Method to convert coefficient values with a default MolarUnit of MicroMolar
            </summary>
            <param name="CoefficientValue">The coefficient value to convert</param>
            <param name="Unit">An enum representing the units of the value to convert</param>
            <returns>The converted value as a double</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralConverter.getWavelengthUnit(System.String)">
            <summary>
            Passes a text string of wavelength unit and returns the relevant enum
            </summary>
            <param name="wavelengthUnit">string representing wavelength unit</param>
            <returns>enum of type WavelengthUnit</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralConverter.getWavelengthUnit(Vts.WavelengthUnit)">
            <summary>
            passes an enum of WavelengthUnit and returns a string of wavelength unit
            </summary>
            <param name="wavelengthUnit">enum of type WavelengthUnit</param>
            <returns>string representing wavelength unit</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralConverter.getAbsorptionCoefficientUnit(System.String)">
            <summary>
            Passes a text string of absorption coefficient unit and returns the relevant enum
            </summary>
            <param name="absorptionCoefficientUnit">string representing absorption coefficient unit</param>
            <returns>enum of type AbsorptionCoefficientUnit</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralConverter.getMolarUnit(System.String)">
            <summary>
            Passes a text string of molar unit and returns the relevant enum
            </summary>
            <param name="molarUnit">string representing molar unit</param>
            <returns>enum of type MolarUnit</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralConverter.getSpectralUnit(Vts.MolarUnit,Vts.AbsorptionCoefficientUnit)">
            <summary>
            Passes the molar unit enum and the absorption coefficient unit enum and returns it as a string
            </summary>
            <param name="molarUnit">The molar unit enum</param>
            <param name="absorptionCoefficientUnit">an absorption coefficient enum</param>
            <returns>A string representing the molar units</returns>
        </member>
        <member name="T:Vts.SpectralMapping.SpectralDatabase">
            <summary>
            This static class provides simple, application-wide access to the loaded spectra. 
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.SpectralDatabase.InternalDictionary">
            <summary>
            Private property to store the loaded database
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralDatabase.GetSpectrumValue(System.String,System.Double)">
            <summary>
            Method to retrieve a spectral value keyed by it's name in the database
            </summary>
            <param name="name">Name of the spectra</param>
            <param name="wavelength">The wavelength at which to get the value</param>
            <returns>Value at the given wavelength</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralDatabase.GetDefaultDatabaseFromFileInResources">
            <summary>
            Returns a dictionary of Chromophore spectra from the file SpectralDictionary.txt in resources
            </summary>
            <returns>Dictionary of Chromophore spectra</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralDatabase.GetDatabaseFromFile(System.String)">
            <summary>
            Returns a dictionary of Chromophore spectra from the specified file
            </summary>
            <returns>Dictionary of Chromophore spectra</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralDatabase.SaveDatabaseToFile(Vts.SpectralMapping.ChromophoreSpectrumDictionary,System.String)">
            <summary>
            Saves a given dictionary of Chromophore spectra to the specified file
            </summary>
            <param name="dictionary">Name of the chromophore spectrum dictionary</param>
            <param name="filename">Name of the file</param>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralDatabase.AppendDatabaseFromFile(Vts.SpectralMapping.ChromophoreSpectrumDictionary,System.IO.Stream)">
            <summary>
            Appends a new chromophore spectral dictionary created from a tab-delimited stream onto an existing dictionary of chromophore spectra
            </summary>
            <param name="existingDictionary">The existing dictionary to which to append</param>
            <param name="fileStream">The file stream</param>
            <returns>The new dictionary of chromophore spectra</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralDatabase.GetSpectraFromFile(System.IO.Stream,System.Boolean)">
            <summary>
            Creates a dictionary of chromophore spectra from a file stream of tab-delimited data, converts the data to work in the VTS
            The header data is written as a comment line starting with %
            Tab delimited data is in the format: Wavelength  1st Column  2nd Column  3rd Column  ...
            </summary>
            <param name="fileStream">The file stream of spectral data</param>
            <param name="convert">Boolean which is true if the data should be converted</param>
            <returns>The dictionary of chromophore spectrum</returns>
        </member>
        <member name="M:Vts.SpectralMapping.SpectralDatabase.WriteDatabaseToFiles(Vts.SpectralMapping.ChromophoreSpectrumDictionary)">
            <summary>
            Writes the Chromophore dictionary to separate text files
            </summary>
            <param name="chromophoreDictionary">The dictionary to write</param>
        </member>
        <member name="T:Vts.SpectralMapping.Tissue">
            <summary>
            Class to represent a tissue
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.Tissue.#ctor(System.Collections.Generic.IList{Vts.SpectralMapping.IChromophoreAbsorber},Vts.SpectralMapping.IScatterer,System.String,System.Nullable{System.Double})">
            <summary>
            Creates a tissue with the specified absorbers, scatterer and name
            </summary>
            <param name="absorbers">List of chromophore absorbers</param>
            <param name="scatterer">scatterer</param>
            <param name="name">Name of the tissue</param>
            <param name="n">refractive index</param>
        </member>
        <member name="P:Vts.SpectralMapping.Tissue.N">
            <summary>
            Index of refraction (default == 1.4)
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.Tissue.#ctor(Vts.TissueType)">
            <summary>
            Creates a tissue with the specified tissue type
            </summary>
            <param name="tissueType">Tissue type</param>
        </member>
        <member name="P:Vts.SpectralMapping.Tissue.ScattererType">
            <summary>
            Scatterer type
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.Tissue.TissueType">
            <summary>
            Type of tissue
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.Tissue.Name">
            <summary>
            Name of the tissue
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.Tissue.Absorbers">
            <summary>
            List of chromophore absorbers
            </summary>
        </member>
        <member name="P:Vts.SpectralMapping.Tissue.Scatterer">
            <summary>
            Scatterer
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.Tissue.SetPredefinedTissueDefinitions(Vts.TissueType)">
            <summary>
            Set the absorbers and the scatterer for the specified tissue type
            </summary>
            <param name="tissueType">Tissue type</param>
        </member>
        <member name="M:Vts.SpectralMapping.Tissue.ToString">
            <summary>
            Returns the name of the tissue
            </summary>
            <returns>The name of the tissue</returns>
        </member>
        <member name="M:Vts.SpectralMapping.Tissue.GetMua(System.Double)">
            <summary>
            Returns Mua (absorption coefficient) for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The absorption coefficient Mua</returns>
        </member>
        <member name="M:Vts.SpectralMapping.Tissue.GetMusp(System.Double)">
            <summary>
            Returns the reduced scattering coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The reduced scattering coefficient Mus'</returns>
        </member>
        <member name="M:Vts.SpectralMapping.Tissue.GetG(System.Double)">
            <summary>
            Returns the anisotropy coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The anisotropy coeffient g</returns>
        </member>
        <member name="M:Vts.SpectralMapping.Tissue.GetMus(System.Double)">
            <summary>
            Returns the scattering coefficient for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The scattering coefficient Mus</returns>
        </member>
        <member name="M:Vts.SpectralMapping.Tissue.GetOpticalProperties(System.Double)">
            <summary>
            Returns the optical properties for a given wavelength
            </summary>
            <param name="wavelength">Wavelength</param>
            <returns>The optical properties</returns>
        </member>
        <member name="M:Vts.SpectralMapping.Tissue.GetOpticalProperties(System.Double[])">
            <summary>
            Returns the optical properties for a given wavelength
            </summary>
            <param name="wavelengths">Wavelength</param>
            <returns>The optical properties</returns>
        </member>
        <member name="T:Vts.SpectralMapping.TissueProvider">
            <summary>
            tissue provider class
            </summary>
        </member>
        <member name="M:Vts.SpectralMapping.TissueProvider.CreateAbsorbers(Vts.TissueType)">
            <summary>
            Creates standard templates lists of absorbers for the specified tissue type
            </summary>
            <param name="tissueType">Tissue type</param>
        </member>
        <member name="M:Vts.SpectralMapping.TissueProvider.CreateScatterer(Vts.TissueType)">
            <summary>
            Sets the scatterer type for the specified tissue type
            </summary>
            <param name="tissueType">Tissue type</param>
        </member>
        <member name="T:Vts.MonteCarlo.AbsorptionWeightingMethods">
            <summary>
            methods used to determine photon weight based on absorption weighting method
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.AbsorptionWeightingMethods.GetVolumeAbsorptionWeightingMethod(Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetector)">
            <summary>
            Method that returns a function providing the correct absorption weighting for analog, DAW and CAW ATotal
            </summary>
            <param name="tissue">tissue specification</param>
            <param name="detector">detector specification</param>
            <returns>func providing correct absorption weighting for analog and DAW</returns>
        </member>
        <member name="M:Vts.MonteCarlo.AbsorptionWeightingMethods.GetpMCVolumeAbsorptionWeightingMethod(Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetector)">
            <summary>
            Method that returns a function providing the correct absorption weighting for analog and DAW
            </summary>
            <param name="tissue">tissue specification</param>
            <param name="detector">detector specification</param>
            <returns>func providing correct absorption weighting for analog and DAW</returns>
        </member>
        <member name="M:Vts.MonteCarlo.AbsorptionWeightingMethods.GetpMCTerminationAbsorptionWeightingMethod(Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetector)">
            <summary>
            Method that returns a function providing the correct absorption weighting for analog and DAW
            </summary>
            <param name="tissue">tissue specification</param>
            <param name="detector">detector specification</param>
            <returns>func providing correct absorption weighting for analog and DAW</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Controllers.DatabaseWriterController">
            <summary>
            A controller of DatabaseWriter(s).  It handles determining whether data should be written,
            and if so, writing the data, and finally disposing of the database.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.DatabaseWriterController.#ctor(System.Collections.Generic.IList{Vts.MonteCarlo.PhotonData.PhotonDatabaseWriter})">
            <summary>
            class that controls DatabaseWriter(s).
            </summary>
            <param name="photonDatabaseWriters">IList of PhotonDatabaseWriter</param>
        </member>
        <member name="P:Vts.MonteCarlo.Controllers.DatabaseWriterController.PhotonDatabaseWriters">
            <summary>
            list of PhotonDatabaseWriter
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.DatabaseWriterController.WriteToSurfaceVirtualBoundaryDatabases(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to write to all surface VB databases
            </summary>
            <param name="dp">PhotonDataPoint</param>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.DatabaseWriterController.DPBelongsToSurfaceVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDatabaseWriter)">
            <summary>
            Method to determine if photon data point should be tallied or not
            </summary>
            <param name="dp">PhotonDataPoint</param>
            <param name="photonDatabaseWriter">single PhotonDatabaseWriter</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.DatabaseWriterController.Dispose">
            <summary>
            Method to dispose of database writer(s)
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Controllers.DetectorController">
            <summary>
            Controller for detectors.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.DetectorController.#ctor(System.Collections.Generic.IEnumerable{Vts.MonteCarlo.IDetector})">
            <summary>
            controller for detectors
            </summary>
            <param name="detectors">IEnumerable for IDetector</param>
        </member>
        <member name="P:Vts.MonteCarlo.Controllers.DetectorController.Detectors">
            <summary>
            IList of IDetector
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.DetectorController.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method that tallies all detectors given Photon
            </summary>
            <param name="photon">Photon</param>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.DetectorController.NormalizeDetectors(System.Int64)">
            <summary>
            method that normalizes the detector tallies
            </summary>
            <param name="N">number of photons launched from source</param>
        </member>
        <member name="T:Vts.MonteCarlo.Controllers.HistoryDetectorController">
            <summary>
            Controller for detectors.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.HistoryDetectorController.#ctor(System.Collections.Generic.IEnumerable{Vts.MonteCarlo.IHistoryDetector},Vts.MonteCarlo.ITissue)">
            <summary>
            controller for history type detectors
            </summary>
            <param name="detectors">IEnumerable of IHistoryDetector</param>
            <param name="tissue">ITissue</param>
        </member>
        <member name="P:Vts.MonteCarlo.Controllers.HistoryDetectorController.Detectors">
            <summary>
            Ilist of IDetector
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.HistoryDetectorController.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detectors managed by this controller
            </summary>
            <param name="photon">Photon</param>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.HistoryDetectorController.NormalizeDetectors(System.Int64)">
            <summary>
            method to normalize detector tallies
            </summary>
            <param name="N">number of photons launched from source</param>
        </member>
        <member name="T:Vts.MonteCarlo.Controllers.pMCDatabaseWriterController">
            <summary>
            A controller of DatabaseWriter(s) for perturbation Monte Carlo (pMC).  It handles 
            determining whether data should be written,
            and if so, writing the data, and finally disposing of the database.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.pMCDatabaseWriterController.#ctor(System.Collections.Generic.IList{Vts.MonteCarlo.PhotonData.PhotonDatabaseWriter},System.Collections.Generic.IList{Vts.MonteCarlo.PhotonData.CollisionInfoDatabaseWriter})">
            <summary>
            constructor for pMC database writer controller
            </summary>
            <param name="photonDatabaseWriters">list of photon database writers</param>
            <param name="collisionInfoDatabaseWriters">list of collision info database writers</param>
        </member>
        <member name="P:Vts.MonteCarlo.Controllers.pMCDatabaseWriterController.PhotonDatabaseWriters">
            <summary>
            list of photon database writers
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Controllers.pMCDatabaseWriterController.CollisionInfoDatabaseWriters">
            <summary>
            list of collision info database writers
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.pMCDatabaseWriterController.WriteToSurfaceVirtualBoundaryDatabases(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.CollisionInfo)">
            <summary>
            Method to write to all surface VB databases
            </summary>
            <param name="dp">photon data point</param>
            <param name="collisionInfo">collision information</param>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.pMCDatabaseWriterController.DPBelongsToSurfaceVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDatabaseWriter)">
            <summary>
            Method to determine if photon data point should be tallied or not
            </summary>
            <param name="dp">photon data point</param>
            <param name="photonDatabaseWriter">photon database writer</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.pMCDatabaseWriterController.DPBelongsToSurfaceVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.CollisionInfoDatabaseWriter)">
            <summary>
            Method to determine if photon datapoint should be tallied or not to
            the collision info database
            </summary>
            <param name="dp">photon data point</param>
            <param name="collisionInfoDatabaseWriter">photon database writer</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.pMCDatabaseWriterController.Dispose">
            <summary>
            method to dispose of photon database writers
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Controllers.VirtualBoundaryController">
            <summary>
            Controller of virtual boundaries.  
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.VirtualBoundaryController.#ctor(System.Collections.Generic.IList{Vts.MonteCarlo.IVirtualBoundary})">
            <summary>
            virtual boundary controller
            </summary>
            <param name="virtualBoundaries">IList of virtual boundaries</param>
        </member>
        <member name="P:Vts.MonteCarlo.Controllers.VirtualBoundaryController.VirtualBoundaries">
            <summary>
            List of IVirtualBoundary.  All VBs handled by this controller.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Controllers.VirtualBoundaryController.GetClosestVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Double@)">
            <summary>
            Method to determine the distance to the closest VB in VirtualBoundaries list.
            </summary>
            <param name="dp">current PhotonDataPoint</param>
            <param name="distance">return: distance to closest VB</param>
            <returns>closest VB</returns>
        </member>
        <member name="T:Vts.MonteCarlo.PostProcessorInput">
            <summary>
             Defines input to the Monte Carlo Post-Processor.  This includes the input folder
             and database names, detector definitions, and output folder name.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PostProcessorInput.DetectorInputs">
            <summary>
            IList of IDetectorInput
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PostProcessorInput.InputFolder">
            <summary>
            string input folder
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PostProcessorInput.DatabaseSimulationInputFilename">
            <summary>
            string identifying database SimulationInput filename
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PostProcessorInput.OutputName">
            <summary>
            string identifying output folder name
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInput.#ctor(System.Collections.Generic.IList{Vts.MonteCarlo.IDetectorInput},System.String,System.String,System.String)">
            <summary>
            constructor for post-processor input
            </summary>
            <param name="detectorInputs">list of detector inputs</param>
            <param name="inputFolder">input folder name, where database file(s), etc. reside</param>
            <param name="databaseSimulationInputFilename">filename of simulation input file that generated database to be post-processed</param>
            <param name="outputName">output folder name</param>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInput.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInput.FromFile(System.String)">
            <summary>
            Method to read this class from JSON file.
            </summary>
            <param name="filename">string file name</param>
            <returns>PostProcessorInput</returns>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInput.ToFile(System.String)">
            <summary>
            Method to write this class to JSON file.
            </summary>
            <param name="filename">string file name</param>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInput.FromFileInResources(System.String,System.String)">
            <summary>
            Method to read this class from file in Resources
            </summary>
            <param name="filename">filename to be read</param>
            <param name="project">project where file resides</param>
            <returns>PostProcessorInput</returns>
        </member>
        <member name="T:Vts.MonteCarlo.PostProcessorInputProvider">
            <summary>
            Implements various commonly used PostProcessorInput classes for various tissue types.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInputProvider.GenerateAllPostProcessorInputs">
            <summary>
            Method that provides instances of all inputs in this class.
            </summary>
            <returns>a list of the PostProcessorInputs generated</returns>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInputProvider.PostProcessorROfRho">
            <summary>
            Perturbation MC R(rho) 
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInputProvider.pMCROfRhoAndROfRhoAndTime">
            <summary>
            Perturbation MC R(rho), R(rho) recessed, R(rho,time).  
            This assumes database being post-processed is for tissue system with one layer.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInputProvider.pMCROfRhoROfXAndYVariants">
            <summary>
            Perturbation MC R(rho) recessed, R(rho,time) recessed, R(rho,maxdepth) recessed
            This assumes database being post-processed is for tissue system with one layer.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInputProvider.pMCROfFxROfFxAndTime">
            <summary>
            Perturbation MC R(fx) and R(fx,time).  This assumes database being post-processed is for
            tissue system with one layer.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.SimulationInput">
            <summary>
             Defines input to the Monte Carlo simulation.  This includes the output
             file name, number of photons to execute (N), source, tissue and detector
             definitions.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInput.#ctor(System.Int64,System.String,Vts.MonteCarlo.SimulationOptions,Vts.MonteCarlo.ISourceInput,Vts.MonteCarlo.ITissueInput,System.Collections.Generic.IList{Vts.MonteCarlo.IDetectorInput})">
            <summary>
            Monte Carlo simulation input data
            </summary>
            <param name="numberOfPhotons">long number indicating number of photons launched from source</param>
            <param name="outputName">string indicating output name</param>
            <param name="simulationOptions">options to execute simulation</param>
            <param name="sourceInput">ISourceInput specifying source of light</param>
            <param name="tissueInput">ITissueInput specifying tissue definition</param>
            <param name="detectorInputs">IDetectorInput specifying which detectors to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInput.#ctor">
            <summary>
            SimulationInput default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationInput.OutputName">
            <summary>
            string name of output file
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationInput.N">
            <summary>
            number of photons launched from source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationInput.Options">
            <summary>
            SimulationOptions specify, for example, absorption weighting type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationInput.SourceInput">
            <summary>
            source input (ISourceInput)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationInput.TissueInput">
            <summary>
            tissue input (ITissueInput)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationInput.DetectorInputs">
            <summary>
            detector input (IList of IDetectorInput)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInput.FromFile(System.String)">
            <summary>
            Method to read SimulationInput from JSON file
            </summary>
            <param name="filename">string filename of file to be read</param>
            <returns>SimulationInput</returns>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInput.CreateSimulation">
            <summary>
            Method to create simulation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInput.ToFile(System.String)">
            <summary>
            Method to write SimulationInput to file
            </summary>
            <param name="filename">string filename to write to</param>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInput.FromFileInResources(System.String,System.String)">
            <summary>
            Method to read SimulationInput json from file in resources
            </summary>
            <param name="filename">string filename</param>
            <param name="project">string project name</param>
            <returns>SimulationInput</returns>
        </member>
        <member name="T:Vts.MonteCarlo.SimulationInputProvider">
            <summary>
            Implements various commonly used SimulationInput classes for various tissue types.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.GenerateAllSimulationInputs">
            <summary>
            Method that provides instances of all inputs in this class.
            </summary>
            <returns>a list of the SimulationInputs generated</returns>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceOneLayerTissueAllDetectors">
            <summary>
            Point source, single tissue layer definition, all detectors included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceOneLayerTissueROfRhoAndFluenceOfRhoAndZDetectors">
            <summary>
            Point source, single tissue layer definition, only ROfRho detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceOneLayerTissueRadianceOfRhoAndZAndAngleDetector">
            <summary>
            Point source, single tissue layer definition, Radiance included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceTwoLayerTissueROfRhoDetector">
            <summary>
            Point source, two-layer tissue definition, only ROfRho detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceTwoLayerTissueROfRhoDetectorWithPhotonDatabase">
            <summary>
            Point source, two-layer tissue definition, only ROfRho detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceSingleEllipsoidTissueFluenceOfRhoAndZDetector">
            <summary>
            Point source, single ellipsoid tissue definition, only FluenceOfRhoAndZ detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceSingleInfiniteCylinderTissueAOfXAndYAndZDetector">
            <summary>
            Point source, single infinite cylinder tissue definition, only AOfXAndYAndZ detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceMultiInfiniteCylinderTissueAOfXAndYAndZDetector">
            <summary>
            Point source, multi infinite cylinder tissue definition, only AOfXAndYAndZ detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.pMCPointSourceOneLayerTissueROfRhoDAW">
            <summary>
            Perturbation MC point source, single tissue layer definition, R(rho) included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.Gaussian2DSourceOneLayerTissueROfRhoDetector">
            <summary>
            Gaussian 2D source, single tissue layer definition, only ROfRho detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.Flat2DSourceTwoLayerBoundedTissueAOfRhoAndZDetector">
            <summary>
            Flat 2D source, two layer, bounded tissue, AOfRhoAndZ detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.Flat2DSourceOneLayerTissueROfRhoDetector">
            <summary>
            Flat 2D source, single tissue layer definition, only ROfRho detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.GaussianLineSourceOneLayerTissueROfRhoDetector">
            <summary>
            Gaussian line source, single tissue layer definition, only ROfRho detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceMultiLayerMomentumTransferDetectors">
            <summary>
            Point source, multi-layer tissue definition, all momentum detectors detectors included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceSingleVoxelTissueROfXAndYAndFluenceOfXAndYAndZDetector">
            <summary>
            Point source, single voxel tissue definition, only FluenceOfXAndYAndZ detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceThreeLayerReflectedTimeOfRhoAndSubregionHistDetector">
            <summary>
            Point source, three-layer tissue definition, with R(rho,time) and
            ReflectedTimeOfRhoAndSubregionHistDetector detector included
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.EmbeddedDirectionalCircularSourceEllipTissueFluenceOfXAndYAndZ">
            <summary>
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.PointSourceSurfaceFiberTissueAndDetector">
            <summary>
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputProvider.FluorescenceEmissionAOfXAndYAndZSourceInfiniteCylinder">
            <summary>
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.SimulationOptions">
            <summary>
            Designates random number generator,
            absorption weighting type and flags input to the Monte
            Carlo simulation (e.g. tally second moment and
            specify seed for RNG).
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationOptions.#ctor(System.Int32,Vts.RandomNumberGeneratorType,Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Collections.Generic.IList{Vts.MonteCarlo.DatabaseType},System.Boolean,System.Double,System.Int32)">
            <summary>
            constructor for simulation options, a class sub to SimulationInput
            </summary>
            <param name="seed">random number generator seed (-1=randomly chosen seed, >=0 reproducible sequence)</param>
            <param name="rngType">random number generator type</param>
            <param name="absWeightingType">absorption weighting type</param>
            <param name="phaseFunctionType">phase function type</param>
            <param name="databases">list of DatabaseType indicating data to be written database for post-processing</param>
            <param name="trackStatistics">flag indicating whether to track statistics about where photons end up</param>
            <param name="russianRouletteWeightThreshold">weight threshold to perform RR (default=0, no RR)</param>
            <param name="simulationIndex">index of simulation</param>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationOptions.#ctor(System.Int32,Vts.RandomNumberGeneratorType,Vts.AbsorptionWeightingType)">
            <summary>
            constructor that uses Henyey-Greenstein phase function, does not save photon data to database,
            tallies 2nd moment information, does not track statistics and designates simulation index to 0
            </summary>
            <param name="seed"></param>
            <param name="rngType"></param>
            <param name="absWeightingType"></param>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationOptions.#ctor(System.Int32)">
            <summary>
            constructor that takes in seed but uses default values for all other parameters
            </summary>
            <param name="seed"></param>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationOptions.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOptions.Seed">
            <summary>
            seed of random number generator (-1=randomly selected seed, >=0 reproducible sequence)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOptions.RandomNumberGeneratorType">
            <summary>
            random number generator type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOptions.AbsorptionWeightingType">
            <summary>
            absorption weighting type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOptions.PhaseFunctionType">
            <summary>
            phase function type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOptions.Databases">
            <summary>
            list of databases to be written
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOptions.TrackStatistics">
            <summary>
            flag indicating whether to track statistics about where photon ends up
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOptions.RussianRouletteWeightThreshold">
            <summary>
            photon weight threshold to perform Russian Roulette.  Default = 0 means no RR performed.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOptions.SimulationIndex">
            <summary>
            simulation index 
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.SimulationOutput">
            <summary>
            Helper class to surface the results of a Monte Carlo simulation in a user-friendly (strongly-typed) way
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationOutput.#ctor(Vts.MonteCarlo.SimulationInput,System.Collections.Generic.IList{Vts.MonteCarlo.IDetector})">
            <summary>
            Output from a Monte Carlo simulation
            </summary>
            <param name="si">SimulationInput</param>
            <param name="detectorResults">list of IDetector</param>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.SurFib">
            <summary>
            Surface fiber
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.SurFib2">
            <summary>
            Surface fiber 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.SurFib_TallyCount">
            <summary>
            Surface fiber tally count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rd">
            <summary>
            Diffuse Reflectance
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rd2">
            <summary>
            Diffuse Reflectance 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rd_TallyCount">
            <summary>
            Diffuse Reflectance TallyCount
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rspec">
            <summary>
            Specular Reflectance
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rspec2">
            <summary>
            Specular Reflectance 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rspec_TallyCount">
            <summary>
            Specular Reflectance Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_r">
            <summary>
            Reflectance as a function of rho (source-detector separation)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_r2">
            <summary>
            Reflectance as a function of rho (source-detector separation) 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_r_TallyCount">
            <summary>
            Reflectance as a function of rho (source-detector separation) Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rr">
            <summary>
            Reflectance as a function of rho (source-detector separation) recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rr2">
            <summary>
            Reflectance as a function of rho (source-detector separation) 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rr_TallyCount">
            <summary>
            Reflectance as a function of rho (source-detector separation) Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_a">
            <summary>
            Reflectance as a function of angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_a2">
            <summary>
            Reflectance as a function of angle 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_a_TallyCount">
            <summary>
            Reflectance as a function of angle Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_ra">
            <summary>
            Reflectance as a function of rho and angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_ra2">
            <summary>
            Reflectance as a function of rho and angle 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_ra_TallyCount">
            <summary>
            Reflectance as a function of rho and angle Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rt">
            <summary>
            Reflectance as a function of rho and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rt2">
            <summary>
            Reflectance as a function of rho and time 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rt_TallyCount">
            <summary>
            Reflectance as a function of rho and time Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rmd">
            <summary>
            Reflectance as a function of rho and maximum depth attained
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rmd2">
            <summary>
            Reflectance as a function of rho and max depth 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rmd_TallyCount">
            <summary>
            Reflectance as a function of rho and max depth Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rmdr">
            <summary>
            Reflectance as a function of rho and maximum depth attained recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rmdr2">
            <summary>
            Reflectance as a function of rho and max depth 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rmdr_TallyCount">
            <summary>
            Reflectance as a function of rho and max depth Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rw">
            <summary>
            Reflectance as a function of rho and omega (temporal frequency)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rw2">
            <summary>
            Reflectance as a function of rho and omega (temporal frequency) 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_rw_TallyCount">
            <summary>
            Reflectance as a function of rho and omega (temporal frequency) Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xy">
            <summary>
            Reflectance as a function of x and y
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xy2">
            <summary>
            Reflectance as a function of x and y 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xy_TallyCount">
            <summary>
            Reflectance as a function of x and y Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyr">
            <summary>
            Reflectance as a function of x and y recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyr2">
            <summary>
            Reflectance as a function of x and y recessed in air 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyr_TallyCount">
            <summary>
            Reflectance as a function of x and y recessed in air Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyt">
            <summary>
            Reflectance as a function of x and y and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyt2">
            <summary>
            Reflectance as a function of x and y and time 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyt_TallyCount">
            <summary>
            Reflectance as a function of x and y and time Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytr">
            <summary>
            Reflectance as a function of x and y and time recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytr2">
            <summary>
            Reflectance as a function of x and y and time recessed in air 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytr_TallyCount">
            <summary>
            Reflectance as a function of x and y and time recessed in air Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyts">
            <summary>
            Reflectance as a function of x and y and time and subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyts2">
            <summary>
            Reflectance as a function of x and y 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyts_xy">
            <summary>
            Reflectance as a function of x and y and time and subregion ROfXAndY
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyts_xy2">
            <summary>
            Reflectance as a function of x and y and time and subregion ROfXAndY 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xyts_TallyCount">
            <summary>
            Reflectance as a function of x and y and subregion Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytsr">
            <summary>
            Reflectance as a function of x and y and time and subregion recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytsr_xy">
            <summary>
            Reflectance as a function of x and y and time and subregion recessed ROfXAndY
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytsr_xy2">
            <summary>
            Reflectance as a function of x and y and time and subregion recessed ROfXAndY 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytsr2">
            <summary>
            Reflectance as a function of x and y and time and subregion recessed in air 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytsr_TallyCount">
            <summary>
            Reflectance as a function of x and y and time and subregion recessed in air Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytp">
            <summary>
            Reflectance as a function of x and y and theta and phi
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytp2">
            <summary>
            Reflectance as a function of x and y and theta and phi 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xytp_TallyCount">
            <summary>
            Reflectance as a function of x and y and theta and phi Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xymd">
            <summary>
            Reflectance as a function of x and y and max depth
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xymd2">
            <summary>
            Reflectance as a function of x and y and max depth 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xymd_TallyCount">
            <summary>
            Reflectance as a function of x and y and max depth Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xymdr">
            <summary>
            Reflectance as a function of x and y and max depth recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xymdr2">
            <summary>
            Reflectance as a function of x and y and max depth recessed in air 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_xymdr_TallyCount">
            <summary>
            Reflectance as a function of x and y and max depth recessed in air Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_fx">
            <summary>
            Reflectance as a function of spatial frequency
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_fx2">
            <summary>
            Reflectance as a function of spatial frequency 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_fx_TallyCount">
            <summary>
            Reflectance as a function of spatial frequency Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_fxt">
            <summary>
            Reflectance as a function of spatial frequency and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_fxt2">
            <summary>
            Reflectance as a function of spatial frequency and time 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_fxt_TallyCount">
            <summary>
            Reflectance as a function of spatial frequency and time Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_fxa">
            <summary>
            Reflectance as a function of spatial frequency and angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_fxa2">
            <summary>
            Reflectance as a function of spatial frequency and time 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.R_fxa_TallyCount">
            <summary>
            Reflectance as a function of spatial frequency and time Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Td">
            <summary>
            Diffuse Transmittance
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Td2">
            <summary>
            Diffuse Transmittance 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Td_TallyCount">
            <summary>
            Diffuse Transmittance Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_r">
            <summary>
            Transmittance as a function of rho (source-detector separation)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_r2">
            <summary>
            Transmittance as a function of rho (source-detector separation) 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_r_TallyCount">
            <summary>
            Transmittance as a function of rho (source-detector separation) Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_a">
            <summary>
            Transmittance as a function of angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_a2">
            <summary>
            Transmittance as a function of angle 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_a_TallyCount">
            <summary>
            Transmittance as a function of angle Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_ra">
            <summary>
            Transmittance as a function of rho and angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_ra2">
            <summary>
            Transmittance as a function of rho and angle 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_ra_TallyCount">
            <summary>
            Transmittance as a function of rho and angle Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_xy">
            <summary>
            Transmittance as a function of x and y
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_xy2">
            <summary>
            Transmittance as a function of x and y 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_xy_TallyCount">
            <summary>
            Transmittance as a function of x and y Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_xyts">
            <summary>
            Transmittance as a function of x and y and time and subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_xyts2">
            <summary>
            Transmittance as a function of x and y 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_xyts_xy">
            <summary>
            Transmittance as a function of x and y and time and subregion ROfXAndY
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_xyts_xy2">
            <summary>
            Transmittance as a function of x and y and time and subregion ROfXAndY 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_xyts_TallyCount">
            <summary>
            Transnmittance as a function of x and y and subregion Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_fx">
            <summary>
            Transmittance as a function of spatial frequency
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_fx2">
            <summary>
            Transmitance as a function of spatial frequency 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.T_fx_TallyCount">
            <summary>
            Transmitance as a function of spatial frequency Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Atot">
            <summary>
            Total Absorbed Energy
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Atot2">
            <summary>
            Total Absorbed Energy 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Atot_TallyCount">
            <summary>
            Total Absorbed Energy Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.AtotBV">
            <summary>
            Total Absorbed Energy in bounding volume
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.AtotBV2">
            <summary>
            Total Absorbed Energy in bounding volume 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.AtotBV_TallyCount">
            <summary>
            Total Absorbed Energy in bounding volume Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.A_rz">
            <summary>
            Absorbed Energy as a function of rho and z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.A_rz2">
            <summary>
            Absorbed Energy as a function of rho and z 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.A_rz_TallyCount">
            <summary>
            Absorbed Energy as a function of rho and z Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.A_xyz">
            <summary>
            Absorption as a function of x, y and z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.A_xyz2">
            <summary>
            Absorption as a function of x, y and z 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.A_xyz_TallyCount">
            <summary>
            Absorption as a function of x, y and z Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_rz">
            <summary>
            Fluence as a function of rho and z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_rz2">
            <summary>
            Fluence as a function of rho and z 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_rz_TallyCount">
            <summary>
            Fluence as a function of rho and z Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_rzt">
            <summary>
            Fluence as a function of rho, z and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_rzt2">
            <summary>
            Fluence as a function of rho, z and time 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_rzt_TallyCount">
            <summary>
            Fluence as a function of rho, z and time Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyz">
            <summary>
            Fluence as a function of x, y and z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyz2">
            <summary>
            Fluence as a function of x, y and z 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyz_TallyCount">
            <summary>
            Fluence as a function of x, y and z Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyzt">
            <summary>
            Fluence as a function of x, y and z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyzt2">
            <summary>
            Fluence as a function of x, y and z 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyzt_TallyCount">
            <summary>
            Fluence as a function of x, y and z Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyzw">
            <summary>
            Fluence as a function of x, y, z and omega (temporal frequency)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyzw2">
            <summary>
            Fluence as a function of x, y, z and omega 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyzw_TallyCount">
            <summary>
            Fluence as a function of x, y, z and omega Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyzxy">
            <summary>
            Fluence as a function of x, y, z and starting location x,y
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyzxy2">
            <summary>
            Fluence as a function of x, y, z and and starting location x,y 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyzxy_TallyCount">
            <summary>
            Fluence as a function of x, y, z and starting location x,y Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_xyzxy_xycount">
            <summary>
            Fluence as a function of x, y, z and starting location x,y Count of starting photons
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_rzw">
            <summary>
            Fluence as a function of rho, z and omega (temporal frequency)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_rzw2">
            <summary>
            Fluence as a function of rho, z and omega 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_rzw_TallyCount">
            <summary>
            Fluence as a function of fx and z Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_fxz">
            <summary>
            Fluence as a function of fx (spatial-frequency) and z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_fxz2">
            <summary>
            Fluence as a function of fx and z2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Flu_fxz_TallyCount">
            <summary>
            Fluence as a function of fx and omega Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_r">
            <summary>
            Radiance as a function of rho (surface tally) at depth Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_r2">
            <summary>
            Radiance as a function of rho (surface tally) at depth Z 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_r_TallyCount">
            <summary>
            Radiance as a function of rho (surface tally) at depth Z Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_rza">
            <summary>
            Radiance as a function of rho, z and angle (volume tally)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_rza2">
            <summary>
            Radiance as a function of rho, z and angle (volume tally) 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_rza_TallyCount">
            <summary>
            Radiance as a function of rho, z and angle (volume tally) Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_fxza">
            <summary>
            Radiance as a function of fx, z and angle (volume tally)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_fxza2">
            <summary>
            Radiance as a function of rho, z and angle (volume tally) 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_fxza_TallyCount">
            <summary>
            Radiance as a function of rho, z and angle (volume tally) Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_xyztp">
            <summary>
            Radiance as a function of x, y, z, theta and phi (volume tally)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_xyztp2">
            <summary>
            Radiance as a function of x, y, z, theta and phi (volume tally) 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Rad_xyztp_TallyCount">
            <summary>
            Radiance as a function of x, y, z, theta and phi (volume tally) Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefMT_rmt">
            <summary>
            Reflected Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefMT_rmt2">
            <summary>
            Reflected Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefMT_rmt_TallyCount">
            <summary>
            Reflected Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefMT_rmt_frac">
            <summary>
            Reflected Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT fractional MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefMT_xymt">
            <summary>
            Reflected Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefMT_xymt2">
            <summary>
            Reflected Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefMT_xymt_TallyCount">
            <summary>
            Reflected Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefMT_xymt_frac">
            <summary>
            Reflected Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT fractional MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransMT_rmt">
            <summary>
            Transmitted Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransMT_rmt2">
            <summary>
            Transmitted Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransMT_rmt_TallyCount">
            <summary>
            Transmitted Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransMT_rmt_frac">
            <summary>
            Transmitted Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT fractional MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransMT_xymt">
            <summary>
            Transmitted Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransMT_xymt2">
            <summary>
            Transmitted Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransMT_xymt_TallyCount">
            <summary>
            Transmitted Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransMT_xymt_frac">
            <summary>
            Transmitted Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT fractional MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_rmt">
            <summary>
            Reflected Dynamic Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_rmt2">
            <summary>
            Reflected Dynamic Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_rmt_TallyCount">
            <summary>
            Reflected Dynamic Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_rmt_frac">
            <summary>
            Reflected Dynamic Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT fractional MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_rmt_totofz">
            <summary>
            Reflected Dynamic Momentum Transfer of Rho and Tissue SubRegion with Total MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_rmt_dynofz">
            <summary>
            Reflected Dynamic Momentum Transfer of Rho and Tissue SubRegion with Dynamic MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_rmt_subrcols">
            <summary>
            Reflected Dynamic Momentum Transfer of Rho and Tissue SubRegion with SubregionCollisions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_xymt">
            <summary>
            Reflected Dynamic Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_xymt2">
            <summary>
            Reflected Dynamic Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_xymt_TallyCount">
            <summary>
            Reflected Dynamic Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_xymt_frac">
            <summary>
            Reflected Dynamic Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT fractional MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_xymt_totofz">
            <summary>
            Reflected Dynamic Momentum Transfer of X, Y and Tissue SubRegion with Total MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_xymt_dynofz">
            <summary>
            Reflected Dynamic Momentum Transfer of X, Y and Tissue SubRegion with Dynamic MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_xymt_subrcols">
            <summary>
            Reflected Dynamic Momentum Transfer of X, Y and Tissue SubRegion with SubregionCollisions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_fxmt">
            <summary>
            Reflected Dynamic Momentum Transfer of Fx and Tissue SubRegion with a histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_fxmt2">
            <summary>
            Reflected Dynamic Momentum Transfer of Fx and Tissue SubRegion with a histogram of MT 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_fxmt_TallyCount">
            <summary>
            Reflected Dynamic Momentum Transfer of Fx and Tissue SubRegion with a histogram of MT Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_fxmt_frac">
            <summary>
            Reflected Dynamic Momentum Transfer of Fx and Tissue SubRegion with a histogram of MT fractional MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_fxmt_totofz">
            <summary>
            Reflected Dynamic Momentum Transfer of Fx and Tissue SubRegion with Total MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_fxmt_dynofz">
            <summary>
            Reflected Dynamic Momentum Transfer of Fx and Tissue SubRegion with Dynamic MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefDynMT_fxmt_subrcols">
            <summary>
            Reflected Dynamic Momentum Transfer of Fx and Tissue SubRegion with SubregionCollisions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_rmt">
            <summary>
            Transmitted Dynamic Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_rmt2">
            <summary>
            Transmitted Dynamic Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_rmt_TallyCount">
            <summary>
            Transmitted Dynamic Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_rmt_frac">
            <summary>
            Transmitted Dynamic Momentum Transfer of Rho and Tissue SubRegion with a histogram of MT fractional MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_rmt_totofz">
            <summary>
            Transmitted Dynamic Momentum Transfer of Rho and Tissue SubRegion with Total MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_rmt_dynofz">
            <summary>
            Transmitted Dynamic Momentum Transfer of Rho and Tissue SubRegion with Dynamic MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_rmt_subrcols">
            <summary>
            Transmitted Dynamic Momentum Transfer of Rho and Tissue SubRegion with SubregionCollisions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_xymt">
            <summary>
            Transmitted Dynamic Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_xymt2">
            <summary>
            Transmitted Dynamic Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_xymt_TallyCount">
            <summary>
            Transmitted Dynamic Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_xymt_frac">
            <summary>
            Transmitted Dynamic Momentum Transfer of X, Y and Tissue SubRegion with a histogram of MT fractional MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_xymt_totofz">
            <summary>
            Transmitted Dynamic Momentum Transfer of X, Y and Tissue SubRegion with Total MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_xymt_dynofz">
            <summary>
            Transmitted Dynamic Momentum Transfer of X, Y and Tissue SubRegion with Dynamic MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_xymt_subrcols">
            <summary>
            Transmitted Dynamic Momentum Transfer of X, Y and Tissue SubRegion with SubregionCollisions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_fxmt">
            <summary>
            Transmitted Dynamic Momentum Transfer of Fx and Tissue SubRegion with a histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_fxmt2">
            <summary>
            Transmitted Dynamic Momentum Transfer of Fx and Tissue SubRegion with a histogram of MT 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_fxmt_TallyCount">
            <summary>
            Transmitted Dynamic Momentum Transfer of Fx and Tissue SubRegion with a histogram of MT Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_fxmt_frac">
            <summary>
            Transmitted Dynamic Momentum Transfer of Fx and Tissue SubRegion with a histogram of MT fractional MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_fxmt_totofz">
            <summary>
            Transmitted Dynamic Momentum Transfer of Fx and Tissue SubRegion with Total MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_fxmt_dynofz">
            <summary>
            Transmitted Dynamic Momentum Transfer of Fx and Tissue SubRegion with Dynamic MT of Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.TransDynMT_fxmt_subrcols">
            <summary>
            Transmitted Dynamic Momentum Transfer of Fx and Tissue SubRegion with SubregionCollisions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefTime_rs_hist">
            <summary>
            Reflected Time of Rho and Tissue SubRegion with a histogram of Time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefTime_rs_hist2">
            <summary>
            Reflected Time of Rho and Tissue SubRegion with a histogram of Time 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.RefTime_rs_hist_TallyCount">
            <summary>
            Reflected Time of Rho and Tissue SubRegion with a histogram of Time Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_Atot">
            <summary>
            pMC Total Absorbed Energy
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_Atot2">
            <summary>
            Total Absorbed Energy 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_Atot_TallyCount">
            <summary>
            Total Absorbed Energy Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_r">
            <summary>
            perturbation MC Reflectance as a function of rho 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_r2">
            <summary>
            perturbation MC Reflectance as a function of rho 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_r_TallyCount">
            <summary>
            perturbation MC Reflectance as a function of rho Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_rr">
            <summary>
            perturbation MC Reflectance as a function of rho recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_rr2">
            <summary>
            perturbation MC Reflectance as a function of rho recessed in air 2nd moment 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_rr_TallyCount">
            <summary>
            perturbation MC Reflectance as a function of rho recessed in air Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_rt">
            <summary>
            perturbation MC Reflectance as a function of rho and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_rt2">
            <summary>
            perturbation MC Reflectance as a function of rho and time 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_rt_TallyCount">
            <summary>
            perturbation MC Reflectance as a function of rho and time Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_rtr">
            <summary>
            perturbation MC Reflectance as a function of rho and time recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_rtr2">
            <summary>
            perturbation MC Reflectance as a function of rho and time recessed in air 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_rtr_TallyCount">
            <summary>
            perturbation MC Reflectance as a function of rho and time recessed in air Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xy">
            <summary>
            perturbation MC Reflectance as a function of x and y
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xy2">
            <summary>
            perturbation MC Reflectance as a function of x and y 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xy_TallyCount">
            <summary>
            perturbation MC Reflectance as a function of x and y Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xyts">
            <summary>
            perturbation MC Reflectance as a function of x, y, time and tissue subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xyts_xy">
            <summary>
            perturbation MC Reflectance as a function of x and y and time and subregion ROfXAndY
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xyts_xy2">
            <summary>
            perturbation MC Reflectance as a function of x and y and time and subregion ROfXAndY 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xyts2">
            <summary>
            perturbation MC Reflectance as a function of x, y, time and tissue subregion 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xyts_TallyCount">
            <summary>
            perturbation MC Reflectance as a function of x, y, time and tissue subregion Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xytsr">
            <summary>
            perturbation MC Reflectance as a function of x, y, time and tissue subregion recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xytsr_xy">
            <summary>
            perturbation MC Reflectance as a function of x and y and time and subregion recessed ROfXAndY
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xytsr_xy2">
            <summary>
            perturbation MC Reflectance as a function of x and y and time and subregion recessed ROfXAndY 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xytsr2">
            <summary>
            perturbation MC Reflectance as a function of x, y, time and tissue subregion recessed in air 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_xytsr_TallyCount">
            <summary>
            perturbation MC Reflectance as a function of x, y, time and tissue subregion recessed in air Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_T_r">
            <summary>
            perturbation MC Transmittance as a function of rho 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_T_r2">
            <summary>
            perturbation MC Transmittance as a function of rho 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_T_r_TallyCount">
            <summary>
            perturbation MC Transmittance as a function of rho Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.dMCdMua_R_r">
            <summary>
            differential MC Reflectance as a function of rho wrt to mua
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.dMCdMua_R_r2">
            <summary>
            differential MC Reflectance as a function of rho wrt to mua 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.dMCdMua_R_r_TallyCount">
            <summary>
            differential MC Reflectance as a function of rho wrt to mua Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.dMCdMus_R_r">
            <summary>
            differential MC Reflectance as a function of rho wrt to mus
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.dMCdMus_R_r2">
            <summary>
            differential MC Reflectance as a function of rho wrt to mus 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.dMCdMus_R_r_TallyCount">
            <summary>
            differential MC Reflectance as a function of rho wrt to mus Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_fx">
            <summary>
            perturbation MC Reflectance as a function of fx
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_fx2">
            <summary>
            perturbation MC Reflectance as a function of fx 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_fx_TallyCount">
            <summary>
            perturbation MC Reflectance as a function of fx Tally Count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_fxt">
            <summary>
            perturbation MC Reflectance as a function of fx and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_fxt2">
            <summary>
            perturbation MC Reflectance as a function of fx and time 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.pMC_R_fxt_TallyCount">
            <summary>
            perturbation MC Reflectance as a function of fx and time Tally count
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.Input">
            <summary>
            Simulation Input that generated this SimulationOutput
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationOutput.ResultsDictionary">
            <summary>
            Dictionary holding detector results as specified in SimulationInput
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationOutput.GetDetectors(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            method that calls GetDetector to get detectors from a list of detector names
            </summary>
            <param name="detectorNames">list of detector names strings</param>
            <returns>list of IDetector</returns>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationOutput.GetDetector(System.String)">
            <summary>
            method to get detector from detector name
            </summary>
            <param name="detectorName">detector name string</param>
            <returns>IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.SimulationStatistics">
            <summary>
            This class captures informational statistics of the MC simulation executed
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationStatistics.#ctor(System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            class captures statistics about where the photon ended up.
            </summary>
            <param name="numberOfPhotonsOutTopOfTissue"># photons out top of tissue</param>
            <param name="numberOfPhotonsOutBottomOfTissue"># photons out bottom of tissue</param>
            <param name="numberOfPhotonsAbsorbed"># photons absorbed</param>
            <param name="numberOfPhotonsSpecularReflected"># photons specular reflected</param>
            <param name="numberOfPhotonsKilledOverMaximumPathLength"># photons killed due to maximum path length</param>
            <param name="numberOfPhotonsKilledOverMaximumCollisions"># photons killed due to maxiumu collisions</param>
            <param name="numberOfPhotonsKilledByRussianRoulette"># photons killed by Russian Roulette
            
            </param>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationStatistics.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationStatistics.NumberOfPhotonsOutTopOfTissue">
            <summary>
            number of photons out top of tissue (diffuse reflection)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationStatistics.NumberOfPhotonsOutBottomOfTissue">
            <summary>
            number of photons out bottom of tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationStatistics.NumberOfPhotonsAbsorbed">
            <summary>
            number of photons absorbed
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationStatistics.NumberOfPhotonsSpecularReflected">
            <summary>
            number of photons specular reflected
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationStatistics.NumberOfPhotonsKilledOverMaximumPathLength">
            <summary>
            number of photons killed because of path length longer than maximum allowed
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationStatistics.NumberOfPhotonsKilledOverMaximumCollisions">
            <summary>
            number of photons killed because number of collisions larger than maximum allowed
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.SimulationStatistics.NumberOfPhotonsKilledByRussianRoulette">
            <summary>
            number of photons killed by Russian Roulette
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationStatistics.ToFile(System.String)">
            <summary>
            method to write results to file
            </summary>
            <param name="filename"></param>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationStatistics.FromFile(System.String)">
            <summary>
            method to read results from file
            </summary>
            <param name="filename">filename to be read</param>
            <returns>instance of simulation statistics</returns>
        </member>
        <member name="T:Vts.MonteCarlo.SourceInputProvider">
            <summary>
            Implements various commonly used SourceInput classes.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SourceInputProvider.GenerateAllSourceInputs">
            <summary>
            Method that provides instances of all inputs in this class.
            </summary>
            <returns>a list of the ISourceInputs generated</returns>
        </member>
        <member name="M:Vts.MonteCarlo.SourceInputProvider.PointSource">
            <summary>
            Point source normally oriented
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.SourceInputProvider.FlatLineSource">
            <summary>
            Line source normally oriented and flat
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SourceInputProvider.GaussianCircularSource">
            <summary>
            Gaussian normal source with fwhm=1 and outer radius=3mm
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SourceInputProvider.GaussianEllipticalSource">
            <summary>
            Gaussian normal source with fwhm=1 and ellipse parameters a and b
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SourceInputProvider.GaussianRectangularSource">
            <summary>
            Gaussian normal source with fwhm=1 and rectangular length and width
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SourceInputProvider.LambertianSphericalSource">
            <summary>
            Lambertian spherical source
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SourceInputProvider.LambertianCuboidalSource">
            <summary>
            Lambertian cuboidal source
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SourceInputProvider.LambertianTubularSource">
            <summary>
            Lambertian tubular source
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.dMCdROfRhodMuaDetectorInputValidation">
            <summary>
            This verifies dMCROfRhoDMuaDetectorInput
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.dMCdROfRhodMuaDetectorInputValidation.ValidateInput(Vts.MonteCarlo.IDetectorInput)">
            <summary>
            Method to validate that only one perturbed region specified
            </summary>
            <param name="input">detector input in SimulationInput</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.dMCdROfRhodMusDetectorInputValidation">
            <summary>
            This verifies dMCROfRhoDMusDetectorInput
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.dMCdROfRhodMusDetectorInputValidation.ValidateInput(Vts.MonteCarlo.IDetectorInput)">
            <summary>
            Method to validate that only one perturbed region specified
            </summary>
            <param name="input">detector input in SimulationInput</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.RecessedDetectorInputValidation">
            <summary>
            This verifies any Recessed DetectorInput
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.RecessedDetectorInputValidation.ValidateInput(Vts.MonteCarlo.IDetectorInput)">
            <summary>
            Method to validate recessed ZPlane specification is negative
            </summary>
            <param name="input">detector input in SimulationInput</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInputValidation">
            <summary>
            This verifies ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInputValidation.ValidateInput(Vts.MonteCarlo.IDetectorInput,System.Int32)">
            <summary>
            Method to validate blood volume fraction input agrees with number of tissue subregions
            </summary>
            <param name="input">detector input in SimulationInput</param>
            <param name="tissueRegionCount">number of tissue regions</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInputValidation">
            <summary>
            This verifies ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInputValidation.ValidateInput(Vts.MonteCarlo.IDetectorInput,System.Int32)">
            <summary>
            Method to validate blood volume fraction input agrees with number of tissue subregions
            </summary>
            <param name="input">detector input in SimulationInput</param>
            <param name="tissueRegionCount">number of tissue regions</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.SurfaceFiberDetectorInputValidation">
            <summary>
            This verifies SurfaceFiberDetectorInput is correct
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SurfaceFiberDetectorInputValidation.ValidateInput(Vts.MonteCarlo.IDetectorInput)">
            <summary>
            Method to validate detector fiber is defined to be on surface of tissue
            </summary>
            <param name="input">detector input in SimulationInput</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInputValidation">
            <summary>
            This verifies TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInputValidation.ValidateInput(Vts.MonteCarlo.IDetectorInput,System.Int32)">
            <summary>
            Method to validate blood volume fraction input agrees with number of tissue subregions
            </summary>
            <param name="input">detector input in SimulationInput</param>
            <param name="tissueRegionCount">number of tissue regions</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInputValidation">
            <summary>
            This verifies TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInputValidation.ValidateInput(Vts.MonteCarlo.IDetectorInput,System.Int32)">
            <summary>
            Method to validate blood volume fraction input agrees with number of tissue subregions
            </summary>
            <param name="input">detector input in SimulationInput</param>
            <param name="tissueRegionCount">number of tissue regions</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.PostProcessorInputValidation">
            <summary>
            This class validates whether the fields in PostProcessorInput have been specified
            correctly or not.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessorInputValidation.ValidateInput(Vts.MonteCarlo.PostProcessorInput,System.String)">
            <summary>
            validate infile as well as overriding command line input
            </summary>
            <param name="input">PostProcessorInput file</param>
            <param name="inpath">command line option inpath</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.SimulationInputValidation">
            <summary>
            This sanity checks SimulationInput
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputValidation.ValidateInput(Vts.MonteCarlo.SimulationInput)">
            <summary>
            Master of call validation methods. Calls methods to validate source,
            tissue and detector definitions.
            </summary>
            <param name="input">SimulationInput to be validated</param>
            <returns>ValidationResult with IsValid bool set and message about error if false</returns>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputValidation.ValidateCombinedInputParameters(Vts.MonteCarlo.SimulationInput)">
            <summary>
            This method checks the input against combined combinations of options
            and source, tissue, detector definitions.   
            </summary>
            <param name="input">input to be validated</param>
            <returns>ValidationResult with IsValid set and error message if false</returns>
        </member>
        <member name="M:Vts.MonteCarlo.SimulationInputValidation.ValidateCurrentIncapabilities(Vts.MonteCarlo.SimulationInput)">
            <summary>
            Method checks SimulationInput against current incapabilities of the code.
            </summary>
            <param name="input">SimulationInput</param>
            <returns>ValidationResult</returns>
        </member>
        <member name="T:Vts.MonteCarlo.BoundingCylinderTissueInputValidation">
            <summary>
            This verifies that the bounding cylinder is the same height as the tissue,
            and that the refractive index of the tissue layer and ellipsoid match.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.BoundingCylinderTissueInputValidation.ValidateInput(Vts.MonteCarlo.ITissueInput)">
            <summary>
            Main validation method for BoundingCylinderTissueInput.
            </summary>
            <param name="input">tissue input defined in SimulationInput</param>
            <returns>ValidationResult</returns>
        </member>
        <member name="M:Vts.MonteCarlo.BoundingCylinderTissueInputValidation.ValidateGeometry(System.Collections.Generic.IList{Vts.MonteCarlo.Tissues.LayerTissueRegion},Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion)">
            <summary>
            Method to validate that the geometry of tissue layers and bounding cylinder agree with capabilities
            of code.
            </summary>
            <param name="layers">list of LayerTissueRegion</param>
            <param name="boundingCylinder">CylinderTissueRegion</param>
            <returns>ValidationResult</returns>
        </member>
        <member name="M:Vts.MonteCarlo.BoundingCylinderTissueInputValidation.ValidateRefractiveIndexMatch(System.Collections.Generic.IList{Vts.MonteCarlo.Tissues.LayerTissueRegion},Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion)">
            <summary>
            Method to verify refractive index of tissue layer and bounding cylinder match.
            Code does not yet include reflecting/refracting off bounding cylinder surface.
            </summary>
            <param name="layers">list of LayerTissueRegion</param>
            <param name="boundingCylinder">CylinderTissueRegion></param>
            <returns>ValidationResult</returns>
        </member>
        <member name="T:Vts.MonteCarlo.MultiLayerTissueInputValidation">
            <summary>
            This verifies the structure of a MultiLayerTissue
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.MultiLayerTissueInputValidation.ValidateInput(Vts.MonteCarlo.ITissueInput)">
            <summary>
            Method to validate that the tissue layers are contiguous and don't overlap
            </summary>
            <param name="input">tissue input in SimulationInput</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.MultiLayerTissueInputValidation.ValidateTopAndBottomLayersAreAir(System.Collections.Generic.IList{Vts.MonteCarlo.Tissues.LayerTissueRegion})">
            <summary>
            This verifies that the top and bottom layers are air.  The photon propagation algorithm in
            Photon class assumes that these layers are air and that the photon exits the domain
            after crossing into these layers and is no longer propagated.
            </summary>
            <param name="layers">list of LayerTissueRegion</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.MultiLayerTissueInputValidation.ValidateLayers(System.Collections.Generic.IList{Vts.MonteCarlo.Tissues.LayerTissueRegion})">
            <summary>
            This verifies that the layers do not overlap.  It assumes that the layers are
            adjacent and defined in order. Public because SimulationInputValidation calls it.
            This also checks that ZRange.Count = 2
            </summary>
            <param name="layers">list of LayerTissueRegion</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.SingleEllipsoidTissueInputValidation">
            <summary>
            This verifies that the ellipsoid is entirely contained within tissue layer,
            that only one tissue layer is defined, and that the refractive index of the
            tissue layer and ellipsoid match.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SingleEllipsoidTissueInputValidation.ValidateInput(Vts.MonteCarlo.ITissueInput)">
            <summary>
            Main validation method for SingleEllipsoidTissueInput.
            </summary>
            <param name="input">tissue input defined in SimulationInput</param>
            <returns>ValidationResult</returns>
        </member>
        <member name="M:Vts.MonteCarlo.SingleEllipsoidTissueInputValidation.ValidateGeometry(System.Collections.Generic.IList{Vts.MonteCarlo.Tissues.LayerTissueRegion},Vts.MonteCarlo.Tissues.EllipsoidTissueRegion)">
            <summary>
            Method to validate that the geometry of tissue layers and ellipsoid agree with capabilities
            of code.
            </summary>
            <param name="layers">list of LayerTissueRegion</param>
            <param name="ellipsoid">EllipsoidTissueRegion</param>
            <returns>ValidationResult</returns>
        </member>
        <member name="M:Vts.MonteCarlo.SingleEllipsoidTissueInputValidation.ValidateRefractiveIndexMatch(System.Collections.Generic.IList{Vts.MonteCarlo.Tissues.LayerTissueRegion},Vts.MonteCarlo.Tissues.EllipsoidTissueRegion)">
            <summary>
            Method to verify refractive index of tissue layer and ellipsoid match.
            Code does not yet include reflecting/refracting off ellipsoid surface.
            </summary>
            <param name="layers">list of LayerTissueRegion</param>
            <param name="ellipsoid">EllipsoidTissueRegion></param>
            <returns>ValidationResult</returns>
        </member>
        <member name="T:Vts.MonteCarlo.SingleVoxelTissueInputValidation">
            <summary>
            This verifies that the voxel is entirely contained within tissue layer,
            that only one tissue layer is defined, and that the refractive index of the
            tissue layer and voxel match.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.SingleVoxelTissueInputValidation.ValidateInput(Vts.MonteCarlo.ITissueInput)">
            <summary>
            Main validation method for SingleVoxelTissueInput.
            </summary>
            <param name="input">tissue input defined in SimulationInput</param>
            <returns>ValidationResult</returns>
        </member>
        <member name="M:Vts.MonteCarlo.SingleVoxelTissueInputValidation.ValidateGeometry(System.Collections.Generic.IList{Vts.MonteCarlo.Tissues.LayerTissueRegion},Vts.MonteCarlo.Tissues.VoxelTissueRegion)">
            <summary>
            Method to validate that the geometry of tissue layers and Voxel agree with capabilities
            of code.
            </summary>
            <param name="layers">list of LayerTissueRegion</param>
            <param name="Voxel">VoxelTissueRegion</param>
            <returns>ValidationResult</returns>
        </member>
        <member name="M:Vts.MonteCarlo.SingleVoxelTissueInputValidation.ValidateRefractiveIndexMatch(System.Collections.Generic.IList{Vts.MonteCarlo.Tissues.LayerTissueRegion},Vts.MonteCarlo.Tissues.VoxelTissueRegion)">
            <summary>
            Method to verify refractive index of tissue layer and Voxel match.
            Code does not yet include reflecting/refracting off Voxel surface.
            </summary>
            <param name="layers">list of LayerTissueRegion</param>
            <param name="Voxel">VoxelTissueRegion></param>
            <returns>ValidationResult</returns>
        </member>
        <member name="T:Vts.MonteCarlo.DataStructuresValidation.ValidationResult">
            <summary>
            Class that holds the result of validating the Monte Carlo inputs.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.DataStructuresValidation.ValidationResult.#ctor(System.Boolean,System.String,System.String)">
            <summary>
            class to capture results of validating the MC Simulation inputs
            </summary>
            <param name="isValid">boolean indicating whether input is valid</param>
            <param name="validationRule">rule governing whether valid or not</param>
            <param name="remarks">possible way to correct input to become valid</param>
        </member>
        <member name="M:Vts.MonteCarlo.DataStructuresValidation.ValidationResult.#ctor(System.Boolean,System.String)">
            <summary>
            overload omitting remarks
            </summary>
            <param name="isValid">boolean indicating whether input is valid</param>
            <param name="validationRule">fule governing whether valid or not</param>
        </member>
        <member name="M:Vts.MonteCarlo.DataStructuresValidation.ValidationResult.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.DataStructuresValidation.ValidationResult.IsValid">
            <summary>
            Boolean indicating whether result is valid or not
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.DataStructuresValidation.ValidationResult.ValidationRule">
            <summary>
            Rule that is being validated
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.DataStructuresValidation.ValidationResult.Remarks">
            <summary>
            Helpful remarks to correct violation
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.AOfRhoAndZDetectorInput">
            <summary>
            Tally for absorbed energy as a function of Rho and Z.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfRhoAndZDetectorInput.#ctor">
            <summary>
            constructor for absorbed energy as a function of rho and Z detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfRhoAndZDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfRhoAndZDetectorInput.Z">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfRhoAndZDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho and Z.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.Z">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfRhoAndZDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetectorInput">
            <summary>
            DetectorInput for Absorbed Energy(x,y,z)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetectorInput.#ctor">
            <summary>
            constructor for Absorbed Energy as a function of x, y and z detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector">
            <summary>
            Implements IDetector.  Tally for Absorbed Energy(x,y,z).
            Note: this tally currently only works with discrete absorption weighting and analog
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.Y">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.AOfXAndYAndZDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            method to determine if photon within detector, i.e. in NA, etc.
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetectorInput">
            <summary>
            Tally for total absorption in bounding volume.  This works like a reflectance
            tally rather than a IHistoryDetector because it tallies once the photon enters
            the bounding volume.
            This implementation works for Analog, DAW and CAW.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetectorInput.#ctor">
            <summary>
            constructor for absorption at bounding volume detector input
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetector">
            <summary>
            Implements IDetector.  Tally for total absorbed energy.
            This implementation works for Analog, DAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons are launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetector.GetBinarySerializers">
            <summary>
            this scalar tally is saved to json
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalBoundingVolumeDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ATotalDetectorInput">
            <summary>
            Tally for total absorption.
            This implementation works for Analog, DAW and CAW.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalDetectorInput.#ctor">
            <summary>
            constructor for total absorption detector input
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ATotalDetector">
            <summary>
            Implements IDetector.  Tally for total absorbed energy.
            This implementation works for Analog, DAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ATotalDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ATotalDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ATotalDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally a single photon collision
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">current tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons are launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalDetector.GetBinarySerializers">
            <summary>
            this scalar tally is saved to json
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ATotalDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.DetectorInput">
            <summary>
            detector input abstract class
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.DetectorInput.#ctor">
            <summary>
            default constructor for detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.DetectorInput.TallyType">
            <summary>
            tally type enum identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.DetectorInput.Name">
            <summary>
            tally name string
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.DetectorInput.TallySecondMoment">
            <summary>
            boolean indicating whether to tally 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.DetectorInput.TallyDetails">
            <summary>
            tally details describing aspects of detector, e.g. IsReflectanceTally
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.Detector">
            <summary>
            detector abstract class
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.Detector.#ctor">
            <summary>
            default constructor for detector
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.Detector.TallyType">
            <summary>
            tally type enum
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.Detector.Name">
            <summary>
            tally name string
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.Detector.TallySecondMoment">
            <summary>
            boolean indicating whether to tally 2nd moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.Detector.TallyDetails">
            <summary>
            tally details 
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetectorInput">
            <summary>
            Tally for dMC estimation of the derivative or reflectance with respect to mua as a function of Rho.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetectorInput.#ctor">
            <summary>
            constructor for pMC reflectance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetectorInput.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetectorInput.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of Rho.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.SetAbsorbAction(Vts.AbsorptionWeightingType)">
            <summary>
            Set the absorption to discrete or continuous
            </summary>
            <param name="awt">absorption weighting type</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMuaDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetectorInput">
            <summary>
            Tally for dMC estimation of the derivative or reflectance with respect to Mus as a function of Rho.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetectorInput.#ctor">
            <summary>
            constructor for pMC reflectance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetectorInput.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetectorInput.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of Rho.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">ITissue implementation</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.SetAbsorbAction(Vts.AbsorptionWeightingType)">
            <summary>
            Set the absorption to discrete or continuous
            </summary>
            <param name="awt">absorption weighting type</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.dMCdROfRhodMusDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetectorInput">
            <summary>
            DetectorInput for fluence as a function of spatial frequency fx and z
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetectorInput.#ctor">
            <summary>
            constructor for fluence as a function of Fx and Z detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetectorInput.Fx">
            <summary>
            detector Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetectorInput.Z">
            <summary>
            time binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Fx.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.Z">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfFxAndZDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetectorInput">
            <summary>
            DetectorInput for Fluence(rho, z, ft). Fluence in cylindrical coordinates and temporal-frequency.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetectorInput.#ctor">
            <summary>
            constructor for fluence as a function of rho, z and omega detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetectorInput.Omega">
            <summary>
            Omega binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector">
            <summary>
            Implements IDetector.  Tally for Fluence(x,y,z,omega).
            Note: this tally currently only works with discrete absorption weighting and analog
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.Omega">
            <summary>
            Omega binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndOmegaDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            method to determine if photon within detector, i.e. in NA, etc.
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetectorInput">
            <summary>
            Tally for Fluence as a function of Rho and Z and Time (theta).
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetectorInput.#ctor">
            <summary>
            constructor for Fluence as a function of rho, z and Time detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetectorInput.Z">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetectorInput.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector">
            <summary>
            Implements IDetector.  Tally for fluence as a function  of Rho, Z and Time.
            This implementation works for Analog, DAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.Z">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZAndTimeDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetectorInput">
            <summary>
            Tally for fluence as a function of Rho and Z.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetectorInput.#ctor">
            <summary>
            constructor for fluence as a function of rho and Z detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetectorInput.Z">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho and Z.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.Z">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfRhoAndZDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetectorInput">
            <summary>
            DetectorInput for Fluence(x,y,z,ft). Fluence in Cartesian coordinates and temporal-frequency.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetectorInput.#ctor">
            <summary>
            constructor for fluence as a function of x, y, z and omega detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetectorInput.Omega">
            <summary>
            Omega binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector">
            <summary>
            Implements IDetector.  Tally for Fluence(x,y,z,omega).
            Note: this tally currently only works with discrete absorption weighting and analog
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.Y">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.Omega">
            <summary>
            Omega binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndOmegaDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            method to determine if photon within detector, i.e. in NA, etc.
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetectorInput">
            <summary>
            DetectorInput for Fluence(x,y,z) and starting (x,y).  This detector
            captures Fluence(x,y,z) with respect to the initial tissue starting 
            location (x,y).  It was written for adjoint fluorescence simulations.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetectorInput.#ctor">
            <summary>
            constructor for fluence as a function of x, y and z detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetectorInput.StartingX">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetectorInput.StartingY">
            <summary>
            y binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector">
            <summary>
            Implements IDetector.  Tally for Fluence(x,y,z) and starting (x,y).
            Note: this tally currently only works with discrete absorption weighting and analog
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.Y">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.StartingX">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.StartingY">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.StartingXYCount">
            <summary>
            detector count of photons starting in each X-Y bin
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            for this detector normlization is based on number launched in starting
            x,y bin
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndStartingXAndYDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            method to determine if photon within detector, i.e. in NA, etc.
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetectorInput">
            <summary>
            DetectorInput for Fluence(x,y,z,t). Fluence in Cartesian coordinates and time.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetectorInput.#ctor">
            <summary>
            constructor for fluence as a function of x, y, z and time detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetectorInput.Time">
            <summary>
            Omega binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector">
            <summary>
            Implements IDetector.  Tally for Fluence(x,y,z,t).
            Note: this tally currently only works with discrete absorption weighting and analog
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.Y">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.Time">
            <summary>
            Omega binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZAndTimeDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            method to determine if photon within detector, i.e. in NA, etc.
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetectorInput">
            <summary>
            DetectorInput for Fluence(x,y,z)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetectorInput.#ctor">
            <summary>
            constructor for fluence as a function of x, y and z detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector">
            <summary>
            Implements IDetector.  Tally for Fluence(x,y,z).
            Note: this tally currently only works with discrete absorption weighting and analog
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.Y">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.FluenceOfXAndYAndZDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            method to determine if photon within detector, i.e. in NA, etc.
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCATotalDetectorInput">
            <summary>
            Tally for pMC estimation of total absorption currently *only for CAW*
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCATotalDetectorInput.#ctor">
            <summary>
            constructor for pMC reflectance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCATotalDetectorInput.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCATotalDetectorInput.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCATotalDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCATotalDetector">
            <summary>
            Implements IDetector.  Tally for pMC total absorption
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCATotalDetector.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCATotalDetector.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCATotalDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCATotalDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCATotalDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCATotalDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCATotalDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector 
            </summary>
            <param name="photon"></param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCATotalDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons are launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCATotalDetector.GetBinarySerializers">
            <summary>
            this scalar tally is saved to json
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCATotalDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA not applicable for ATotal
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetectorInput">
            <summary>
            Tally for pMC estimation of reflectance as a function of Fx.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetectorInput.#ctor">
            <summary>
            constructor for pMC reflectance as a function of Fx detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetectorInput.Fx">
            <summary>
            detector Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetectorInput.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetectorInput.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetectorInput.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of Fx.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxAndTimeDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfFxDetectorInput">
            <summary>
            Tally for pMC estimation of reflectance as a function of Fx.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxDetectorInput.#ctor">
            <summary>
            constructor for pMC reflectance as a function of Fx detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetectorInput.Fx">
            <summary>
            detector Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetectorInput.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetectorInput.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfFxDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of Fx.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetector.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetector.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetector.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfFxDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfFxDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA       
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetectorInput">
            <summary>
            Tally for pMC estimation of reflectance as a function of Rho and Time.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetectorInput.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetectorInput.PerturbedOps">
            <summary>
            perturbed optical properties listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetectorInput.PerturbedRegionsIndices">
            <summary>
            perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of Rho and Time.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.PerturbedOps">
            <summary>
            perturbed optical properties listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.PerturbedRegionsIndices">
            <summary>
            perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetectorInput">
            <summary>
            Tally for pMC estimation of reflectance as a function of Rho and Time recessed in air.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetectorInput.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetectorInput.ZPlane">
            <summary>
            z-plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetectorInput.PerturbedOps">
            <summary>
            perturbed optical properties listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetectorInput.PerturbedRegionsIndices">
            <summary>
            perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of Rho and Time.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.ZPlane">
            <summary>
            height above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.PerturbedOps">
            <summary>
            perturbed optical properties listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.PerturbedRegionsIndices">
            <summary>
            perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoAndTimeRecessedDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfRhoDetectorInput">
            <summary>
            Tally for pMC estimation of reflectance as a function of Rho.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoDetectorInput.#ctor">
            <summary>
            constructor for pMC reflectance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetectorInput.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetectorInput.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfRhoDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of Rho.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetectorInput">
            <summary>
            Tally for pMC estimation of reflectance as a function of Rho recessed in
            air a height ZPlane
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetectorInput.#ctor">
            <summary>
            constructor for pMC reflectance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetectorInput.ZPlane">
            <summary>
            z-plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetectorInput.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetectorInput.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of RhoRecessed.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.ZPlane">
            <summary>
            height above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfRhoRecessedDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetectorInput">
            <summary>
            Tally for pMC estimation of reflectance as a function of X, Y, Time and Subregion.
            Method tallies photon weight to time bin associated with pathlength in each region.
            Integrated R(x,y,t,subregion) will not integrate to R(x,y), independent array
            ROfXAndY used to determine this. Reference: Hiraoka93, Phys.Med.Biol.38 and
            Okada96, Appl. Opt. 35(19) -> the sum of the partial path lengths over all the
            medium is equivalent to the mean total path length (CH found this to be true)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of x,y,time,tissue region detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetectorInput.X">
            <summary>
            detector x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetectorInput.Y">
            <summary>
            detector y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetectorInput.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetectorInput.PerturbedOps">
            <summary>
            perturbed optical properties listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetectorInput.PerturbedRegionsIndices">
            <summary>
            perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of XAndY and Time.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.X">
            <summary>
            detector x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.Y">
            <summary>
            detector y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.ROfXAndY">
            <summary>
            total reflectance, needed to normalize partial differential path length
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.ROfXAndYSecondMoment">
            <summary>
            total reflectance 2nd moment, needed to normalize partial differential path length
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.NumberOfRegions">
            <summary>
            Number of tissue regions for serial/deserialization
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.PerturbedOps">
            <summary>
            perturbed optical properties listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.PerturbedRegionsIndices">
            <summary>
            perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput">
            <summary>
            Tally for pMC estimation of reflectance as a function of X, Y, Time and Subregion
            recessed in air.
            Method tallies photon weight to time bin associated with pathlength in each region.
            Integrated R(x,y,t,subregion) will not integrate to R(x,y), independent array
            ROfXAndY used to determine this. Reference: Hiraoka93, Phys.Med.Biol.38 and
            Okada96, Appl. Opt. 35(19) -> the sum of the partial path lengths over all the
            medium is equivalent to the mean total path length (CH found this to be true)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of x,y,time,tissue region detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput.X">
            <summary>
            detector x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput.Y">
            <summary>
            detector y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput.ZPlane">
            <summary>
            z-plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput.PerturbedOps">
            <summary>
            perturbed optical properties listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput.PerturbedRegionsIndices">
            <summary>
            perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of XAndY and Time.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.X">
            <summary>
            detector x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.Y">
            <summary>
            detector y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.ZPlane">
            <summary>
            z-plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.ROfXAndY">
            <summary>
            total reflectance, needed to normalize partial differential path length
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.ROfXAndYSecondMoment">
            <summary>
            total reflectance 2nd moment, needed to normalize partial differential path length
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.NumberOfRegions">
            <summary>
            Number of tissue regions for serial/deserialization
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.PerturbedOps">
            <summary>
            perturbed optical properties listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.PerturbedRegionsIndices">
            <summary>
            perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYAndTimeAndSubregionRecessedDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfXAndYDetectorInput">
            <summary>
            Tally for pMC estimation of reflectance as a function of X and Y.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetectorInput.X">
            <summary>
            detector x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetectorInput.PerturbedOps">
            <summary>
            perturbed optical properties listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetectorInput.PerturbedRegionsIndices">
            <summary>
            perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector">
            <summary>
            Implements IDetector.  Tally for pMC reflectance as a function  of X and Y.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.X">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.Y">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.PerturbedOps">
            <summary>
            perturbed optical properties listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.PerturbedRegionsIndices">
            <summary>
            perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCROfXAndYDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCTOfRhoDetectorInput">
            <summary>
            Tally for pMC estimation of transmittance as a function of Rho.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCTOfRhoDetectorInput.#ctor">
            <summary>
            constructor for pMC transmittance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetectorInput.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetectorInput.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCTOfRhoDetectorInput.CreateDetector">
            <summary>
            method to create detector
            </summary>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector">
            <summary>
            Implements IDetector.  Tally for pMC transmittance as a function  of Rho.
            This implementation works for DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.PerturbedOps">
            <summary>
            list of perturbed OPs listed in order of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.PerturbedRegionsIndices">
            <summary>
            list of perturbed regions indices
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            method to initialize detector 
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.pMCTOfRhoDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            pMC does not have access to PreviousDP so logic based on DP and 
            n1 sin(theta1) = n2 sin(theta2) 
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetectorInput">
            <summary>
            Tally for radiance as a function of Fx and Z and Angle (theta).
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetectorInput.#ctor">
            <summary>
            constructor for radiance as a function of fx, z and angle detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetectorInput.Fx">
            <summary>
            detector Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetectorInput.Z">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetectorInput.Angle">
            <summary>
            Angle binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector">
            <summary>
            Implements IDetector.  Tally for radiance as a function  of Fx and Z and Angle.
            This implementation works for Analog, DAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.Fx">
            <summary>
            detector Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.Z">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.Angle">
            <summary>
            Angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfFxAndZAndAngleDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetectorInput">
            <summary>
            Tally for radiance as a function of Rho and Z and Angle (theta).
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetectorInput.#ctor">
            <summary>
            constructor for radiance as a function of rho, z and angle detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetectorInput.Z">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetectorInput.Angle">
            <summary>
            Angle binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector">
            <summary>
            Implements IDetector.  Tally for radiance as a function  of Rho and Z and Angle.
            This implementation works for Analog, DAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.Z">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.Angle">
            <summary>
            Angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>none</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAndZAndAngleDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetectorInput">
            <summary>
            DetectorInput for Radiance(r) for internal surface detector at depth z.
            Detector captures radiance in downward direction through plane at depth z.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetectorInput.#ctor">
            <summary>
            constructor for radiance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetectorInput.ZDepth">
            <summary>
            constant defining surface of tally
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.ZDepth">
            <summary>
            constant defining surface of tally
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfRhoAtZDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetectorInput">
            <summary>
            DetectorInput for Radiance(x,y,z,theta,phi)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetectorInput.#ctor">
            <summary>
            constructor for Radiance as a function of x, y, z, theta and phi detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetectorInput.Theta">
            <summary>
            theta binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetectorInput.Phi">
            <summary>
            phi binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector">
            <summary>
            Implements IDetector.  Tally for Radiance(x,y,z).
            Note: this tally currently only works with discrete absorption weighting and analog
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.Y">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.Theta">
            <summary>
            theta binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.Phi">
            <summary>
            phi binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.SecondMoment">
            <summary>
            detector second moment
            </summary> 
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            method to tally given two consecutive photon data points
            </summary>
            <param name="previousDP">previous data point</param>
            <param name="dp">current data point</param>
            <param name="currentRegionIndex">index of region photon current is in</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RadianceOfXAndYAndZAndThetaAndPhiDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            method to determine if photon within detector, i.e. in NA, etc.
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RDiffuseDetectorInput">
            <summary>
            Tally for diffuse reflectance.
            This implementation works for Analog, DAW and CAW.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RDiffuseDetectorInput.#ctor">
            <summary>
            constructor for diffuse reflectance detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RDiffuseDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RDiffuseDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RDiffuseDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RDiffuseDetector">
            <summary>
            Implements IDetector.  Tally for diffuse reflectance.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RDiffuseDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RDiffuseDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RDiffuseDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RDiffuseDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RDiffuseDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RDiffuseDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RDiffuseDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RDiffuseDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons are launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RDiffuseDetector.GetBinarySerializers">
            <summary>
            this scalar tally is saved to json
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RDiffuseDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetectorInput">
            <summary>
            Tally for Reflected dynamic MT as a function of Fx using blood volume fraction in each tissue region.
            This detector also tallies the total and dynamic MT as a function of Z.  If a random number is less
            than blood volume fraction for the tissue region in which the collision occurred, then hit blood and considered
            "dynamic" event.  Otherwise, it is a "static" event.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor for ReflectedMT as a function of Fx and blood volume frac. in tissue subregion detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetectorInput.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetectorInput.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetectorInput.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetectorInput.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of Fx and tissue subregion
            using blood volume fraction in each tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.TotalMTOfZ">
            <summary>
            total MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.TotalMTOfZSecondMoment">
            <summary>
            total MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.DynamicMTOfZ">
            <summary>
            dynamic MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.DynamicMTOfZSecondMoment">
            <summary>
            dynamic MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.FractionalMT">
            <summary>
            fraction of DYNAMIC MT spent in tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.SubregionCollisions">
            <summary>
            number of dynamic and static collisions in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.TallyCount">
            <summary>
            number of tallies to detector
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.NumSubregions">
            <summary>
            number of tissue subregions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.TotalCollisions">
            <summary>
            number of total collisions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfFxAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput">
            <summary>
            Tally for Reflected dynamic MT as a function of Rho using blood volume fraction in each tissue region.
            This detector also tallies the total and dynamic MT as a function of Z.  If a random number is less
            than blood volume fraction for the tissue region in which the collision occurred, then hit blood and considered
            "dynamic" event.  Otherwise, it is a "static" event.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor for ReflectedMT as a function of rho and blood volume frac. in tissue subregion detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of Rho and tissue subregion
            using blood volume fraction in each tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.TotalMTOfZ">
            <summary>
            total MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.TotalMTOfZSecondMoment">
            <summary>
            total MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.DynamicMTOfZ">
            <summary>
            dynamic MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.DynamicMTOfZSecondMoment">
            <summary>
            dynamic MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.FractionalMT">
            <summary>
            fraction of DYNAMIC MT spent in tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.SubregionCollisions">
            <summary>
            number of dynamic and static collisions in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.TallyCount">
            <summary>
            number of tallies to detector
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.NumSubregions">
            <summary>
            number of tissue subregions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.TotalCollisions">
            <summary>
            total number of collisions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfRhoAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput">
            <summary>
            Tally for Reflected dynamic MT as a function of X and Y using blood volume fraction in each tissue region.
            This detector also tallies the total and dynamic MT as a function of Z.  If a random number is less
            than blood volume fraction for the tissue region in which the collision occurred, then hit blood and considered
            "dynamic" event.  Otherwise, it is a "static" event.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor for ReflectedMT as a function of rho and tissue Z detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of X, Y and tissue subregion
            using blood volume fraction in each tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.TotalMTOfZ">
            <summary>
            total MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.TotalMTOfZSecondMoment">
            <summary>
            total MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.DynamicMTOfZ">
            <summary>
            dynamic MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.DynamicMTOfZSecondMoment">
            <summary>
            dynamic MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.FractionalMT">
            <summary>
            fraction of DYNAMIC MT spent in tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.SubregionCollisions">
            <summary>
            number of dynamic and static collisions in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.NumSubregions">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedDynamicMTOfXAndYAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetectorInput">
            <summary>
            Tally for ReflectedMT as a function of Rho and Z.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor for ReflectedMT as a function of rho and tissue subregion detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetectorInput.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetectorInput.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of Rho and tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.FractionalMT">
            <summary>
            fraction of MT spent in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.NumSubregions">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfRhoAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetectorInput">
            <summary>
            Tally for ReflectedMT as a function of X and Y.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor for ReflectedMT as a function of x and y and tissue subregion detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetectorInput.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetectorInput.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of X and Y and tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.FractionalMT">
            <summary>
            fraction of MT spent in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.NumSubregions">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedMTOfXAndYAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetectorInput">
            <summary>
            Tally for ReflectedTime as a function of Rho and Z.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor for ReflectedTime as a function of rho and tissue subregion detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetectorInput.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of Rho and tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.Time">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.FractionalTimeBins">
            <summary>
            fractional time bins binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.FractionalTime">
            <summary>
            fraction of Time spent in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.NumSubregions">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally reflected photon by determining cumulative MT in each tissue subregion and binning in MT
            </summary>
            <param name="photon">Photon (includes HistoryData)</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize tally
            </summary>
            <param name="numPhotons">number of photons launched from source</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ReflectedTimeOfRhoAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfAngleDetectorInput">
            <summary>
            DetectorInput for reflectance as a function of angle
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfAngleDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of Angle detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfAngleDetectorInput.Angle">
            <summary>
            detector Angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfAngleDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfAngleDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfAngleDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfAngleDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Angle.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfAngleDetector.Angle">
            <summary>
            Angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfAngleDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfAngleDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfAngleDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfAngleDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfAngleDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfAngleDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfAngleDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfAngleDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfAngleDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfAngleDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetectorInput">
            <summary>
            DetectorInput for reflectance as a function of spatial frequency fx and exiting theta angle
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of Fx and Angle detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetectorInput.Fx">
            <summary>
            detector Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetectorInput.Angle">
            <summary>
            angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Fx and Angle.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.Angle">
            <summary>
            angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndAngleDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetectorInput">
            <summary>
            DetectorInput for reflectance as a function of spatial frequency fx and time
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of Fx and Time detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetectorInput.Fx">
            <summary>
            detector Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetectorInput.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Fx.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.Time">
            <summary>
            time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxAndTimeDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfFxDetectorInput">
            <summary>
            DetectorInput for reflectance as a function of spatial frequency fx
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of Fx detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxDetectorInput.Fx">
            <summary>
            detector Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfFxDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Fx.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxDetector.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfFxDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfFxDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetectorInput">
            <summary>
            Tally for reflectance as a function of Rho and Angle.
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of rho and angle detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetectorInput.Angle">
            <summary>
            angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho and Angle.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.Angle">
            <summary>
            angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndAngleDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetectorInput">
            <summary>
            Tally for reflectance as a function of Rho and MaxDepth.
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of rho and MaxDepth detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetectorInput.MaxDepth">
            <summary>
            MaxDepth binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho and MaxDepth.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.MaxDepth">
            <summary>
            MaxDepth binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetectorInput">
            <summary>
            Tally for reflectance as a function of Rho and MaxDepth recessed in air
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of rho and MaxDepth detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetectorInput.MaxDepth">
            <summary>
            MaxDepth binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetectorInput.ZPlane">
            <summary>
            z-plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho and MaxDepth.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.MaxDepth">
            <summary>
            MaxDepth binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.ZPlane">
            <summary>
            height above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndMaxDepthRecessedDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetectorInput">
            <summary>
            Tally for reflectance as a function of Rho and Omega.
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of rho and Omega detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetectorInput.Omega">
            <summary>
            Omega binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho and Omega.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.Omega">
            <summary>
            Omega binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndOmegaDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetectorInput">
            <summary>
            Tally for reflectance as a function of Rho and Time.
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of rho and Time detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetectorInput.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho and Time.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoAndTimeDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoDetectorInput">
            <summary>
            DetectorInput for R(r)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetectorInput">
            <summary>
            DetectorInput for R(r) recessed in air at a specified z plane
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetectorInput.ZPlane">
            <summary>
            height above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.ZPlane">
            <summary>
            z-plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfRhoRecessedDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetectorInput">
            <summary>
            Tally for reflectance as a function of X and Y and MaxDepth.
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of X and Y detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetectorInput.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetectorInput.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetectorInput.MaxDepth">
            <summary>
            MaxDepth binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of X and Y and MaxDepth.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.MaxDepth">
            <summary>
            MaxDepth binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.TallyCount">
            <summary>
            number of Ys detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetectorInput">
            <summary>
            Tally for reflectance as a function of X and Y and MaxDepth, recessed in air at z-plane
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of X and Y detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetectorInput.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetectorInput.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetectorInput.MaxDepth">
            <summary>
            MaxDepth binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetectorInput.ZPlane">
            <summary>
            z plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of X and Y and MaxDepth.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.MaxDepth">
            <summary>
            MaxDepth binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.ZPlane">
            <summary>
            z plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.TallyCount">
            <summary>
            number of Ys detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndMaxDepthRecessedDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetectorInput">
            <summary>
            DetectorInput for R(x,y,theta,phi)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetectorInput.#ctor">
            <summary>
            constructor for R as a function of x, y, theta and phi detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetectorInput.Theta">
            <summary>
            theta binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetectorInput.Phi">
            <summary>
            phi binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector">
            <summary>
            Implements IDetector.  Tally for R(x,y,theta,phi).
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.Y">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.Theta">
            <summary>
            theta binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.Phi">
            <summary>
            phi binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.FinalTissueRegionIndex">
            <summary>                                                   
            Detector region index                                                  
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.SecondMoment">
            <summary>
            detector second moment
            </summary> 
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndThetaAndPhiDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetectorInput">
            <summary>
            Tally for reflectance as a function of X and Y and Time and Subregion.
            This works for Analog, DAW and CAW processing.
            Method tallies photon weight to time bin associated with pathlength in each region.
            Integrated R(x,y,t,subregion) will not integrate to R(x,y), independent array
            ROfXAndY used to determine this. Reference: Hiraoka93, Phys.Med.Biol.38 and
            Okada96, Appl. Opt. 35(19) -> the sum of the partial path lengths over all the
            medium is equivalent to the mean total path length (CH found this to be true)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of X and Y detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetectorInput.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetectorInput.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetectorInput.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of X and Y and TimeAndSubregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.NumberOfRegions">
            <summary>
            Number of tissue regions for serial/deserialization
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.ROfXAndY">
            <summary>
            total reflectance, needed to normalize partial differential path length
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.ROfXAndYSecondMoment">
            <summary>
            total reflectance 2nd moment, needed to normalize partial differential path length
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.TallyCount">
            <summary>
            number of Ys detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetectorInput">
            <summary>
            Tally for reflectance as a function of X and Y and Time and Subregion recessed in air.
            This works for Analog, DAW and CAW processing.
            Method tallies photon weight to time bin associated with pathlength in each region.
            Integrated R(x,y,t,subregion) will not integrate to R(x,y), independent array
            ROfXAndY used to determine this. Reference: Hiraoka93, Phys.Med.Biol.38 and
            Okada96, Appl. Opt. 35(19) -> the sum of the partial path lengths over all the
            medium is equivalent to the mean total path length (CH found this to be true)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of X and Y detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetectorInput.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetectorInput.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetectorInput.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetectorInput.ZPlane">
            <summary>
            z plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of X and Y and TimeAndSubregionRecessed.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.ZPlane">
            <summary>
            z plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.ROfXAndY">
            <summary>
            total reflectance, needed to normalize partial differential path length
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.ROfXAndYSecondMoment">
            <summary>
            total reflectance 2nd moment, needed to normalize partial differential path length
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.NumberOfRegions">
            <summary>
            Number of tissue regions for serial/deserialization
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.TallyCount">
            <summary>
            number of Ys detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeAndSubregionRecessedDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetectorInput">
            <summary>
            Tally for reflectance as a function of X and Y and Time.
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of X and Y detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetectorInput.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetectorInput.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetectorInput.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of X and Y and Time.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.TallyCount">
            <summary>
            number of Ys detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetectorInput">
            <summary>
            Tally for reflectance as a function of X and Y and Time, recessed in air.
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of X and Y detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetectorInput.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetectorInput.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetectorInput.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetectorInput.ZPlane">
            <summary>
            z plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of X and Y and Time.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.ZPlane">
            <summary>
            z plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.TallyCount">
            <summary>
            number of Ys detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYAndTimeRecessedDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYDetectorInput">
            <summary>
            Tally for reflectance as a function of X and Y.
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of X and Y detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetectorInput.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetectorInput.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of X and Y.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetector.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetector.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetector.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYDetector.TallyCount">
            <summary>
            number of Ys detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetectorInput">
            <summary>
            Tally for reflectance as a function of X and Y recessed in air a specified z plane
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetectorInput.#ctor">
            <summary>
            constructor for reflectance as a function of X and Y detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetectorInput.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetectorInput.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetectorInput.ZPlane">
            <summary>
            z plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of X and Y.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.ZPlane">
            <summary>                              
            z-plane above tissue in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.TallyCount">
            <summary>
            number of Ys detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.ROfXAndYRecessedDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RSpecularDetectorInput">
            <summary>
            Tally for Specular reflectance.
            This implementation works for Analog, DAW and CAW.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RSpecularDetectorInput.#ctor">
            <summary>
            constructor for Specular reflectance detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RSpecularDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RSpecularDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RSpecularDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.RSpecularDetector">
            <summary>
            Implements IDetector.  Tally for Specular reflectance.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RSpecularDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RSpecularDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RSpecularDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RSpecularDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.RSpecularDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RSpecularDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RSpecularDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RSpecularDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons are launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RSpecularDetector.GetBinarySerializers">
            <summary>
            this scalar tally is saved to json
            </summary>
            <returns>null</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.RSpecularDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.SurfaceFiberDetectorInput">
            <summary>
            DetectorInput for an actual fiber detector. 
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.SurfaceFiberDetectorInput.#ctor">
            <summary>
            constructor for cylindrical surface fiber detector input. The fiber only detects as photon
            crosses bottom cap in an upward direction (negative z direction)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetectorInput.Center">
            <summary>
            detector center location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetectorInput.Radius">
            <summary>
            detector Radius
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetectorInput.N">
            <summary>
            detector fiber refractive index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.SurfaceFiberDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.SurfaceFiberDetector">
            <summary>
            Implements IDetector.  Tally for fiber detection.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.Center">
            <summary>
            detector center location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.Radius">
            <summary>
            detector Radius
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.N">
            <summary>
            detector fiber refractive index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.GetBinarySerializers">
            <summary>
            this scalar tally is saved to json
            </summary>
            <returns>null</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.SurfaceFiberDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TallyDetails">
            <summary>
            details for each detector that identifies type of detector
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IsReflectanceTally">
            <summary>
            boolean identifying all reflectance tallies
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IsTransmittanceTally">
            <summary>
            boolean identifying all transmittance tallies
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IsSpecularReflectanceTally">
            <summary>
            boolean identifying all specular reflectance tallies
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IsInternalSurfaceTally">
            <summary>
            boolean identifying all internal surface tallies
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IspMCReflectanceTally">
            <summary>
            boolean identifying all perturbation MC reflectance tallies
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IspMCTransmittanceTally">
            <summary>
            boolean identifying all perturbation MC transmittance tallies
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IsBoundingVolumeTally">
            <summary>
            boolean identifying all bounding volume tallies
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IsVolumeTally">
            <summary>
            boolean identifying all volume tallies
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IsCylindricalTally">
            <summary>
            boolean identifying whether detector is in cylindrical coordinates
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IsNotImplementedForDAW">
            <summary>
            boolean identifying whether detector is not implemented yet for DAW
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IsNotImplementedForCAW">
            <summary>
            boolean identifying whether detector is not implemented yet for CAW
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TallyDetails.IsNotImplementedYet">
            <summary>
            boolean identifying whether detector is not implemented yet
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TDiffuseDetectorInput">
            <summary>
            Tally for diffuse transmittance.
            This implementation works for Analog, DAW and CAW.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TDiffuseDetectorInput.#ctor">
            <summary>
            constructor for diffuse transmittance detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TDiffuseDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TDiffuseDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TDiffuseDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TDiffuseDetector">
            <summary>
            Implements IDetector.  Tally for diffuse transmittance.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TDiffuseDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TDiffuseDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TDiffuseDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TDiffuseDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TDiffuseDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TDiffuseDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TDiffuseDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TDiffuseDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after numPhotons are launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TDiffuseDetector.GetBinarySerializers">
            <summary>
            this scalar tally is saved to json
            </summary>
            <returns>null</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TDiffuseDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfAngleDetectorInput">
            <summary>
            DetectorInput for R(r)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfAngleDetectorInput.#ctor">
            <summary>
            constructor for transmittance as a function of Angle detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfAngleDetectorInput.Angle">
            <summary>
            detector Angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfAngleDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfAngleDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfAngleDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfAngleDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Angle.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfAngleDetector.Angle">
            <summary>
            Angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfAngleDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfAngleDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfAngleDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfAngleDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfAngleDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfAngleDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfAngleDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfAngleDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfAngleDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfAngleDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfFxDetectorInput">
            <summary>
            DetectorInput for transmittance as a function of spatial frequency fx
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfFxDetectorInput.#ctor">
            <summary>
            constructor for transmittance as a function of Fx detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfFxDetectorInput.Fx">
            <summary>
            detector Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfFxDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfFxDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfFxDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfFxDetector">
            <summary>
            Implements IDetector.  Tally for transmittance as a function  of Fx.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfFxDetector.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfFxDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfFxDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfFxDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfFxDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfFxDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfFxDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfFxDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfFxDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfFxDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfFxDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetectorInput">
            <summary>
            Tally for reflectance as a function of Rho and Angle.
            This works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetectorInput.#ctor">
            <summary>
            constructor for transmittance as a function of rho and angle detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetectorInput.Angle">
            <summary>
            angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho and Angle.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.Angle">
            <summary>
            angle binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoAndAngleDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfRhoDetectorInput">
            <summary>
            DetectorInput for T(r)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoDetectorInput.#ctor">
            <summary>
            constructor for transmittance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoDetectorInput.Rho">
            <summary>
            detector rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfRhoDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of Rho.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfRhoDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfRhoDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetectorInput">
            <summary>
            Tally for transmittance as a function of X and Y and Time and Subregion.
            This works for Analog, DAW and CAW processing.
            Method tallies photon weight to time bin associated with pathlength in each region.
            Integrated T(x,y,t,subregion) will not integrate to T(x,y), independent array
            TOfXAndY used to determine this. Reference: Hiraoka93, Phys.Med.Biol.38
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetectorInput.#ctor">
            <summary>
            constructor for transmittance as a function of X and Y detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetectorInput.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetectorInput.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetectorInput.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetectorInput.NA">
            <summary>
            detector numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector">
            <summary>
            Implements IDetector.  Tally for transmittance as a function  of X and Y and TimeAndSubregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.X">
            <summary>
            X binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.Y">
            <summary>
            Y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.Time">
            <summary>
            Time binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.NumberOfRegions">
            <summary>
            Number of tissue regions for serial/deserialization
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.TOfXAndY">
            <summary>
            total transmittance, needed to normalize partial differential path length
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.TOfXAndYSecondMoment">
            <summary>
            total transmittance 2nd moment, needed to normalize partial differential path length
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.TallyCount">
            <summary>
            number of Ys detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYAndTimeAndSubregionDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfXAndYDetectorInput">
            <summary>
            DetectorInput for T(x,y)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYDetectorInput.#ctor">
            <summary>
            constructor for transmittance as a function of rho detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetectorInput.X">
            <summary>
            detector x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetectorInput.Y">
            <summary>
            detector y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TOfXAndYDetector">
            <summary>
            Implements IDetector.  Tally for reflectance as a function  of X and Y.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetector.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TOfXAndYDetector.TallyCount">
            <summary>
            number of times detector gets tallied to
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector tally results
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TOfXAndYDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput">
            <summary>
            Tally for Transmitted dynamic MT as a function of Fx using blood volume fraction in each tissue region.
            This detector also tallies the total and dynamic MT as a function of Z.   If a random number is less
            than blood volume fraction for the tissue region in which the collision occurred, then hit blood and considered
            "dynamic" event.  Otherwise, it is a "static" event.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor for TransmittedMT as a function of fx and tissue subregion detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput.SubregionCollisions">
            <summary>
            number of dynamic and static collisions in each subregion
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of Fx and tissue subregion
            using blood volume fraction in each tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.Fx">
            <summary>
            Fx binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.TotalMTOfZ">
            <summary>
            total MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.TotalMTOfZSecondMoment">
            <summary>
            total MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.DynamicMTOfZ">
            <summary>
            dynamic MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.DynamicMTOfZSecondMoment">
            <summary>
            dynamic MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.FractionalMT">
            <summary>
            fraction of DYNAMIC MT spent in tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.SubregionCollisions">
            <summary>
            number of dynamic and static collisions in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.TallyCount">
            <summary>
            number of tallies to detector
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.NumSubregions">
            <summary>
            number of tissue subregions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.ContainsPoint(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to determine if photon is within detector
            </summary>
            <param name="dp">photon data point</param>
            <returns>method always returns true</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfFxAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput">
            <summary>
            Tally for Transmitted dynamic MT as a function of Rho using blood volume fraction in each tissue region.
            This detector also tallies the total and dynamic MT as a function of Z.   If a random number is less
            than blood volume fraction for the tissue region in which the collision occurred, then hit blood and considered
            "dynamic" event.  Otherwise, it is a "static" event.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor for TransmittedMT as a function of rho and tissue subregion detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput.SubregionCollisions">
            <summary>
            number of dynamic and static collisions in each subregion
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of Rho and tissue subregion
            using blood volume fraction in each tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.TotalMTOfZ">
            <summary>
            total MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.TotalMTOfZSecondMoment">
            <summary>
            total MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.DynamicMTOfZ">
            <summary>
            dynamic MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.DynamicMTOfZSecondMoment">
            <summary>
            dynamic MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.FractionalMT">
            <summary>
            fraction of DYNAMIC MT spent in tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.SubregionCollisions">
            <summary>
            number of dynamic and static collisions in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.NumSubregions">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfRhoAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput">
            <summary>
            Tally for Transmited dynamic MT as a function of X and Y using blood volume fraction in each tissue region.
            This detector also tallies the total and dynamic MT as a function of Z.   If a random number is less
            than blood volume fraction for the tissue region in which the collision occurred, then hit blood and considered
            "dynamic" event.  Otherwise, it is a "static" event.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor for TransmittedMT as a function of rho and tissue subregion detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.SubregionCollisions">
            <summary>
            number of dynamic and static collisions in each subregion
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of X, Y and tissue subregion
            using blood volume fraction in each tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.Z">
            <summary>
            z binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.BloodVolumeFraction">
            <summary>
            subregion blood volume fraction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.TotalMTOfZ">
            <summary>
            total MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.TotalMTOfZSecondMoment">
            <summary>
            total MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.DynamicMTOfZ">
            <summary>
            dynamic MT as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.DynamicMTOfZSecondMoment">
            <summary>
            dynamic MT Second Moment as a function of Z multiplied by final photon weight
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.FractionalMT">
            <summary>
            fraction of DYNAMIC MT spent in tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.SubregionCollisions">
            <summary>
            number of dynamic and static collisions in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.NumSubregions">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedDynamicMTOfXAndYAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetectorInput">
            <summary>
            Tally for TransmittedMT as a function of Rho and Z.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor for TransmittedMT as a function of rho and tissue subregion detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetectorInput.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetectorInput.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetectorInput.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of Rho and tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.Rho">
            <summary>
            rho binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.FractionalMT">
            <summary>
            fraction of MT spent in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.NumSubregions">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfRhoAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetectorInput">
            <summary>
            Tally forTransmittedMT as a function of X and Y.
            This works for Analog and DAW processing.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetectorInput.#ctor">
            <summary>
            constructor forTransmittedMT as a function of x and y and tissue subregion detector input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetectorInput.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetectorInput.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetectorInput.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetectorInput.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetectorInput.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetectorInput.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetectorInput.CreateDetector">
            <summary>
            Method to create detector from detector input
            </summary>
            <returns>created IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector">
            <summary>
            Implements IDetector.  Tally for momentum transfer as a function  of X and Y and tissue subregion.
            This implementation works for Analog, DAW and CAW processing.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.X">
            <summary>
            x binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.Y">
            <summary>
            y binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.MTBins">
            <summary>
            momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.FractionalMTBins">
            <summary>
            fractional momentum transfer binning
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.FinalTissueRegionIndex">
            <summary>
            Detector region index
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.NA">
            <summary>
            numerical aperture
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.Mean">
            <summary>
            detector mean
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.SecondMoment">
            <summary>
            detector second moment
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.FractionalMT">
            <summary>
            fraction of MT spent in each subregion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.TallyCount">
            <summary>
            number of Zs detector gets tallied to
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.NumSubregions">
            <summary>
            Z binning
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to initialize detector
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            method to tally to detector
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.Normalize(System.Int64)">
            <summary>
            method to normalize detector results after all photons launched
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.GetBinarySerializers">
            <summary>
            this is to allow saving of large arrays separately as a binary file
            </summary>
            <returns>BinaryArraySerializer[]</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Detectors.TransmittedMTOfXAndYAndSubregionHistDetector.IsWithinDetectorAperture(Vts.MonteCarlo.Photon)">
            <summary>
            Method to determine if photon is within detector NA
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="T:Vts.MonteCarlo.Extensions.DatabaseExtensionMethods">
            <summary>
            Methods used to determine type of virtual boundary.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.DatabaseExtensionMethods.IspMCDatabase(Vts.MonteCarlo.DatabaseType)">
            <summary>
            Method to determine if perturbation Monte Carlo (pMC) database specified or not
            </summary>
            <param name="databaseType">database type</param>
            <returns>true if pMC VB, false if not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.DatabaseExtensionMethods.GetCorrespondingVirtualBoundaryType(Vts.MonteCarlo.DatabaseType)">
            <summary>
            Method to provide VirtualBoundaryType corresponding to DatabaseType
            </summary>
            <param name="databaseType">database type</param>
            <returns>corresponding virtual boundary type</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Extensions.ITissueRegionExtensions">
            <summary>
            extension methods for ITissueRegion classes
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.ITissueRegionExtensions.IsAir(Vts.MonteCarlo.ITissueRegion)">
            <summary>
            Method to determine if tissue region is air or not.
            </summary>
            <param name="region">tissue region</param>
            <returns>boolean</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Extensions.PhotonDataExtensionMethods">
            <summary>
            Methods used to write to surface or volume virtual boundary databases
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.PhotonDataExtensionMethods.WriteToPMCSurfaceVirtualBoundaryDatabases(System.Collections.Generic.IList{Vts.MonteCarlo.PhotonData.CollisionInfoDatabaseWriter},Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.CollisionInfo)">
            <summary>
            Method to write to pMC surface VB databases, calls singular method below for a list.
            </summary>
            <param name="collisionInfoDatabaseWriters">list of CollisionInfoDatabaseWriters</param>
            <param name="dp">PhotonDataPoint</param>
            <param name="collisionInfo">CollisionInfo</param>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.PhotonDataExtensionMethods.WriteToPMCSurfaceVirtualBoundaryDatabase(Vts.MonteCarlo.PhotonData.CollisionInfoDatabaseWriter,Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.CollisionInfo)">
            <summary>
            Method to write to pMC surface VB database
            </summary>
            <param name="collisionInfoDatabaseWriter">CollisionInfoDatabaseWriter</param>
            <param name="dp">PhotonDataPoint</param>
            <param name="collisionInfo">CollisionInfo</param>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.PhotonDataExtensionMethods.BelongsToSurfaceVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.CollisionInfoDatabaseWriter)">
            <summary>
            method to determine whether photon database belongs to surface virtual boundary
            </summary>
            <param name="dp">photon data point</param>
            <param name="collisionInfoDatabaseWriter">collision info database writer</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.PhotonDataExtensionMethods.IsWithinNA(Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Double,Vts.Common.Direction,System.Double)">
            <summary>
            method to determine whether photon direction is within NA of detector
            </summary>
            <param name="dp">photon data point</param>
            <param name="detectorNA">numerical aperture of detector</param>
            <param name="detectorNormal">normal Direction of detector</param>
            <param name="n">refractive index of region where the detector resides</param>
            <returns>boolean</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Extensions.SimulationInputExtensions">
            <summary>
            Methods to aid in setting up Monte Carlo simulation input values. 
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.SimulationInputExtensions.WithValue(Vts.MonteCarlo.SimulationInput,System.String,System.Double)">
            <summary>
            Method to overwrite data in SimulationInput.  Used in MC CommandLineApplication 
            paramsweep and paramsweepdelta.
            </summary>
            <param name="data">base SimulationInput</param>
            <param name="inputParameter">parameter in SimulationInput to be overwritten</param>
            <param name="value">value of parameter</param>
            <returns>updated SimulationInput with new data</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.SimulationInputExtensions.WithParameterSweep(System.Collections.Generic.IEnumerable{Vts.MonteCarlo.SimulationInput},System.Collections.Generic.IEnumerable{System.Double},System.String)">
            <summary>
            Method to perform parameter sweeps of data and create new SimulationInput with each data
            value in sweep.
            </summary>
            <param name="input">base SimulationInput</param>
            <param name="values">values to be used</param>
            <param name="inputParameterType">parameter identifier</param>
            <returns>updated IEnumerable of SimulationInput</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Extensions.StatisticsExtensions">
            <summary>
            Methods to help track statistics in the Monte Carlo simulation
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.StatisticsExtensions.TrackDeathStatistics(Vts.MonteCarlo.SimulationStatistics,Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to determine statistics about how the photon died.
            </summary>
            <param name="statistics">SimulationStatistics class where statistics are kept</param>
            <param name="dp">PhotonDataPoint</param>
            <returns>Updated SimulationStatistics</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Extensions.VirtualBoundariesExtensionMethods">
            <summary>
            Methods used to determine type of virtual boundary.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.VirtualBoundariesExtensionMethods.IsSurfaceVirtualBoundary(Vts.MonteCarlo.VirtualBoundaryType)">
            <summary>
            Method to determine whether VB is Surface VB or not
            </summary>
            <param name="virtualBoundaryType">VB type</param>
            <returns>true if surface VB, false if not </returns>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.VirtualBoundariesExtensionMethods.IsVolumeVirtualBoundary(Vts.MonteCarlo.VirtualBoundaryType)">
            <summary>
            Method to determine if VB is volume VB or not
            </summary>
            <param name="virtualBoundaryType">VB type</param>
            <returns>true if volume VB, false if not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.VirtualBoundariesExtensionMethods.IsReflectanceSurfaceVirtualBoundary(Vts.MonteCarlo.VirtualBoundaryType)">
            <summary>
            Method to determine if VB is surface reflectance VB or not
            </summary>
            <param name="virtualBoundaryType">VB type</param>
            <returns>true of surface reflectance VB, false if not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.VirtualBoundariesExtensionMethods.IsTransmittanceSurfaceVirtualBoundary(Vts.MonteCarlo.VirtualBoundaryType)">
            <summary>
            Method to determine if transmittance surface VB or not
            </summary>
            <param name="virtualBoundaryType">VB type</param>
            <returns>true if transmittance surface VB, false if not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.VirtualBoundariesExtensionMethods.IsSpecularSurfaceVirtualBoundary(Vts.MonteCarlo.VirtualBoundaryType)">
            <summary>
            Method to determine if specular surface VB or not
            </summary>
            <param name="virtualBoundaryType">VB type</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.VirtualBoundariesExtensionMethods.IsDosimetryVirtualBoundary(Vts.MonteCarlo.VirtualBoundaryType)">
            <summary>
            Method to determine if dosimetry VB or not
            </summary>
            <param name="virtualBoundaryType">VB type </param>
            <returns>true if internal surface VB, false if not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.VirtualBoundariesExtensionMethods.IsGenericVolumeVirtualBoundary(Vts.MonteCarlo.VirtualBoundaryType)">
            <summary>
            Method to determine if generic volume VB or not
            </summary>
            <param name="virtualBoundaryType">VB type</param>
            <returns>true if generic volume VB, false if not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Extensions.VirtualBoundariesExtensionMethods.IspMCVirtualBoundary(Vts.MonteCarlo.VirtualBoundaryType)">
            <summary>
            Method to determine if perturbation Monte Carlo (pMC) VB or not
            </summary>
            <param name="virtualBoundaryType">VB type</param>
            <returns>true if pMC VB, false if not</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Factories.DatabaseWriterFactory">
            <summary>
            Factory methods to provide the PhotonDatabaseWriter (or list of PhotonDatabaseWriters)
            or CollisionInfoDatabaseWriter (or list).
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.DatabaseWriterFactory.GetSurfaceVirtualBoundaryDatabaseWriters(System.Collections.Generic.IList{Vts.MonteCarlo.DatabaseType},System.String,System.String)">
            <summary>
            Static method to provide a list of PhotonDatabaseWriters.  It calls the method
            to instantiate one PhotonDatabaseWriter, GetSurfaceVirtualBoundaryDatabaseWriter,
            for all elements in the list of virtual boundary DatabaseType.
            </summary>
            <param name="databaseTypes">list of database types</param>
            <param name="filePath">path string for database output</param>
            <param name="outputName">name string of output</param>
            <returns>a list of PhotonDatabaseWriter</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.DatabaseWriterFactory.GetSurfaceVirtualBoundaryDatabaseWriter(Vts.MonteCarlo.DatabaseType,System.String,System.String)">
            <summary>
            Static method to instantiate correct PhotonDatabaseWriter given a 
            virtual boundary DatabaseType, path to where to output database and database filename.
            </summary>
            <param name="databaseType">database type enum</param>
            <param name="filePath">path string of database output</param>
            <param name="outputName">filename string of database file</param>
            <returns>a PhotonDatabaseWriter</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.DatabaseWriterFactory.GetCollisionInfoDatabaseWriters(System.Collections.Generic.IList{Vts.MonteCarlo.DatabaseType},Vts.MonteCarlo.ITissue,System.String,System.String)">
            <summary>
            Static method to provide list of CollisionInfoDatabaseWriters.  It calls the method
            to instantiate one CollisionInfoDatabaseWriter, GetCollisionInfoDatabaseWriter,
            for all elements in the list of virtual boundary DatabaseType. 
            </summary>
            <param name="databaseTypes">list of database types</param>
            <param name="tissue">ITissue needed to instantiate Writer to know how many regions</param>
            <param name="filePath">path string of database output</param>
            <param name="outputName">filename string of output file</param>
            <returns>a list of CollisionInfoDatabaseWriter</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.DatabaseWriterFactory.GetCollisionInfoDatabaseWriter(Vts.MonteCarlo.DatabaseType,Vts.MonteCarlo.ITissue,System.String,System.String)">
            <summary>
            Static method to instantiate correct CollisionInfoDatabaseWriter given a 
            virtual boundary DatabaseType, path to where to output database and database filename.
            </summary>
            <param name="databaseType">database type enum</param>
            <param name="tissue">ITissue to know how many regions</param>
            <param name="filePath">path string of database output</param>
            <param name="outputName">filename string of database file</param>
            <returns>a CollisionInfoDatabaseWriter</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Factories.DetectorControllerFactory">
            <summary>
            factory to handle instantiation of detector controllers
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.DetectorControllerFactory.GetDetectorController(Vts.MonteCarlo.VirtualBoundaryType,System.Collections.Generic.IEnumerable{Vts.MonteCarlo.IDetector},Vts.MonteCarlo.ITissue)">
            <summary>
            method that returns an IDetectorController given the VBType, list of detectors and tissue
            </summary>
            <param name="virtualBoundaryType">virtual boundary type</param>
            <param name="detectors">IEnumerable of IDetector</param>
            <param name="tissue">ITissue</param>
            <returns>IDetectorController</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Factories.DetectorFactory">
            <summary>
            Instantiates appropriate detector tally given TallyType.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.DetectorFactory.GetDetectors(System.Collections.Generic.IEnumerable{Vts.MonteCarlo.IDetectorInput},Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to instantiate all detectors given list of IDetectorInputs.  This method calls
            the method below that instantiates a single detector.
            </summary>
            <param name="detectorInputs">IEnumerable of IDetectorInput</param>
            <param name="tissue">ITissue</param>
            <param name="rng">random number generator</param>
            <returns>List of IDetector</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.DetectorFactory.GetDetector(Vts.MonteCarlo.IDetectorInput,Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Method to instantiate a single IDetectorInput.  This method is called by
            the method below that instantiates a list of detectors.
            </summary>
            <param name="detectorInput">IEnumerable of IDetectorInput</param>
            <param name="tissue">ITissue</param>
            <param name="rng">random number generator</param>
            <returns>List of IDetector</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.DetectorFactory.RegisterDetector(System.Type,System.Type)">
            <summary>
            method to register detector: currently not used
            </summary>
            <param name="detectorInputType">type of detector input</param>
            <param name="detectorType">type of detector</param>
        </member>
        <member name="T:Vts.MonteCarlo.Factories.PhotonDatabaseFactory">
            <summary>
            Factory methods for PhotonDatabase class
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.PhotonDatabaseFactory.GetPhotonDatabase(Vts.MonteCarlo.VirtualBoundaryType,System.String)">
            <summary>
            Method to read photon database from file
            </summary>
            <param name="virtualBoundaryType">VB type</param>
            <param name="filePath">path to database file</param>
            <returns>PhotonDatabase read</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.PhotonDatabaseFactory.GetpMCDatabase(Vts.MonteCarlo.VirtualBoundaryType,System.String)">
            <summary>
            Method to read perturbation Monte Carlo (pMC) photon database from file
            </summary>
            <param name="virtualBoundaryType">VB type</param>
            <param name="filePath">path to database file</param>
            <returns>PhotonDatabase read</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Factories.RandomNumberGeneratorFactory">
            <summary>
            Class containing factory methods returning random number generator instances
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.RandomNumberGeneratorFactory.GetRandomNumberGenerator(Vts.RandomNumberGeneratorType)">
            <summary>
            Returns an instance of the desired random number generator with random seeding
            </summary>
            <param name="type">RandomNumberGeneratorType</param>
            <returns>Random</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.RandomNumberGeneratorFactory.GetRandomNumberGenerator(Vts.RandomNumberGeneratorType,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Returns an instance of the desired random number generator
            </summary>
            <param name="type">RandomNumberGeneratorType enum</param>
            <param name="seed">integer seed for the RNG, seed=-1 -> random seed, otherwise seeded with input seed</param>
            <param name="index">The </param>
            <returns>Random</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Factories.SourceFactory">
            <summary>
            Instantiates appropriate source given a ISourceInput, ITissue
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.SourceFactory.GetSource(Vts.MonteCarlo.ISourceInput,System.Random)">
            <summary>
            Method to instantiate the correct source given ISourceInput
            </summary>
            <param name="input">ISourceInput</param>
            <param name="rng">random number generator instance</param>
            <returns>ISource</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Factories.TissueFactory">
            <summary>
            Instantiates appropriate ITissue given ITissueInput.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.TissueFactory.GetTissue(Vts.MonteCarlo.ITissueInput,Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Method to return ITissue given inputs
            </summary>
            <param name="ti">ITissueInput</param>
            <param name="awt">AbsorptionWeightingType enum</param>
            <param name="pft">PhaseFunctionType enum</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette weight threshold</param>
            <returns>ITissue</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Factories.VirtualBoundaryFactory">
            <summary>
            Instantiates appropriate virtual boundary.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Factories.VirtualBoundaryFactory.GetVirtualBoundary(Vts.MonteCarlo.VirtualBoundaryType,Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetectorController)">
            <summary>
            method that gets appropriate VB 
            </summary>
            <param name="vbType">VirtualBoundaryType</param>
            <param name="tissue">ITissue</param>
            <param name="detectorController">IDetectorController</param>
            <returns>IVirtualBoundary</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.CylinderTissueRegionToolbox">
            <summary>
            Helper methods for  cylindrical tissue region methods.  For example, ray intersect infinite cylinder of given axis alignment
            and ray intersect finite cylinder.  Currently this method only makes sense with our current tissue classes, if axis alignment
            is along x- or y- axes because if along z-axis will intersect tissue surface and bottom.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CylinderTissueRegionToolbox.RayIntersectInfiniteCylinder(Vts.Common.Position,Vts.Common.Position,System.Boolean,Vts.MonteCarlo.CylinderTissueRegionAxisType,Vts.Common.Position,System.Double,System.Double@)">
            <summary>
            method to determine if photon ray (or track) will intersect boundary of cylinder
            equations to determine intersection are derived by parameterizing ray from p1 to p2
            as p2=p1+[dx dy dz]t t in [0,1] where dx=p2.x-p1.x dy=p2.y-p1.y dz=p2.z-p2.z
            and substituting into cylinder equations and solving quadratic in t, i.e. t1, t2
            t1,t2 less than 0 or t1,t2 greater than 1 => no intersection
            0 less than t1 less than 1 => one intersection
            0 less than t2 less than 1 => one intersections, if above line true too => two intersections
            </summary>
            <param name="p1">ray starting position</param>
            <param name="p2">ray ending position</param>
            <param name="oneIn">boolean indicating whether p1 is inside infinite cylinder</param>
            <param name="axis">axis of cylinder: CylinderTissueRegionAxisType.X, Y or Z</param>
            <param name="center">position of center of cylinder</param>
            <param name="radius">radius of cylinder</param>
            <param name="distanceToBoundary">return: distance to boundary, infinity if no intersection</param>
            <returns>boolean: true if intersection, false if on boundary of cylinder</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.LayerTissueRegionToolbox">
            <summary>
            Helper methods for  layer tissue region methods.  For example, ray intersect infinite plane
            at z=constant
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.LayerTissueRegionToolbox.RayExtendToInfinitePlane(Vts.Common.Position,Vts.Common.Direction,System.Double)">
            <summary>
            This extends photon ray from position and angle of exit from tissue into air
            up to plane specified by zPlane
            </summary>
            <param name="p">position of photon exit</param>
            <param name="d">direction of photon exit</param>
            <param name="zPlane">z-plane above tissue in air, must be negative value</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.BoundedTissue">
            <summary>
            Implements ITissue.  Defines a tissue geometry comprised of a layered slab bounded laterally by a TissueRegion.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundedTissue.#ctor(Vts.MonteCarlo.ITissueRegion,System.Collections.Generic.IList{Vts.MonteCarlo.ITissueRegion})">
            <summary>
            Creates an instance of a SingleInclusionTissue
            </summary>
            <param name="boundingRegion">Tissue region defining later extent of tissue (must span top to bottom of tissue layers)</param>
            <param name="layerRegions">The tissue layers</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundedTissue.#ctor">
            <summary>
            Creates a default instance of a BoundingTissue
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundedTissue.GetRegionIndex(Vts.Common.Position)">
            <summary>
            method to get tissue region index of photon's current position
            </summary>
            <param name="position">photon Position</param>
            <returns>integer tissue region index</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundedTissue.GetDistanceToBoundary(Vts.MonteCarlo.Photon)">
            <summary>
            method to get distance from current photon position and direction to boundary of region
            </summary>
            <param name="photon">Photon</param>
            <returns>distance to boundary</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundedTissue.OnDomainBoundary(Vts.Common.Position)">
            <summary>
            method to determine if on boundary of tissue, i.e. at tissue/air interface
            </summary>
            <param name="position">photon position</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundedTissue.GetNeighborRegionIndex(Vts.MonteCarlo.Photon)">
            <summary>
            method to get index of neighbor tissue region when photon on boundary of two regions
            </summary>
            <param name="photon">Photon</param>
            <returns>index of neighbor index</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundedTissue.GetPhotonDataPointStateOnExit(Vts.Common.Position)">
            <summary>
            method to determine photon state type of photon exiting tissue boundary
            </summary>
            <param name="position"></param>
            <returns>PhotonStateType</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundedTissue.GetReflectedDirection(Vts.Common.Position,Vts.Common.Direction)">
            <summary>
            method that provides reflected direction when phton reflects off boundary
            </summary>
            <param name="currentPosition">Position</param>
            <param name="currentDirection">Direction</param>
            <returns>new Direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundedTissue.GetRefractedDirection(Vts.Common.Position,Vts.Common.Direction,System.Double,System.Double,System.Double)">
            <summary>
            method that provides refracted direction when photon refracts off boundary
            </summary>
            <param name="currentPosition">Position</param>
            <param name="currentDirection">Direction</param>
            <param name="currentN">refractive index N of current tissue region</param>
            <param name="nextN">refractive index N of next tissue region</param>
            <param name="cosThetaSnell">cosine of theta per Snell's</param>
            <returns>new Direction</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.BoundingCylinderTissueInput">
            <summary>
            Implements ITissueInput.  Defines input to BoundingCylinderTissue class which is comprised of
            multilayer tissue bounded laterally by *vertical* cylinder
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundingCylinderTissueInput.#ctor(Vts.MonteCarlo.ITissueRegion,Vts.MonteCarlo.ITissueRegion[])">
            <summary>
            allows definition of tissue bounded by capless cylinder height of tissue
            </summary>
            <param name="caplessCylinderRegion">bounding vertical cylinder region specification</param>
            <param name="layerRegions">tissue layer specification</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundingCylinderTissueInput.#ctor">
            <summary>
            BoundingCylinderTissueInput default constructor provides homogeneous tissue with bounding cylinder
            with radius 0.5mm and center (0,0,1)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.BoundingCylinderTissueInput.Regions">
            <summary>
            regions of tissue (layers and ellipsoid)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.BoundingCylinderTissueInput.CylinderRegion">
            <summary>
            tissue capless cylinder region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.BoundingCylinderTissueInput.LayerRegions">
            <summary>
            tissue layer regions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.BoundingCylinderTissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion">
            <summary>
            Implements ITissueRegion.  Defines cylindrical region with axis along
            z-axis and dimensions
            Center, Radius and Height with NO CAPS (used for BoundingCylinderTissue).
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.#ctor(Vts.Common.Position,System.Double,System.Double,Vts.OpticalProperties)">
            <summary>
            CaplessCylinderTissueRegion assumes cylinder axis is parallel with z-axis
            </summary>
            <param name="center">center position</param>
            <param name="radius">radius in x-y plane</param>
            <param name="height">height along z axis</param>
            <param name="op">optical properties of cylinder</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.TissueRegionType">
            <summary>
            tissue region identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.Center">
            <summary>
            center of cyliner
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.Radius">
            <summary>
            radius of cylinder
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.Height">
            <summary>
            height of cylinder
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.RegionOP">
            <summary>
            optical properties of cylinder
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.ContainsPosition(Vts.Common.Position)">
            <summary>
            method to determine if photon position within or on cylinder
            </summary>
            <param name="position">photon position</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.OnBoundary(Vts.Common.Position)">
            <summary>
            Method to determine if photon on boundary of cylinder.
            </summary>
            <param name="position">photon position</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.RayIntersectBoundary(Vts.MonteCarlo.Photon,System.Double@)">
            <summary>
            method to determine if photon ray (or track) will intersect boundary of cylinder
            without caps
            </summary>
            <param name="photon">photon position, direction, etc.</param>
            <param name="distanceToBoundary">distance to boundary</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CaplessCylinderTissueRegion.SurfaceNormal(Vts.Common.Position)">
            <summary>
            method to determine normal to surface at given position
            </summary>
            <param name="position"></param>
            <returns>Direction</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.CylinderTissueRegion">
            <summary>
            Implements ITissueRegion.  Defines cylindrical region finite along z-axis with Center at (xc,yc,zc)
            Radius and Height where cylinder caps on planes (zc-Height/2) and (zc+Height/2).
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CylinderTissueRegion.#ctor(Vts.Common.Position,System.Double,System.Double,Vts.OpticalProperties)">
            <summary>
            CylinderTissueRegion assumes cylinder axis is parallel with z-axis
            </summary>
            <param name="center">center position</param>
            <param name="radius">radius in x-y plane</param>
            <param name="height">height along z axis</param>
            <param name="op">optical properties of cylinder</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CylinderTissueRegion.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.CylinderTissueRegion.TissueRegionType">
            <summary>
            tissue region identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.CylinderTissueRegion.Center">
            <summary>
            center of cylinder
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.CylinderTissueRegion.Radius">
            <summary>
            radius of cylinder
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.CylinderTissueRegion.Height">
            <summary>
            height of cylinder
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.CylinderTissueRegion.RegionOP">
            <summary>
            optical properties of cylinder
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CylinderTissueRegion.ContainsPosition(Vts.Common.Position)">
            <summary>
            Method to determine if photon position within or on cylinder.  This works if height=0
            as long as Center.Z=0;
            </summary>
            <param name="position">photon position</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CylinderTissueRegion.OnBoundary(Vts.Common.Position)">
            <summary>
            Method to determine if photon on boundary of cylinder.
            Currently OnBoundary of an inclusion region isn't called by any code ckh 3/5/19.
            </summary>
            <param name="position">photon position</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CylinderTissueRegion.RayIntersectBoundary(Vts.MonteCarlo.Photon,System.Double@)">
            <summary>
            Method to determine if photon ray (or track) will intersect boundary of cylinder
            equations to determine intersection are derived by parameterizing ray from p1 to p2
            as p2=p1+[dx dy dz]t t in [0,1] where dx=p2.x-p1.x dy=p2.y-p1.y dz=p2.z-p2.z
            and substituting into ellipsoid equations and solving quadratic in t, i.e. t1, t2
            t1,t2 less than 0 or t1,t2 greater than 1 => no intersection
            0 less than t1 less than 1 => one intersection
            0 less than t2 less than 1 => one intersections, if above line true too => two intersections
            Equations obtained from pdf at https://mrl.nyu.edu/~dzorin/rendering/lectures/lecture3/lecture3-6pp.pdf
            and modified to assume cylinder finite along z-axis with caps in x-y planes.
            Note: can't vouch for this code yet, especially if photon intersects sides AND cap
            </summary>
            <param name="photon">photon position, direction, etc.</param>
            <param name="distanceToBoundary">distance to boundary</param>
            <returns>boolean indicating intersection or not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.CylinderTissueRegion.SurfaceNormal(Vts.Common.Position)">
            <summary>
            method to determine normal to surface at given position
            </summary>
            <param name="position"></param>
            <returns>Direction</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion">
            <summary>
            Implements ITissueRegion.  Defines ellipsiod given Center, and Axis
            radii along x,y,z axis.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.#ctor(Vts.Common.Position,System.Double,System.Double,System.Double,Vts.OpticalProperties)">
            <summary>
            class specifies ellipsoid tissue region (x-xc)^2/a^2 + (y-yc)^2/b^2 + (z-zc)^2/c^2 = 1
            where center is (xc,yc,zc) and semi-axis along x-, y-, z- axes are a, b, c, respectively.
            </summary>
            <param name="center">Position (x,y,z) of the center of the ellipsoid</param>
            <param name="radiusX">semi-axis along x-axis</param>
            <param name="radiusY">semi-axis along y-axis</param>
            <param name="radiusZ">semi-axis along z-axis</param>
            <param name="op">OpticalProperties of ellipsoid</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.#ctor">
            <summary>
            default constructor defines sphere with radius 0.5mm and center (0,0,1)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.TissueRegionType">
            <summary>
            tissue region identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.RegionOP">
            <summary>
            optical properties of ellipsoid
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.Center">
            <summary>
            center of ellipsoid
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.Dx">
            <summary>
            distance from center to x-axis radius
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.Dy">
            <summary>
            distance from center to y-axis radius
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.Dz">
            <summary>
            distance from center to z-axis radius
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.ContainsPosition(Vts.Common.Position)">
            <summary>
            method to determine if given Position lies within ellipsoid allows for floating point imprecision
            </summary>
            <param name="position">Position</param>
            <returns>boolean, true if within or on, false otherwise</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.OnBoundary(Vts.Common.Position)">
            <summary>
            Method to determine if given Position lies on boundary of ellipsoid.
            Currently OnBoundary of an inclusion region isn't called by any code ckh 3/5/19.
            </summary>
            <param name="position">position to be checked</param>
            <returns>true if on boundary, false otherwise</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.SurfaceNormal(Vts.Common.Position)">
            <summary>
            method to determine normal to surface at given position. Note this returns outward facing normal.
            </summary>
            <param name="position">position of surface normal</param>
            <returns>direction of normal</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.EllipsoidTissueRegion.RayIntersectBoundary(Vts.MonteCarlo.Photon,System.Double@)">
            <summary>
            method to determine if photon track or ray intersects boundary of ellipsoid
            equations to determine intersection are derived by parameterizing ray from p1 to p2
            as p2=p1+[dx dy dz]t t in [0,1] where dx=p2.x-p1.x dy=p2.y-p1.y dz=p2.z-p2.z
            and substituting into ellipsoid equations and solving quadratic in t, i.e. t1, t2
            t1,t2 less than 0 or t1,t2 greater than 1 => no intersection
            0 less than t1 less than 1 => one intersection
            0 less than t2 less than 1 => one intersections, if above line true too => two intersections
            </summary>
            <param name="photon">Photon</param>
            <param name="distanceToBoundary">return: distance to boundary, infinity if no intersection</param>
            <returns>boolean true if intersection, false otherwise</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion">
            <summary>
            Implements ITissueRegion.  Defines cylindrical region infinite along y-axis with center at (xc,zc).
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion.#ctor(Vts.Common.Position,System.Double,Vts.OpticalProperties)">
            <summary>
            CylinderTissueRegion assumes cylinder axis is parallel with z-axis
            </summary>
            <param name="center">center position</param>
            <param name="radius">radius in x-y plane</param>
            <param name="op">optical properties of cylinder</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion.TissueRegionType">
            <summary>
            tissue region identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion.Center">
            <summary>
            center of cylinder
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion.Radius">
            <summary>
            radius of cylinder
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion.RegionOP">
            <summary>
            optical properties of cylinder
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion.ContainsPosition(Vts.Common.Position)">
            <summary>
            Method to determine if photon position within or on cylinder.  The loss of precision in floating
            point operations necessitates the checks of if "inside" is close but not exact
            </summary>
            <param name="position">photon position</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion.OnBoundary(Vts.Common.Position)">
            <summary>
            Method to determine if photon on boundary of infinite cylinder.
            Currently OnBoundary of an inclusion region isn't called by any code ckh 3/5/19.
            </summary>
            <param name="position">photon position</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion.SurfaceNormal(Vts.Common.Position)">
            <summary>
            method to determine normal to surface at given position. Note this returns outward facing normal.
            </summary>
            <param name="position"></param>
            <returns>Direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.InfiniteCylinderTissueRegion.RayIntersectBoundary(Vts.MonteCarlo.Photon,System.Double@)">
            <summary>
            Method to determine if photon ray (or track) will intersect boundary of cylinder
            equations to determine intersection are derived by parameterizing ray from p1 to p2
            as p2=p1+[dx dy dz]t t in [0,1] where dx=p2.x-p1.x dy=p2.y-p1.y dz=p2.z-p2.z
            and substituting into ellipsoid equations and solving quadratic in t, i.e. t1, t2
            t1,t2 less than 0 or t1,t2 greater than 1 => no intersection
            0 less than t1 less than 1 => one intersection
            0 less than t2 less than 1 => one intersections, if above line true too => two intersections
            Equations obtained from pdf at https://mrl.nyu.edu/~dzorin/rendering/lectures/lecture3/lecture3-6pp.pdf
            and modified to assume cylinder infinite along y-axis
            </summary>
            <param name="photon">photon position, direction, etc.</param>
            <param name="distanceToBoundary">return: distance to boundary</param>
            <returns>boolean</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.LayerTissueRegion">
            <summary>
            Implements ITissueRegion.  Defines a layer infinite in extent along
            x,y-axes and with extent along z-axis given by ZRange.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.LayerTissueRegion.#ctor(Vts.Common.DoubleRange,Vts.OpticalProperties)">
            <summary>
            constructor for layer region
            </summary>
            <param name="zRange">specifies extent of layer</param>
            <param name="op">optical properties of layer</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.LayerTissueRegion.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.LayerTissueRegion.TissueRegionType">
            <summary>
            tissue region identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.LayerTissueRegion.ZRange">
            <summary>
            extent of z layer
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.LayerTissueRegion.RegionOP">
            <summary>
            optical properties of layer
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.LayerTissueRegion.Center">
            <summary>
            center of layer
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.LayerTissueRegion.ContainsPosition(Vts.Common.Position)">
            <summary>
            This checks which region photon is currently in.  
            inclusion defined in half-open interval [start,stop) so that continuum of layers do not overlap.
            </summary>
            <param name="position">Position being checked</param>
            <returns>True if photon in region, false if not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.LayerTissueRegion.OnBoundary(Vts.Common.Position)">
            <summary>
            Method to determine if photon on layer boundary.  Needed to determine which boundary photon is
            on when layer region contains inclusion.  Errors in Position accommodated for in test.
            </summary>
            <param name="position">Position being checked</param>
            <returns>True if photon on boundary, false if not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.LayerTissueRegion.SurfaceNormal(Vts.Common.Position)">
            <summary>
            method to determine normal to surface at given position
            </summary>
            <param name="position"></param>
            <returns>Direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.LayerTissueRegion.RayIntersectBoundary(Vts.MonteCarlo.Photon,System.Double@)">
            <summary>
            Method to determine if photon track or ray intersects layer boundary.
            Note: LayerTissueRegion.RayIntersectBoundary does NOT use photon.S in the calculation
            so all photons (unless horizontal) intersect the top or bottom of the layer and the
            returned distance is not infinity (unless horizontal).  This is because MonteCarloSimulation
            uses the distance to the boundary without intersection in its processing.
            This is different that all other TissueRegions.  
            </summary>
            <param name="photon">Photon</param>
            <param name="distanceToBoundary">return: distance to boundary, actual distance if no intersection</param>
            <returns>true if intersection, false otherwise</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissueInput">
            <summary>
            Implements ITissueInput.  Defines input to MultiConcentricInfiniteCylinderTissue class.
            This assumes infinite cylinders are concentric and lie entirely within a layer.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissueInput.#ctor(Vts.MonteCarlo.ITissueRegion[],Vts.MonteCarlo.ITissueRegion[])">
            <summary>
            constructor for Multi-ConcentricInfiniteCylinder tissue input
            </summary>
            <param name="infiniteCylinderRegions">concentric cylinder regions, larger radius first</param>
            <param name="layerRegions">layer regions</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissueInput.#ctor">
            <summary>
            MultiConcentricInfiniteCylinderTissue default constructor provides homogeneous tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissueInput.Regions">
            <summary>
            list of tissue regions comprising tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissueInput.InfiniteCylinderRegions">
            <summary>
            tissue outer infinite cylinder region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissueInput.LayerRegions">
            <summary>
            tissue layer regions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue">
            <summary>
            Implements ITissue.  Defines tissue geometries comprised of layers
            (including homogenous with air layers above and below).  Layers are infinite along
            x- and y- axes.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue.#ctor(System.Collections.Generic.IList{Vts.MonteCarlo.ITissueRegion},System.Collections.Generic.IList{Vts.MonteCarlo.ITissueRegion})">
            <summary>
            Creates an instance of a MultiConcentricInfiniteCylinderTissue
            </summary>
            <param name="infiniteCylinderRegions">list of cylinder regions</param>
            <param name="layerRegions">list of layer regions</param>
            <remarks>air above and below tissue needs to be specified for a slab geometry</remarks>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue.#ctor">
            <summary>
            Creates a default instance of a MultiConcentricInfiniteCylinderTissue based on a homogeneous medium slab geometry
            and discrete absorption weighting
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue.GetRegionIndex(Vts.Common.Position)">
            <summary>
            method to determine region index of region photon is currently in
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue.GetDistanceToBoundary(Vts.MonteCarlo.Photon)">
            <summary>
            Finds the distance to the next boundary and independent of hitting it
            </summary>
            <param name="photon"></param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue.OnDomainBoundary(Vts.Common.Position)">
            <summary>
            method to determine if on boundary of tissue, i.e. at tissue/air interface
            </summary>
            <param name="position">photon position</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue.GetNeighborRegionIndex(Vts.MonteCarlo.Photon)">
            <summary>
            method to determine index of region photon is about to enter
            </summary>
            <param name="photon">photon info including position and direction</param>
            <returns>region index</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue.GetPhotonDataPointStateOnExit(Vts.Common.Position)">
            <summary>
            method to determine photon state type of photon exiting tissue boundary
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue.GetReflectedDirection(Vts.Common.Position,Vts.Common.Direction)">
            <summary>
            method to determine direction of reflected photon
            </summary>
            <param name="currentPosition"></param>
            <param name="currentDirection"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue.GetRefractedDirection(Vts.Common.Position,Vts.Common.Direction,System.Double,System.Double,System.Double)">
            <summary>
            method to determine refracted direction of photon
            </summary>
            <param name="currentPosition">current photon position</param>
            <param name="currentDirection">current photon direction</param>
            <param name="currentN">refractive index of current region</param>
            <param name="nextN">refractive index of next region</param>
            <param name="cosThetaSnell">cos(theta) resulting from Snell's law</param>
            <returns>direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiConcentricInfiniteCylinderTissue.GetAngleRelativeToBoundaryNormal(Vts.MonteCarlo.Photon)">
            <summary>
            method to get cosine of the angle between photons current direction and boundary normal
            </summary>
            <param name="photon"></param>
            <returns>Uz=cos(theta)</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.MultiEllipsoidTissueInput">
            <summary>
            Implements ITissueInput.  Defines input to SingleEllipsoidTissue class.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiEllipsoidTissueInput.#ctor(Vts.MonteCarlo.ITissueRegion[],Vts.MonteCarlo.ITissueRegion[])">
            <summary>
            allows definition of single ellipsoid tissue
            </summary>
            <param name="ellipsoidRegions">ellipsoid region specification</param>
            <param name="layerRegions">tissue layer specification</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiEllipsoidTissueInput.#ctor">
            <summary>
            SingleEllipsoidTissueInput default constructor provides homogeneous tissue with single ellipsoid
            with radius 0.5mm and center (0,0,1)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.MultiEllipsoidTissueInput.Regions">
            <summary>
            regions of tissue (layers and ellipsoid)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.MultiEllipsoidTissueInput.EllipsoidRegions">
            <summary>
            tissue ellipsoid region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.MultiEllipsoidTissueInput.LayerRegions">
            <summary>
            tissue layer regions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiEllipsoidTissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.MultiLayerTissueInput">
            <summary>
            Implements ITissueInput.  Defines input to MultiLayerTissue class.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissueInput.#ctor(Vts.MonteCarlo.ITissueRegion[])">
            <summary>
            constructor for Multi-layer tissue input
            </summary>
            <param name="regions">list of tissue regions comprising tissue</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissueInput.#ctor">
            <summary>
            MultiLayerTissue default constructor provides homogeneous tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.MultiLayerTissueInput.Regions">
            <summary>
            list of tissue regions comprising tissue
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.MultiLayerTissue">
            <summary>
            Implements ITissue.  Defines tissue geometries comprised of layers
            (including homogenous with air layers above and below).  Layers are infinite along
            x- and y- axes.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissue.#ctor(System.Collections.Generic.IList{Vts.MonteCarlo.ITissueRegion})">
            <summary>
            Creates an instance of a MultiLayerTissue
            </summary>
            <param name="regions">list of tissue regions comprising tissue</param>
            <remarks>air above and below tissue needs to be specified for a slab geometry</remarks>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissue.#ctor">
            <summary>
            Creates a default instance of a MultiLayerTissue based on a homogeneous medium slab geometry
            and discrete absorption weighting
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissue.GetRegionIndex(Vts.Common.Position)">
            <summary>
            method to determine region index of region photon is currently in
            </summary>
            <param name="position">photon position</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissue.GetDistanceToBoundary(Vts.MonteCarlo.Photon)">
            <summary>
            Finds the distance to the next boundary and independent of hitting it
            </summary>
            <param name="photon">photon</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissue.OnDomainBoundary(Vts.Common.Position)">
            <summary>
            method to determine if on boundary of tissue, i.e. at tissue/air interface
            </summary>
            <param name="position">photon position</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissue.GetNeighborRegionIndex(Vts.MonteCarlo.Photon)">
            <summary>
            method to determine index of region photon is about to enter
            </summary>
            <param name="photon">photon info including position and direction</param>
            <returns>region index</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissue.GetPhotonDataPointStateOnExit(Vts.Common.Position)">
            <summary>
            method to determine photon state type of photon exiting tissue boundary
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissue.GetReflectedDirection(Vts.Common.Position,Vts.Common.Direction)">
            <summary>
            method to determine direction of reflected photon
            </summary>
            <param name="currentPosition"></param>
            <param name="currentDirection"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissue.GetRefractedDirection(Vts.Common.Position,Vts.Common.Direction,System.Double,System.Double,System.Double)">
            <summary>
            method to determine refracted direction of photon
            </summary>
            <param name="currentPosition">current photon position</param>
            <param name="currentDirection">current photon direction</param>
            <param name="currentN">refractive index of current region</param>
            <param name="nextN">refractive index of next region</param>
            <param name="cosThetaSnell">cos(theta) resulting from Snell's law</param>
            <returns>direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerTissue.GetAngleRelativeToBoundaryNormal(Vts.MonteCarlo.Photon)">
            <summary>
            method to get cosine of the angle between photons current direction and boundary normal
            </summary>
            <param name="photon"></param>
            <returns>Uz=cos(theta)</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissueInput">
            <summary>
            Implements ITissueInput.  Defines input to MultiLayerTissueWithSurfaceFiber class.
            This class is not created using SingleInclusionTissue.  Instead it is designed like
            MultiLayerTissue so that Photon CrossRegionOrReflect can ask
            int neighborIndex = _tissue.GetNeighborRegionIndex(this);
            double nNext = _tissue.Regions[neighborIndex].RegionOP.N;
            and get the detector N when the photon is residing in the fiber circle.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissueInput.#ctor(Vts.MonteCarlo.ITissueRegion,Vts.MonteCarlo.ITissueRegion[])">
            <summary>
            constructor for Multi-layer tissue with surface fiber circle input
            </summary>
            <param name="surfaceFiberRegion">surface fiber region defining area and characteristics of detector fiber</param>
            <param name="layerRegions">list of tissue regions comprising tissue</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissueInput.#ctor">
            <summary>
            MultiLayerTissue default constructor provides homogeneous tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissueInput.Regions">
            <summary>
            regions of tissue (layers and surface fiber circle)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissueInput.SurfaceFiberRegion">
            <summary>
            surface fiber region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissueInput.LayerRegions">
            <summary>
            tissue layer regions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue">
            <summary>
            Implements ITissue.  Defines tissue geometries comprised of layers
            (including homogenous with air layers above and below).  Layers are infinite along
            x- and y- axes.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue.#ctor(Vts.MonteCarlo.ITissueRegion,System.Collections.Generic.IList{Vts.MonteCarlo.ITissueRegion})">
            <summary>
            Creates an instance of a MultiLayerSurfaceFiberTissue
            </summary>
            <param name="surfaceFiberRegion">circular surface fiber region and characteristics</param>
            <param name="layerRegions">list of tissue regions comprising tissue</param>
            <remarks>air above and below tissue needs to be specified for a slab geometry</remarks>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue.#ctor">
            <summary>
            Creates a default instance of a MultiLayerTissue based on a homogeneous medium slab geometry
            and discrete absorption weighting
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue.GetRegionIndex(Vts.Common.Position)">
            <summary>
            method to determine region index of region photon is currently in
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue.GetDistanceToBoundary(Vts.MonteCarlo.Photon)">
            <summary>
            Finds the distance to the next boundary and independent of hitting it
            </summary>
            <param name="photon"></param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue.OnDomainBoundary(Vts.Common.Position)">
            <summary>
            method to determine if on boundary of tissue, i.e. at tissue/air interface
            </summary>
            <param name="position">photon position</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue.GetNeighborRegionIndex(Vts.MonteCarlo.Photon)">
            <summary>
            method to determine index of region photon is about to enter
            </summary>
            <param name="photon">photon info including position and direction</param>
            <returns>region index</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue.GetPhotonDataPointStateOnExit(Vts.Common.Position)">
            <summary>
            method to determine photon state type of photon exiting tissue boundary
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue.GetReflectedDirection(Vts.Common.Position,Vts.Common.Direction)">
            <summary>
            method to determine direction of reflected photon
            </summary>
            <param name="currentPosition"></param>
            <param name="currentDirection"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue.GetRefractedDirection(Vts.Common.Position,Vts.Common.Direction,System.Double,System.Double,System.Double)">
            <summary>
            method to determine refracted direction of photon
            </summary>
            <param name="currentPosition">current photon position</param>
            <param name="currentDirection">current photon direction</param>
            <param name="currentN">refractive index of current region</param>
            <param name="nextN">refractive index of next region</param>
            <param name="cosThetaSnell">cos(theta) resulting from Snell's law</param>
            <returns>direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.MultiLayerWithSurfaceFiberTissue.GetAngleRelativeToBoundaryNormal(Vts.MonteCarlo.Photon)">
            <summary>
            method to get cosine of the angle between photons current direction and boundary normal
            </summary>
            <param name="photon"></param>
            <returns>Uz=cos(theta)</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.SemiInfiniteTissueInput">
            <summary>
            Implements ITissueInput.  Defines input to SemiInfiniteTissueInput class.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SemiInfiniteTissueInput.#ctor(Vts.MonteCarlo.ITissueRegion)">
            <summary>
            constructor for Semi-infinite tissue input
            </summary>
            <param name="region">tissue region info</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SemiInfiniteTissueInput.#ctor">
            <summary>
            SemiInfiniteTissueInput default constructor provides homogeneous tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SemiInfiniteTissueInput.Regions">
            <summary>
            list of tissue regions comprising tissue
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SemiInfiniteTissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.SemiInfiniteTissueRegion">
            <summary>
            Implements ITissueRegion.  Defines a layer infinite in extent along
            x,y-axes and with extent along z-axis given by ZRange.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SemiInfiniteTissueRegion.#ctor(Vts.OpticalProperties)">
            <summary>
            constructor for SemiInfiniteTissueRegion
            </summary>
            <param name="op">optical properties of layer</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SemiInfiniteTissueRegion.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SemiInfiniteTissueRegion.TissueRegionType">
            <summary>
            tissue region identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SemiInfiniteTissueRegion.RegionOP">
            <summary>
            optical properties of layer
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SemiInfiniteTissueRegion.Center">
            <summary>
            Center of tissue region (semi-infinite has no center)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SemiInfiniteTissueRegion.ContainsPosition(Vts.Common.Position)">
            <summary>
            This checks which region photon is currently in.  
            inclusion defined in half-open interval [start,stop) so that continuum of layers do not overlap.
            </summary>
            <param name="position">Position being checked</param>
            <returns>True if photon in region, false if not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SemiInfiniteTissueRegion.OnBoundary(Vts.Common.Position)">
            <summary>
            Method to determine if photon on layer boundary.  Needed to determine which boundary photon is
            on when layer region contains inclusion.  Errors in Position accommodated for in test.
            </summary>
            <param name="position">Position being checked</param>
            <returns>True if photon on boundary, false if not</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SemiInfiniteTissueRegion.SurfaceNormal(Vts.Common.Position)">
            <summary>
            method to determine normal to surface at given position
            </summary>
            <param name="position"></param>
            <returns>Direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SemiInfiniteTissueRegion.RayIntersectBoundary(Vts.MonteCarlo.Photon,System.Double@)">
            <summary>
            method to determine if photon track or ray intersects layer boundary
            </summary>
            <param name="photon">Photon</param>
            <param name="distanceToBoundary">return distance to boundary</param>
            <returns>true if intersection, false otherwise</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.SingleCylinderTissueInput">
            <summary>
            Implements ITissueInput.  Defines input to SingleCylinderTissue class.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleCylinderTissueInput.#ctor(Vts.MonteCarlo.ITissueRegion,Vts.MonteCarlo.ITissueRegion[])">
            <summary>
            allows definition of single cylinder tissue
            </summary>
            <param name="cylinderRegion">cylinder region specification</param>
            <param name="layerRegions">tissue layer specification</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleCylinderTissueInput.#ctor">
            <summary>
            SingleCylinderTissueInput default constructor provides homogeneous tissue with single Cylinder
            with radius 0.5mm and center (0,0,1)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleCylinderTissueInput.Regions">
            <summary>
            regions of tissue (layers and Cylinder)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleCylinderTissueInput.CylinderRegion">
            <summary>
            tissue Cylinder region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleCylinderTissueInput.LayerRegions">
            <summary>
            tissue layer regions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleCylinderTissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.SingleEllipsoidTissueInput">
            <summary>
            Implements ITissueInput.  Defines input to SingleEllipsoidTissue class.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleEllipsoidTissueInput.#ctor(Vts.MonteCarlo.ITissueRegion,Vts.MonteCarlo.ITissueRegion[])">
            <summary>
            allows definition of single ellipsoid tissue
            </summary>
            <param name="ellipsoidRegion">ellipsoid region specification</param>
            <param name="layerRegions">tissue layer specification</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleEllipsoidTissueInput.#ctor">
            <summary>
            SingleEllipsoidTissueInput default constructor provides homogeneous tissue with single ellipsoid
            with radius 0.5mm and center (0,0,1)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleEllipsoidTissueInput.Regions">
            <summary>
            regions of tissue (layers and ellipsoid)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleEllipsoidTissueInput.EllipsoidRegion">
            <summary>
            tissue ellipsoid region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleEllipsoidTissueInput.LayerRegions">
            <summary>
            tissue layer regions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleEllipsoidTissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.SingleInclusionTissue">
            <summary>
            Implements ITissue.  Defines a tissue geometry comprised of an
            inclusion embedded within a layered slab.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleInclusionTissue.#ctor(Vts.MonteCarlo.ITissueRegion,System.Collections.Generic.IList{Vts.MonteCarlo.ITissueRegion})">
            <summary>
            Creates an instance of a SingleInclusionTissue
            </summary>
            <param name="inclusionRegion">The single inclusion (must be contained completely within a layer region)</param>
            <param name="layerRegions">The tissue layers</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleInclusionTissue.#ctor">
            <summary>
            Creates a default instance of a SingleInclusionTissue
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleInclusionTissue.GetRegionIndex(Vts.Common.Position)">
            <summary>
            method to get tissue region index of photon's current position
            </summary>
            <param name="position">photon Position</param>
            <returns>integer tissue region index</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleInclusionTissue.GetNeighborRegionIndex(Vts.MonteCarlo.Photon)">
            <summary>
            method to get index of neighbor tissue region when photon on boundary of two regions
            </summary>
            <param name="photon">Photon</param>
            <returns>index of neighbor index</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleInclusionTissue.GetDistanceToBoundary(Vts.MonteCarlo.Photon)">
            <summary>
            method to get distance from current photon position and direction to boundary of region
            </summary>
            <param name="photon">Photon</param>
            <returns>distance to boundary</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleInclusionTissue.GetReflectedDirection(Vts.Common.Position,Vts.Common.Direction)">
            <summary>
            method that provides reflected direction when phton reflects off boundary
            </summary>
            <param name="currentPosition">Position</param>
            <param name="currentDirection">Direction</param>
            <returns>new Direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleInclusionTissue.GetRefractedDirection(Vts.Common.Position,Vts.Common.Direction,System.Double,System.Double,System.Double)">
            <summary>
            method that provides refracted direction when photon refracts off boundary
            </summary>
            <param name="currentPosition">Position</param>
            <param name="currentDirection">Direction</param>
            <param name="currentN">refractive index N of current tissue region</param>
            <param name="nextN">refractive index N of next tissue region</param>
            <param name="cosThetaSnell">cosine of theta from Snell's law</param>
            <returns>new Direction</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.SingleInfiniteCylinderTissueInput">
            <summary>
            Implements ITissueInput.  Defines input to SingleInfiniteCylinderTissue class.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleInfiniteCylinderTissueInput.#ctor(Vts.MonteCarlo.ITissueRegion,Vts.MonteCarlo.ITissueRegion[])">
            <summary>
            allows definition of single infinite cylinder tissue
            </summary>
            <param name="infiniteCylinderRegion">infinite cylinder region specification</param>
            <param name="layerRegions">tissue layer specification</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleInfiniteCylinderTissueInput.#ctor">
            <summary>
            SingleInfiniteCylinderTissueInput default constructor provides homogeneous tissue with single infinite cylinder
            with radius 0.5mm and center (0,0,1)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleInfiniteCylinderTissueInput.Regions">
            <summary>
            regions of tissue (layers and infinite cylinder)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleInfiniteCylinderTissueInput.InfiniteCylinderRegion">
            <summary>
            tissue infinite cylinder region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleInfiniteCylinderTissueInput.LayerRegions">
            <summary>
            tissue layer regions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleInfiniteCylinderTissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.SingleVoxelTissueInput">
            <summary>
            Implements ITissueInput.  Defines input to SingleVoxelTissue class.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleVoxelTissueInput.#ctor(Vts.MonteCarlo.ITissueRegion,Vts.MonteCarlo.ITissueRegion[])">
            <summary>
            allows definition of single voxel tissue
            </summary>
            <param name="voxelRegion">voxel region specification</param>
            <param name="layerRegions">tissue layer specification</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleVoxelTissueInput.#ctor">
            <summary>
            SingleVoxelTissueInput default constructor provides homogeneous tissue with single ellipsoid
            with radius 0.5mm and center (0,0,1)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleVoxelTissueInput.Regions">
            <summary>
            regions of tissue (layers and ellipsoid)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleVoxelTissueInput.VoxelRegion">
            <summary>
            tissue ellipsoid region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SingleVoxelTissueInput.LayerRegions">
            <summary>
            tissue layer regions
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SingleVoxelTissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion">
            <summary>
            Implements ITissueRegion.  Defines circular region at surface of tissue
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion.#ctor(Vts.Common.Position,System.Double,Vts.OpticalProperties)">
            <summary>
            SurfaceFiberTissueRegion assumes SurfaceFiber axis is parallel with z-axis
            </summary>
            <param name="center">center position</param>
            <param name="radius">radius in x-y plane</param>
            <param name="op">optical properties of SurfaceFiber</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion.TissueRegionType">
            <summary>
            tissue region identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion.Center">
            <summary>
            center of SurfaceFiber
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion.Radius">
            <summary>
            radius of SurfaceFiber
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion.RegionOP">
            <summary>
            optical properties of SurfaceFiber
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion.ContainsPosition(Vts.Common.Position)">
            <summary>
            Method to determine if photon position within or on SurfaceFiber.  This works if height=0
            as long as Center.Z=0;
            </summary>
            <param name="position">photon position</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion.OnBoundary(Vts.Common.Position)">
            <summary>
            Method to determine if photon on boundary of SurfaceFiber.
            Currently OnBoundary of an inclusion region isn't called by any code ckh 3/5/19.
            </summary>
            <param name="position">photon position</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion.RayIntersectBoundary(Vts.MonteCarlo.Photon,System.Double@)">
            <summary>
            method to determine if photon track intersects boundary
            </summary>
            <param name="photon">photon</param>
            <param name="distanceToBoundary">if intersection, distance to intersection</param>
            <returns>boolean true=intersection, false=no intersection</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.SurfaceFiberTissueRegion.SurfaceNormal(Vts.Common.Position)">
            <summary>
            method to determine normal to surface at given position
            </summary>
            <param name="position">position to calculate normal</param>
            <returns>Direction</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.TissueInput">
            <summary>
            Base class for all tissue inputs
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.TissueInput.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.TissueInput.TissueType">
            <summary>
            tissue type
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.TissueBase">
            <summary>
            Base class for all tissue definitions.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.TissueBase.#ctor(System.Collections.Generic.IList{Vts.MonteCarlo.ITissueRegion})">
            <summary>
            constructor for tissue base
            </summary>
            <param name="regions">list of tissue regions</param>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.TissueBase.Regions">
            <summary>
            list of tissue regions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.TissueBase.RegionScatterLengths">
            <summary>
            scatter lengths of region, either 1/mut or 1/mus depending on AbsorptionWeightingTyp
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.TissueBase.AbsorptionWeightingType">
            <summary>
            type of absorption deweighting employed
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.TissueBase.PhaseFunctionType">
            <summary>
            type of phase function used within region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.TissueBase.RussianRouletteWeightThreshold">
            <summary>
            photon weight threshold, below which turns on Russian Roulette
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.TissueBase.Initialize(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required method to initialize the corresponding ITissue
            </summary>
            <param name="awt">absorption weighting type</param>
            <param name="pft">phase function type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette threshold (default=0)</param>
        </member>
        <member name="T:Vts.MonteCarlo.Tissues.VoxelTissueRegion">
            <summary>
            Implements ITissueRegion.  Defines Cartesian coordinate voxel with x,y,z ranges.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.VoxelTissueRegion.#ctor(Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.OpticalProperties)">
            <summary>
            constructor for voxel region
            </summary>
            <param name="x">x range of voxel</param>
            <param name="y">y range of voxel</param>
            <param name="z">z range of voxel</param>
            <param name="op">optical properties of voxel</param>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.VoxelTissueRegion.#ctor">
            <summary>
            default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.VoxelTissueRegion.TissueRegionType">
            <summary>
            tissue region identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.VoxelTissueRegion.X">
            <summary>
            x range of voxel
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.VoxelTissueRegion.Y">
            <summary>
            y range of voxel
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.VoxelTissueRegion.Z">
            <summary>
            z range of voxel
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.VoxelTissueRegion.RegionOP">
            <summary>
            optical properties of voxel
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Tissues.VoxelTissueRegion.Center">
            <summary>
            center of voxel
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.VoxelTissueRegion.RayIntersectBoundary(Vts.MonteCarlo.Photon,System.Double@)">
            <summary>
            Checks if the specified photon will intersect the voxel boundary
            </summary>
            <param name="photon">Photon to check for intersection (including Position, Direction, and S)</param>
            <param name="distanceToBoundary">The distance to the next boundary</param>
            <returns>True if photon will intersect the voxel boundary, false otherwise</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.VoxelTissueRegion.ContainsPosition(Vts.Common.Position)">
            <summary>
            method to determine if photon at designated position resides within or on voxel
            </summary>
            <param name="position">position of photon</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.VoxelTissueRegion.OnBoundary(Vts.Common.Position)">
            <summary>
            Method to determine if photon on boundary of voxel.
            Currently OnBoundary of an inclusion region isn't called by any code ckh 3/5/19.
            </summary>
            <param name="position">photon position</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Tissues.VoxelTissueRegion.SurfaceNormal(Vts.Common.Position)">
            <summary>
            method to determine normal to surface at given position
            </summary>
            <param name="position"></param>
            <returns>Direction</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Helpers.DetectorBinning">
            <summary> 
            Methods that aid in determining which detector bin to tally.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.DetectorBinning.WhichBin(System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            WhichBin determines which uniform bin "value" is in.
            If data is beyond last bin, the last bin is returned.
            If the data is smaller than first bin, the first bin is returned.
            This assumes bins are contiguous.
            </summary>
            <param name="value">value to be binned</param>
            <param name="binSize">bin size</param>
            <param name="numberOfBins">size of array</param>
            <param name="binStart">starting location of binning</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.DetectorBinning.WhichBin(System.Double,System.Double,System.Double[])">
            <summary>
            WhichBin determines which bin "value" is in given a list of bin centers and bin sizes.
            If value not in any bin, -1 returned.
            This allows for non-contiguous bins and nonuniformly spaced bins.
            </summary>
            <param name="value">value to be binned</param>
            <param name="binSize">bin size</param>
            <param name="binCenters">list of bin centers</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.DetectorBinning.WhichBin(System.Double,System.Double[])">
            <summary>
            WhichBin determines which bin "value" is in given a list of bin stops.
            If value not in any bin, -1 returned.
            This allows for nonuniformly spaced bins within assumed contiguous span starting from 0.
            </summary>
            <param name="value">value to be binned</param>
            <param name="binStops">list of bin stops</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.DetectorBinning.WhichBinExclusive(System.Double,System.Int32,System.Double,System.Double)">
            <summary>
            WhichBin determines which uniform bin "value" is in.
            If data is beyond last bin, it is not binned and -1 is returned
            If the data is smaller than first bin, it is not binned and -1 is returned
            This assumes bins are contiguous.
            </summary>
            <param name="value">value to be binned</param>
            <param name="binSize">bin size</param>
            <param name="numberOfBins">size of array</param>
            <param name="binStart">starting location of binning</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.DetectorBinning.GetTimeDelay(System.Double,System.Double)">
            <summary>
            Method to determine time delay of photon given its pathlength and refractive index
            of medium where pathlength is determined
            </summary>
            <param name="pathlength">distance photon has traveled</param>
            <param name="n">refractive index of medium where pathlength is determined</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.DetectorBinning.GetRho(System.Double,System.Double)">
            <summary>
            Method to determine rho given x and y coordinates
            </summary>
            <param name="x">x coordinate</param>
            <param name="y">y coordinate</param>
            <returns>sqrt(x*x+y*y)</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Helpers.ErrorCalculation">
            <summary>
            Provides statistical error estimation given 2nd moment calculation
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.ErrorCalculation.StandardDeviation(System.Int64,System.Double,System.Double)">
            <summary>
            StandardDeviation calculates the square root of the variance
            </summary>
            <param name="numberOfPhotons">number of photons launched</param>
            <param name="mean">average value of first moment</param>
            <param name="secondMoment">average value of second moment</param>
            <returns>standard deviation</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Helpers.Optics">
            <summary>
            Provides common optics methods (e.g. Fresnel, Specular)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.Optics.Fresnel(System.Double,System.Double,System.Double,System.Double@)">
            <summary>
            Fresnel calculates the reflection coefficient when light moves from one medium to
            another
            </summary>
            <param name="n1">refractive index of current medium</param>
            <param name="n2">refractive index of next medium</param>
            <param name="ci">cosine of the angle with interface normal</param>
            <param name="uz_snell">cosine of the transmitted light with interface normal</param>
            <returns>reflection probability</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.Optics.Specular(System.Double,System.Double)">
            <summary>
            Specular determines the fraction of the light reflected for normally incident light
            </summary>
            <param name="n1">refractive index of the current medium</param>
            <param name="n2">refractive index of the next medium</param>
            <returns>double</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Helpers.PolarAzimuthalAngles">
            <summary>
            Methods to help with the determination of polar azimuthal angles.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.PolarAzimuthalAngles.#ctor(System.Double,System.Double)">
            <summary>
            Returns polar azimuthal angle angle in spherical coordinate system
            </summary>
            <param name="theta">polar angle</param>
            <param name="phi">azimuthal angle</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.PolarAzimuthalAngles.#ctor">
            <summary>
            Theta (polar) and Phi (azimuthal) angles default constructor
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Helpers.PolarAzimuthalAngles.Theta">
            <summary>
            Polar Angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Helpers.PolarAzimuthalAngles.Phi">
            <summary>
            Azimuthal Angle
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.PolarAzimuthalAngles.op_Equality(Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles)">
            <summary>
            Equality overload for polar azimuthal angle pair
            </summary>
            <param name="pa1">polar angle 1</param>
            <param name="pa2">polar angle 2</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.PolarAzimuthalAngles.op_Inequality(Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles)">
            <summary>
            Inequality overload for polar azimuthal angle pair
            </summary>
            <param name="pa1">polar angle 1</param>
            <param name="pa2">polar angle 2</param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.PolarAzimuthalAngles.Equals(System.Object)">
            <summary>
            Instance member for equality comparison
            </summary>
            <param name="obj"></param>
            <returns>boolean</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.PolarAzimuthalAngles.Clone">
            <summary>
            method to clone class
            </summary>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.PolarAzimuthalAngles.GetHashCode">
            <summary>
            Override of GetHashCode to allow the type to work correctly in a hash table
            </summary>
            <returns>The hashcode as an integer</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Helpers.SourceFlags">
            <summary>
            Implements SourceFlags class
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceFlags.#ctor(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Provide on/off flags for translation, rotation from inward normal and rotation of Principal source axis
            </summary>
            <param name="translationFromOriginFlag">The translation from origin</param>
            <param name="beamRotationFromInwardNormalFlag">The rotation from inward normal</param>
            <param name="rotationOfPrincipalSourceAxisFlag">The source axis rotation</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceFlags.#ctor">
            <summary>
            No translation, no inward normal rotation and no principal axis rotation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Helpers.SourceFlags.TranslationFromOriginFlag">
            <summary>
            boolean flag indicating whether translation from origin required
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Helpers.SourceFlags.BeamRotationFromInwardNormalFlag">
            <summary>
            boolean flag indicating whether beam rotation from inward normal required
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Helpers.SourceFlags.RotationOfPrincipalSourceAxisFlag">
            <summary>
            boolean flag indicating whether rotation of principal source axis required
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceFlags.Clone">
            <summary>
            method to clone class
            </summary>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Helpers.SourceToolbox">
            <summary>
            Utilities shared by Sources.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetDirectionForGiven2DPositionAndGivenPolarAngle(System.Double,Vts.Common.Position)">
            <summary>
            Provides a direction for a given two dimensional position and a polar angle
            </summary>
            <param name="polarAngle">Constant polar angle</param>
            <param name="position">The position </param>
            <returns>direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetDirectionForGivenPolarAzimuthalAngleRangeRandom(Vts.Common.DoubleRange,Vts.Common.DoubleRange,System.Random)">
            <summary>
            Provides a direction after uniform sampling of given polar angle range and azimuthal angle range 
            </summary>
            <param name="polarAngleEmissionRange">The polar angle range</param>
            <param name="azimuthalAngleEmissionRange">The azimuthal angle range</param>
            <param name="rng">The random number generator</param>
            <returns>direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetDirectionForIsotropicDistributionRandom(System.Random)">
            <summary>
            Provides a random direction for a isotropic point source
            </summary>
            <param name="rng">The random number generator</param>
            <returns>direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetDoubleNormallyDistributedRandomNumbers(System.Double@,System.Double@,System.Double,System.Double,System.Random)">
            <summary>
            Generate two normally (Gaussian) distributed random numbers by using Box Muller Algorithm (with sine/cosine)
            </summary>
            <param name="nrng1">normally distributed random number 1</param>
            <param name="nrng2">normally distributed random number 2</param>
            <param name="lowerLimit">lower limit of the uniform random number</param>
            <param name="upperLimit">lower limit of the uniform random number</param>
            <param name="rng">The random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetLimit(System.Double)">
            <summary>
            Provides the limit of a flat random distribution between 0 and 1
            </summary>
            <param name="factor">factor</param>
            <returns>lower limit</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPolarAzimuthalPairForGivenAngleRangeRandom(Vts.Common.DoubleRange,Vts.Common.DoubleRange,System.Random)">
            <summary>
            Provides polar azimuthal angle pair after uniform sampling of given polar angle range and azimuthal angle range
            </summary>
            <param name="polarAngleEmissionRange">The polar angle range</param>
            <param name="azimuthalAngleEmissionRange">The azimuthal angle range</param>
            <param name="rng">The random number generator</param>
            <returns>polar azimuthal angle pair</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPolarAzimuthalPairFromDirection(Vts.Common.Direction)">
            <summary>
            Provide corresponding Polar Azimuthal Angle pair for a given direction
            </summary>
            <param name="direction">Current direction</param>
            <returns>polar azimuthal angle pair</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInACircleRandomFlat(Vts.Common.Position,System.Double,System.Double,System.Random)">
            <summary>
            Provides a random position in a circle (Flat distribution)
            </summary>
            <param name="center">The center coordinates of the circle</param>
            <param name="innerRadius">The inner radius of the circle</param>
            <param name="outerRadius">The outer radius of the circle</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionAtCirclePerimeter(Vts.Common.Position,System.Double,System.Random)">
            <summary>
            Provides a random position at circle perimeter
            </summary>
            <param name="center">The center coordinates of the circle</param>
            <param name="radius">The radius of the circle</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInACircleRandomGaussian(Vts.Common.Position,System.Double,System.Double,System.Double,System.Random)">
            <summary>
            Provides a random position in a circle (Gaussisan distribution)
            </summary>
            <param name="center">The center coordinates of the circle</param>
            <param name="outerRadius">The outer radius of the circle</param>
            <param name="innerRadius">The inner radius of the circle</param>
            <param name="beamDiaFWHM">Beam diameter at FWHM</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>       
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInACuboidRandomFlat(Vts.Common.Position,System.Double,System.Double,System.Double,System.Random)">
            <summary>
            Returns a random position in a cuboid volume (Flat distribution)
            </summary>
            <param name="center">The center coordinates of the cuboid</param>
            <param name="lengthX">The x-length of the cuboid</param>
            <param name="lengthY">The y-length of the cuboid</param>
            <param name="lengthZ">The z-length of the cuboid</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInACuboidRandomGaussian(Vts.Common.Position,System.Double,System.Double,System.Double,System.Double,System.Random)">
            <summary>
            Returns a random position in a cuboid volume (Gaussian distribution)
            </summary>
            <param name="center">The center coordinates of the cuboid</param>
            <param name="lengthX">The x-coordinate of the length</param>
            <param name="lengthY">The y-coordinate of the width</param>
            <param name="lengthZ">The z-coordinate of the height</param>
            <param name="beamDiaFWHM">Beam diameter at FWHM</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInALineRandomFlat(Vts.Common.Position,System.Double,System.Random)">
            <summary>
            Returns a random position in a line (Flat distribution)        
            </summary>
            <param name="center">The center coordiantes of the line</param>
            <param name="lengthX">The x-length of the line</param>        
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInALineRandomGaussian(Vts.Common.Position,System.Double,System.Double,System.Random)">
            <summary>
            Returns a random position in a line (Flat distribution)        
            </summary>
            <param name="center">The center coordinates of the line</param>
            <param name="lengthX">The x-coordinate of the length</param>   
            <param name="beamDiaFWHM">Beam diameter at FWHM</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInAnEllipseRandomFlat(Vts.Common.Position,System.Double,System.Double,System.Random)">
            <summary>
            Provides a random position in an ellipse (Flat distribution)
            </summary>
            <param name="center">The center coordiantes of the ellipse</param>
            <param name="a">'a' parameter of the ellipse</param>
            <param name="b">'b' parameter of the ellipse</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInAnEllipseRandomGaussian(Vts.Common.Position,System.Double,System.Double,System.Double,System.Random)">
            <summary>
            Provides a random position in an ellipse (Gaussian distribution)
            </summary>
            <param name="center">The center coordiantes of the ellipse</param>
            <param name="a">'a' parameter of the ellipse</param>
            <param name="b">'b' parameter of the ellipse</param>
            <param name="beamDiaFWHM">Beam diameter at FWHM</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>   
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInAnEllipsoidRandomFlat(Vts.Common.Position,System.Double,System.Double,System.Double,System.Random)">
            <summary>
            Returns a random position in an ellipsoid volume (Flat distribution)
            </summary>
            <param name="center">The center coordiantes of the ellipse</param>
            <param name="a">'a' parameter of the ellipsoid</param>
            <param name="b">'b' parameter of the ellipsoid</param>
            <param name="c">'c' parameter of the ellipsoid</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInAnEllipsoidRandomGaussian(Vts.Common.Position,System.Double,System.Double,System.Double,System.Double,System.Random)">
            <summary>
            Returns a random position in an ellipsoid volume (Gaussian distribution)
            </summary>
            <param name="center">The center coordiantes of the ellipsoid</param>
            <param name="a">'a' parameter of the ellipsoid</param>
            <param name="b">'b' parameter of the ellipsoid</param>
            <param name="c">'c' parameter of the ellipsoid</param>
            <param name="beamDiaFWHM">Beam diameter at FWHM</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInARectangleRandomFlat(Vts.Common.Position,System.Double,System.Double,System.Random)">
            <summary>
            Returns a random position in a rectangular surface (Flat distribution)
            </summary>
            <param name="center">The center coordiantes of the rectangle</param>
            <param name="lengthX">The x-length of the rectangle</param>
            <param name="lengthY">The y-length of the rectangle</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionInARectangleRandomGaussian(Vts.Common.Position,System.Double,System.Double,System.Double,System.Random)">
            <summary>
            Returns a random position in a rectangular surface (Gaussian distribution)
            </summary>
            <param name="center">The center coordiantes of the rectangle</param>
            <param name="lengthX">The x-coordinate of the lengthX</param>
            <param name="lengthY">The y-coordinate of the widthY</param>
            <param name="beamDiaFWHM">Beam diameter at FWHM</param>
            <param name="rng">The random number generator</param>
            <returns>position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetPositionOfASymmetricalLineRandomFlat(System.Double,System.Random)">
            <summary>
            Provides a flat random location of a symmetrical line
            </summary>
            <param name="length">The length of the line</param>
            <param name="rng">The random number generator</param>
            <returns>position in a line</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.GetSingleNormallyDistributedRandomNumber(System.Double,System.Random)">
            <summary>
            Generate one normally (Gaussian) distributed random number by using Box Muller Algorithm (with sine/cosine)
            </summary>
            <param name="lowerLimit">lower limit of the uniform random number</param>
            <param name="rng">The random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionAfterRotatingAroundThreeAxis(Vts.MonteCarlo.Helpers.ThreeAxisRotation,Vts.Common.Direction)">
            <summary>
            Update the direction after rotating around three axis
            </summary>
            <param name="rotationAngles">x, y, z rotation angles </param>
            <param name="currentDirection">The direction to be updated</param>
            <returns>direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionAfterRotatingAroundXAxis(System.Double,Vts.Common.Direction)">
            <summary>
            Update the direction after rotating around the x-axis
            </summary>
            <param name="xRotation">rotation angle around the x-axis</param>
            <param name="currentDirection">The direction to be updated</param>       
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionAfterRotatingAroundYAxis(System.Double,Vts.Common.Direction)">
            <summary>
            Update the direction after rotating around the y-axis
            </summary>
            <param name="yRotation">rotation angle around the y-axis</param>
            <param name="currentDirection">The direction to be updated</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionAfterRotatingAroundZAxis(System.Double,Vts.Common.Direction)">
            <summary>
            Update the direction after rotating around the z-axis
            </summary>
            <param name="zRotation">rotation angle around the z-axis</param>
            <param name="currentDirection">The direction to be updated</param>
            <returns>direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionAfterRotatingByGivenAnglePair(Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,Vts.Common.Direction)">
            <summary>
            Update the direction after rotating by given polar and azimuthal angle
            </summary>
            <param name="rotationAnglePair">polar and azimuthal angle pair</param>        
            <param name="currentDirection">The direction to be updated</param>
            <returns>direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionPositionAfterGivenFlags(Vts.Common.Position@,Vts.Common.Direction@,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,Vts.MonteCarlo.Helpers.SourceFlags)">
            <summary>
            Update the direction and position after beam rotation, source axis rotation and translation
            </summary>
            <param name="pos">Position</param>
            <param name="dir">Direction</param>
            <param name="sourceAxisRotation">Source Axis Rotation</param>       
            <param name="translate">Translation</param>
            <param name="beamRotation">Beam Rotation</param>
            <param name="flags">Flags</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionPositionAfterGivenFlags(Vts.Common.Position@,Vts.Common.Direction@,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,Vts.Common.Position,Vts.MonteCarlo.Helpers.SourceFlags)">
            <summary>
            Update the direction and position after beam axis rotation and translation
            </summary>
            <param name="pos">Position</param>
            <param name="dir">Direction</param>
            <param name="sourceAxisRotation">Source Axis Rotation</param>    
            <param name="translate">Translation</param>        
            <param name="flags">Flags</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionPositionAfterRotatingAroundXAxis(System.Double,Vts.Common.Direction@,Vts.Common.Position@)">
            <summary>
            Update the direction and position of the source after rotating around the x-axis
            </summary>
            <param name="xRotation">rotation angle around the x-axis</param>
            <param name="currentDirection">The direction to be updated</param>
            <param name="currentPosition">The position to be updated</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionPositionAfterRotatingAroundYAxis(System.Double,Vts.Common.Direction@,Vts.Common.Position@)">
            <summary>
            Update the direction and position of the source after rotating around the y-axis
            </summary>
            <param name="yRotation">rotation angle around the y-axis</param>
            <param name="currentDirection">The direction to be updated</param>
            <param name="currentPosition">The position to be updated</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionPositionAfterRotatingAroundZAxis(System.Double,Vts.Common.Direction@,Vts.Common.Position@)">
            <summary>
            Update the direction and position of the source after rotating around the z-axis
            </summary>
            <param name="zRotation">rotation angle around the z-axis</param>
            <param name="currentDirection">The direction to be updated</param>
            <param name="currentPosition">The position to be updated</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdateDirectionPositionAfterRotatingByGivenAnglePair(Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,Vts.Common.Direction@,Vts.Common.Position@)">
            <summary>
            Update the direction and position of the source after rotating by a given polar and azimuthal angle
            </summary>
            <param name="rotationAnglePair">polar and azimuthal angle angle pair</param>
            <param name="currentDirection">The direction to be updated</param>
            <param name="currentPosition">The position to be updated</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdatePolarAngleForDirectionalSources(System.Double,System.Double,System.Double)">
            <summary>
            Update the polar angle based on incidnet location
            </summary>
            <param name="fullLength">Maximum length</param>
            <param name="curLength">Current Length</param>
            <param name="thetaConvOrDiv">Convergence or Diveregence Angle</param>
            <returns>polar angle</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.SourceToolbox.UpdatePositionAfterTranslation(Vts.Common.Position,Vts.Common.Position)">
            <summary>
            Update the position after translation
            </summary>
            <param name="currentPosition">The old location</param>
            <param name="translation">Translation coordinats relative to the origin</param>
            <returns>position</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Helpers.ThreeAxisRotation">
            <summary>
            Implements ThreeAxisRotation class
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.ThreeAxisRotation.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the ThreeAxisRotation class
            </summary>
            <param name="xRotation">Rotation angle around x-axis</param>
            <param name="yRotation">Rotation angle around y-axis</param>
            <param name="zRotation">Rotation angle around z-axis</param>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.ThreeAxisRotation.#ctor">
            <summary>
            Initializes a new instance of the ThreeAxisRotation class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Helpers.ThreeAxisRotation.XRotation">
            <summary>
            rotation angle around x-axis
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Helpers.ThreeAxisRotation.YRotation">
            <summary>
            rotation angle around y-axis
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Helpers.ThreeAxisRotation.ZRotation">
            <summary>
            rotation angle around z-axis
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Helpers.ThreeAxisRotation.Clone">
            <summary>
            method to clone ThreeAxisRotation
            </summary>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.SourceDefaults">
            <summary>
            Define SourceDefault values
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SourceDefaults.DefaultDirectionOfPrincipalSourceAxis">
            <summary>
            Default direction (positive z-axis)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SourceDefaults.DefaultPosition">
            <summary>
            Default position (0, 0, 0)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SourceDefaults.DefaultBeamRoationFromInwardNormal">
            <summary>
            Default beam rotation angle from inward normal (0.0, 0.0)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SourceDefaults.DefaultFullPolarAngleRange">
            <summary>
            Default full polar angle range (0.0, PI)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SourceDefaults.DefaultHalfPolarAngleRange">
            <summary>
            Default half polar angle range (0.0, PI/2)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SourceDefaults.DefaultAzimuthalAngleRange">
            <summary>
            Default azimuthal angle range (0.0, 2PI)
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.SourceProfiles.ArbitrarySourceProfile">
            <summary>
            Defines Arbitrary Source Profile
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SourceProfiles.ArbitrarySourceProfile.#ctor(System.Double[],System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the ArbitrarySourceProfile class
            </summary>
            <param name="image">1D array containing 2D image of values</param>
            <param name="pixelWidth">pixel width</param>
            <param name="pixelHeight">pixel height</param>
            <remarks>Currently, only binary maps are implemented. Non-zero (1e-10D) values will be 1, 0 otherwise</remarks>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SourceProfiles.ArbitrarySourceProfile.#ctor">
            <summary>
            Initializes the default constructor of ArbitrarySourceProfile class (intensity = 1.0)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SourceProfiles.ArbitrarySourceProfile.SourceProfileType">
            <summary>
            Returns Arbitrary profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SourceProfiles.ArbitrarySourceProfile.Image">
            <summary>
            1D array containing 2D image of values
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SourceProfiles.ArbitrarySourceProfile.PixelWidth">
            <summary>
            pixel width
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SourceProfiles.ArbitrarySourceProfile.PixelHeight">
            <summary>
            pixel height
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SourceProfiles.ArbitrarySourceProfile.IsBinary">
            <summary>
            flag to determine if binary, currently only binary is implemented
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.SourceProfiles.FlatSourceProfile">
            <summary>
            Defines Flat Source Profile
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SourceProfiles.FlatSourceProfile.#ctor">
            <summary>
            Initializes the default constructor of FlatSourceProfile class
            for serialization purposes
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SourceProfiles.FlatSourceProfile.SourceProfileType">
            <summary>
            Returns flat profile type
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.SourceProfiles.GaussianSourceProfile">
            <summary>
            Defines Gaussian Source Profile
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SourceProfiles.GaussianSourceProfile.SourceProfileType">
            <summary>
            Returns Gaussian profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SourceProfiles.GaussianSourceProfile.BeamDiaFWHM">
            <summary>
            Full width half maximum beam diameter
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SourceProfiles.GaussianSourceProfile.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the GaussianSourceProfile class
            </summary>
            <param name="beamDiaFWHM">Full width half maximum beam diameter</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SourceProfiles.GaussianSourceProfile.#ctor">
            <summary>
            Initializes the default constructor of GaussianSourceProfile class (BeamDiaFWHM = 1.0)
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomLineSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for CustomLineSource implementation 
            including line length, source profile, polar angle range, azimuthal angle range, 
            direction, position, inward normal beam rotation and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomLineSourceInput.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of CustomLineSourceInput class
            </summary>
            <param name="lineLength">The length of the line source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">beam rotation angle</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomLineSourceInput.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange)">
            <summary>
            Initializes a new instance of CustomLineSourceInput class
            </summary>
            <param name="lineLength">The length of the line source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomLineSourceInput.#ctor">
            <summary>
            Initializes the default constructor of CustomLineSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomLineSourceInput.SourceType">
            <summary>
            Line source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomLineSourceInput.LineLength">
            <summary>
            The length of the line source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomLineSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomLineSourceInput.PolarAngleEmissionRange">
            <summary>
            Polar angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomLineSourceInput.AzimuthalAngleEmissionRange">
            <summary>
            Azimuthal angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomLineSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomLineSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomLineSourceInput.BeamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomLineSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomLineSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomLineSource">
            <summary>
            Implements CustomLineSource with ine length, source profile, polar angle range, azimuthal 
            angle range, direction, position, inward normal beam rotation and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomLineSource.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of the CustomLineSource class
            </summary>
            <param name="lineLength">The length of the line source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle emission range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle emission range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">Beam rotation from inward normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomLineSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalLineSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for DirectionalLineSource implementation 
            including converging/diverging angle, line length, source profile, direction, position, 
            inward normal beam rotation and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of the DirectionalLineSourceInput class
            </summary>
            <param name="thetaConvOrDiv">Covergence or Divergance Angle {= 0, for a collimated beam} {= 0, for a collimated beam}</param>
            <param name="lineLength">The length of the line source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">beam rotation angle</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile)">
            <summary>
            Initializes a new instance of the DirectionalLineSourceInput class
            </summary>
            <param name="thetaConvOrDiv">Covergence or Divergance Angle {= 0, for a collimated beam}</param>
            <param name="lineLength">The length of the line source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.#ctor">
            <summary>
            Initializes a new instance of the DirectionalLineSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.ThetaConvOrDiv">
            <summary>
            Covergence or Divergance Angle {= 0, for a collimated beam}
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.SourceType">
            <summary>
            Line source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.LineLength">
            <summary>
            The length of the line source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.BeamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalLineSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalLineSource">
            <summary>
            Implements DirectionalLineSource. Returns DirectionalLineSource with converging/diverging angle,
            line length, source profile, direction, position, inward normal beam rotation and initial tissue
            region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalLineSource.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of the DirectionalLineSource class
            </summary>
            <param name="thetaConvOrDiv">Covergence or Divergance Angle {= 0, for a collimated beam}</param>
            <param name="lineLength">The length of the line source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">Ray rotation from inward normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalLineSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>       
        </member>
        <member name="T:Vts.MonteCarlo.Sources.IsotropicLineSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for IsotropicLineSource implementation 
            including line length, source profile, direction, position, inward normal beam 
            rotation and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of IsotropicLineSourceInput class
            </summary>
            <param name="lineLength">The length of the line source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">beam rotation angle</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile)">
            <summary>
            Initializes a new instance of IsotropicLineSourceInput class
            </summary>
            <param name="lineLength">The length of the line source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.#ctor">
            <summary>
            Initializes the default constructor of IsotropicLineSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.SourceType">
            <summary>
            Line source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.LineLength">
            <summary>
            The length of the line source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.BeamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicLineSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.IsotropicLineSource">
            <summary>
            Implements IsotropicLineSource with line length, source profile, direction, position, 
            inward normal beam rotation and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicLineSource.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Returns an instance of isotropicLineSource with line length, source profile, direction, position, 
            inward normal beam rotation and initial tissue region index.
            </summary>
            <param name="lineLength">The length of the line source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">Ray rotation from inward normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicLineSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for a line source
            of width tissueLineLength ray traced back to line in air (pupil in 2D).
            This is different than sampling theta,phi angles performed in LineSources
            All of the "AngledFrom" series of sources translate the source on tissue
            and the source in air separately.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Position,System.Double,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of CustomLineSourceInput class
            </summary>
            <param name="tissueLineLength">The length of line source on tissue</param>
            <param name="sourceProfile">Profile of line on tissue surface</param>
            <param name="translationFromOrigin">center position of line source on tissue</param>
            <param name="lineInAirLength">The length of the line source in air</param>
            <param name="lineInAirTranslationFromOrigin">center position of line source in air (Z assumed to be negative)</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput.#ctor">
            <summary>
            Initializes the default constructor of LineAngledFromLineSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput.SourceType">
            <summary>
            Line source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput.TissueLineLength">
            <summary>
            The length of the line source on tissue surface
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput.TranslationFromOrigin">
            <summary>
            Line in tissue surface translation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput.LineInAirLength">
            <summary>
            The length of the line source in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput.LineInAirTranslationFromOrigin">
            <summary>
            Line in air translation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index, this will always be 0
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LineAngledFromLineSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LineAngledFromLineSource">
            <summary>
            Implements LineAngledFromLineSource with line length, direction, position, 
            and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LineAngledFromLineSource.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Position,System.Double,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of the LineAngledFromLineSource class
            </summary>
            <param name="tissueLineLength">The length of line source on tissue</param>
            <param name="sourceProfile">Profile of line on tissue</param>
            <param name="translationFromOrigin">line on tissue surface translation</param>
            <param name="lineInAirLength">The length of the line source in air</param>
            <param name="lineInAirTranslationFromOrigin">line in air translation</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LineAngledFromLineSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position on *tissue*</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LineSourceBase">
            <summary>
            Abstract class for LineSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.LineSourceBase._sourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.LineSourceBase._newDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.LineSourceBase._translationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.LineSourceBase._beamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.LineSourceBase._rotationAndTranslationFlags">
            <summary>
            Source rotation and translation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.LineSourceBase._lineLength">
            <summary>
            The length of the line source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.LineSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LineSourceBase.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Defines LineSourceBase class
            </summary>
            <param name="lineLength">The length of the line source</param>
            <param name="sourceProfile">Source profile type</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">Beam rotation from inward normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LineSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LineSourceBase.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns final direction for a given position
            </summary>
            <param name="position">Current position</param>
            <returns>new direction</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LineSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomPointSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for CustomLineSource implementation 
            including polar angle range, azimuthal angle range, emitting point location,
            direction and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomPointSourceInput.#ctor(Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Position,Vts.Common.Direction,System.Int32)">
            <summary>
            Initializes a new instance of CustomPointSourceInput class
            </summary>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
            <param name="pointLocation">position</param>
            <param name="direction">direction</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomPointSourceInput.#ctor">
            <summary>
            Initializes the default constructor of CustomPointSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomPointSourceInput.SourceType">
            <summary>
            Point source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomPointSourceInput.PolarAngleEmissionRange">
            <summary>
            Polar angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomPointSourceInput.AzimuthalAngleEmissionRange">
            <summary>
            Azimuthal angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomPointSourceInput.PointLocation">
            <summary>
            New position
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomPointSourceInput.Direction">
            <summary>
            Point source emitting direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomPointSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomPointSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomPointSource">
            <summary>
            Implements CustomLineSource with polar angle range, azimuthal angle range, emitting point
            location, direction and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomPointSource.#ctor(Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of Custom Point Source for a given polar and azimuthal angle range, 
            new source axis direction, and  translation.
            </summary>
            <param name="polarAngleEmissionRange">Polar angle emission range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle emission range</param>
            <param name="newDirectionOfPrincipalSourceAxis">Point source emitting direction</param>
            <param name="pointLocation">New position</param>  
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalPointSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for CustomLineSource implementation 
            including converging/diverging angle, emitting point location, direction and 
            initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalPointSourceInput.#ctor(Vts.Common.Position,Vts.Common.Direction,System.Int32)">
            <summary>
            Initializes a new instance of DirectionalPointSourceInput class
            </summary>
            <param name="pointLocation">New position</param>
            <param name="direction">Point source emitting direction</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalPointSourceInput.#ctor">
            <summary>
            Initializes the default constructor of DirectionalPointSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalPointSourceInput.SourceType">
            <summary>
            Point source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalPointSourceInput.PointLocation">
            <summary>
            New position
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalPointSourceInput.Direction">
            <summary>
            Point source emitting direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalPointSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalPointSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalPointSource">
            <summary>
            Implements CustomLineSource  with converging/diverging angle, emitting point location, 
            direction and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalPointSource.#ctor(Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of Directional Point Source with a given emission direction at a given location
            </summary>        
            <param name="direction">Point source emitting direction</param>
            <param name="pointLocation">New position</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.IsotropicPointSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for IsotropicPointSource implementation 
            including emitting position, direction and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicPointSourceInput.#ctor(Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of IsotropicPointSourceInput class
            </summary>
            <param name="pointLocation">position</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicPointSourceInput.#ctor">
            <summary>
            Initializes the default constructor of IsotropicPointSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicPointSourceInput.SourceType">
            <summary>
            Point source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicPointSourceInput.PointLocation">
            <summary>
            New position
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicPointSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicPointSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.IsotropicPointSource">
            <summary>
            Implements IsotropicPointSource with emitting position, direction and initial 
            tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicPointSource.#ctor(Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of Isotropic Point Source at a given location
            </summary>        
            <param name="pointLocation">Location of the point source</param> 
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.PointSourceBase">
            <summary>
            Abstract class for PointSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.PointSourceBase._polarAngleEmissionRange">
            <summary>
            Polar angle range
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.PointSourceBase._azimuthalAngleEmissionRange">
            <summary>
            Azimuthal angle range
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.PointSourceBase._pointLocation">
            <summary>
            New position
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.PointSourceBase._direction">
            <summary>
            Point source emitting direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.PointSourceBase._rotationalAnglesOfPrincipalSourceAxis">
            <summary>
            Rotation angles pair(polar/azimuthal) of emitting direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.PointSourceBase._rotationAndTranslationFlags">
            <summary>
            Source translation and rotation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.PointSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.PointSourceBase.#ctor(Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Defines PointSourceBase class
            </summary>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
            <param name="direction">Point source emitting direction</param>
            <param name="pointLocation">New position</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.PointSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.PointSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for LambertianSurfaceEmittingCylindricalFiberSource
            implementation including tube radius, tube height, curved surface efficiency, bottom surface 
            efficiency, direction, position, and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.#ctor(System.Double,System.Double,System.Double,System.Double,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of LambertianSurfaceEmittingCylindricalFiberSourceInput class
            </summary>
            <param name="fiberRadius">Fiber radius</param>
            <param name="fiberHeightZ">Fiber height</param>
            <param name="curvedSurfaceEfficiency">Efficiency of curved surface (0 - 1)</param>
            <param name="bottomSurfaceEfficiency">Efficiency of bottom surface (0 - 1)</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of LambertianSurfaceEmittingCylindricalFiberSourceInput class
            </summary>
            <param name="fiberRadius">Fiber radius</param>
            <param name="fiberHeightZ">Fiber height</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.#ctor">
            <summary>
            Initializes the default constructor of LambertianSurfaceEmittingCylindricalFiberSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.SourceType">
            <summary>
            Surface emitting cylindrical fiber source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.FiberRadius">
            <summary>
            Fiber radius
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.FiberHeightZ">
            <summary>
            Fiber height
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.CurvedSurfaceEfficiency">
            <summary>
            Efficiency of curved surface (0 - 1)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.BottomSurfaceEfficiency">
            <summary>
            Efficiency of bottom surface (0 - 1)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSource">
            <summary>
            Implements LambertianSurfaceEmittingCylindricalFiberSource with fiber radius, fiber height,
            curved surface efficiency, bottom surface efficiency, direction, position, and initial 
            tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCylindricalFiberSource.#ctor(System.Double,System.Double,System.Double,System.Double,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of Lambertian Surface Emitting cylindrical fiber source with source axis rotation and translation
            </summary>
            <param name="fiberRadius">Fiber radius</param>
            <param name="fiberHeightZ">Fiber height</param>
            <param name="curvedSurfaceEfficiency">Efficciency of the curved surface (0-1)</param>
            <param name="bottomSurfaceEfficiency">Efficciency of the bottom surface (0-1)</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase">
            <summary>
            Abstract class for SurfaceEmittingCylindricalFiberSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase._newDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase._translationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase._rotationAndTranslationFlags">
            <summary>
            Source rotation and translation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase._fiberRadius">
            <summary>
            Fiber radius
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase._fiberHeightZ">
            <summary>
            Fiber height
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase._curvedSurfaceEfficiency">
            <summary>
            Efficciency of the curved surface (0-1)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase._bottomSurfaceEfficiency">
            <summary>
            Efficciency of the bottom surface (0-1)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase.#ctor(System.Double,System.Double,System.Double,System.Double,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Defines SurfaceEmittingCylindricalFiberSourceBase class
            </summary>
            <param name="fiberRadius">Fiber radius</param>
            <param name="fiberHeightZ">Fiber height</param>
            <param name="curvedSurfaceEfficiency">Efficciency of the curved surface (0-1)</param>
            <param name="bottomSurfaceEfficiency">Efficciency of the bottom surface (0-1)</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SurfaceEmittingCylindricalFiberSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for CustomSurfaceEmittingSphericalSource 
            implementation including radius, source profile, polar angle range, azimuthal angle 
            range, direction, position and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.#ctor(System.Double,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of CustomSurfaceEmittingSphericalSourceInput class
            </summary>
            <param name="radius">The radius of the sphere</param>
            <param name="polarAngleRangeToDefineSphericalSurface">Polar angle range to define spherical surface</param>
            <param name="azimuthalAngleRangeToDefineSphericalSurface">Azimuthal angle range to define spherical surface</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.#ctor(System.Double,Vts.Common.DoubleRange,Vts.Common.DoubleRange)">
            <summary>
            Initializes a new instance of CustomSurfaceEmittingSphericalSourceInput class
            </summary>
            <param name="radius">The radius of the sphere</param>
            <param name="polarAngleRangeToDefineSphericalSurface">polar angle range to define spherical surface</param>
            <param name="azimuthalAngleRangeToDefineSphericalSurface">azimuthal angle range to define spherical surface</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.#ctor">
            <summary>
            Initializes the default constructor of CustomSurfaceEmittingSphericalSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.SourceType">
            <summary>
            Spherical source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.Radius">
            <summary>
            The radius of the sphere
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.PolarAngleRangeToDefineSphericalSurface">
            <summary>
            Polar angle range to define spherical surface
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.AzimuthalAngleRangeToDefineSphericalSurface">
            <summary>
            Azimuthal angle range to define spherical surface
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSource">
            <summary>
            Implements CustomSurfaceEmittingSphericalSource with radius, source profile, 
            polar angle range, azimuthal angle range, direction, position and initial 
            tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomSurfaceEmittingSphericalSource.#ctor(System.Double,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of Custom Spherical Surface Emitting Source with a user defined surface area
            (based on polar azimuthal angle range), new source axis direction, and translation,
            </summary>
            <param name="radius">The radius of the sphere</param>
            <param name="polarAngleRangeToDefineSphericalSurface">Polar angle range to define the emitting area of the sphere</param>
            <param name="azimuthalAngleRangeToDefineSphericalSurface">Azimuthal angle range to define the emitting area of the sphere</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for LambertianSurfaceEmittingSphericalSource 
            implementation including radius, position and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSourceInput.#ctor(System.Double,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of LambertianSurfaceEmittingSphericalSourceInput class
            </summary>
            <param name="radius">The radius of the sphere</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSourceInput.#ctor(System.Double)">
            <summary>
            Initializes a new instance of LambertianSurfaceEmittingSphericalSourceInput class
            </summary>
            <param name="radius">The radius of the sphere</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSourceInput.#ctor">
            <summary>
            Initializes the default constructor of LambertianSurfaceEmittingSphericalSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSourceInput.SourceType">
            <summary>
            Spherical source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSourceInput.Radius">
            <summary>
            The radius of the sphere
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSource">
            <summary>
            Implements LambertianSurfaceEmittingSphericalSource with radius, position and
            initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingSphericalSource.#ctor(System.Double,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of Lambertian Spherical Surface Emitting Source with a specified translation.
            </summary>
            <param name="radius">The radius of the sphere</param> 
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase">
            <summary>
            Abstract class for SurfaceEmittingSphericalSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase._polarAngleRangeToDefineSphericalSurface">
            <summary>
            Polar angle range to define the emitting area of the sphere
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase._azimuthalAngleRangeToDefineSphericalSurface">
            <summary>
            Azimuthal angle range to define the emitting area of the sphere
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase._newDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase._translationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase._rotationAndTranslationFlags">
            <summary>
            Source rotation and translation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase._radius">
            <summary>
            The radius of the sphere
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase.#ctor(System.Double,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Defines SurfaceEmittingSphericalSourceBase class
            </summary>
            <param name="radius">The radius of the sphere</param>
            <param name="polarAngleRangeToDefineSphericalSurface">polar angle range to define the emitting area of the sphere</param>
            <param name="azimuthalAngleRangeToDefineSphericalSurface">azimuthal angle range to define the emitting area of the sphere</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SurfaceEmittingSphericalSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for LambertianSurfaceEmittingCuboidalSource 
            implementation including length, width, height, source profile, direction, position, and
            initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of LambertianSurfaceEmittingCuboidalSourceInput class
            </summary>
            <param name="cubeLengthX">The length of the cube (along x axis)</param>
            <param name="cubeWidthY">The width of the cube (along y axis)</param>
            <param name="cubeHeightZ">The height of the cube (along z axis)</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile)">
            <summary>
            Initializes a new instance of LambertianSurfaceEmittingCuboidalSourceInput class
            </summary>
            <param name="cubeLengthX">length</param>
            <param name="cubeWidthY">width</param>
            <param name="cubeHeightZ">height</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.#ctor">
            <summary>
            Initializes the default constructor of LambertianSurfaceEmittingCuboidalSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.SourceType">
            <summary>
            Surface Emitting Cuboidal source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.CubeLengthX">
            <summary>
            The length of the cube (along x axis)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.CubeWidthY">
            <summary>
            The width of the cube (along y axis)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.CubeHeightZ">
            <summary>
            The height of the cube (along z axis)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSource">
            <summary>
            Implements LambertianSurfaceEmittingCuboidalSource with length, width, height, source profile, 
            direction, position, and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingCuboidalSource.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of Lambertian Surface Emitting Cuboidal Source with a given source profile
            new source axis direction, and translation,
            </summary>
            <param name="cubeLengthX">The length of the cube (along x axis)</param>
            <param name="cubeWidthY">The width of the cube (along y axis)</param>
            <param name="cubeHeightZ">The height of the cube (along z axis)</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>       
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase">
            <summary>
            Abstract class for SurfaceEmittingCuboidalSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase._sourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase._polarAngleEmissionRange">
            <summary>
            Polar angle emission range
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase._newDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase._translationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase._rotationAndTranslationFlags">
            <summary>
            Source rotation and translation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase._cubeLengthX">
            <summary>
            The length of the cube (along x axis)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase._cubeWidthY">
            <summary>
            The width of the cube (along y axis)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase._cubeHeightZ">
            <summary>
            The height of the cube (along z axis)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Defines SurfaceEmittingCuboidalSourceBase class
            </summary>
            <param name="cubeLengthX">The length of the cube (along x axis)</param>
            <param name="cubeWidthY">The width of the cube (along y axis)</param>
            <param name="cubeHeightZ">The height of the cube (along z axis)</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle emission range {0 - 90degrees}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>  
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase.SelectEmittingSurface(System.Double,System.Double,System.Double,System.Random)">
            <summary>
            Select the cuboid surface after sampling
            </summary>
            <param name="lengthX">The length of the cube (along x axis)</param>
            <param name="widthY">The width of the cube (along y axis)</param>
            <param name="heightZ">The height of the cube (along z axis)</param>
            <param name="rng"></param>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SurfaceEmittingCuboidalSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for LambertianSurfaceEmittingTubularSource 
            implementation including tube radius, height, direction, position and initial tissue 
            region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput.#ctor(System.Double,System.Double,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of LambertianSurfaceEmittingTubularSourceInput class
            </summary>
            <param name="tubeRadius">Tube radius</param>
            <param name="tubeHeightZ">Tube height</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of LambertianSurfaceEmittingTubularSourceInput class
            </summary>
            <param name="tubeRadius">Tube radius</param>
            <param name="tubeHeightZ">Tube height</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput.#ctor">
            <summary>
            Initializes the default constructor of LambertianSurfaceEmittingTubularSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput.SourceType">
            <summary>
            Tubular source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput.TubeRadius">
            <summary>
            Tube radius
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput.TubeHeightZ">
            <summary>
            Tube height
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSource">
            <summary>
            Implements LambertianSurfaceEmittingTubularSource with tube radius, height, 
            direction, position and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.LambertianSurfaceEmittingTubularSource.#ctor(System.Double,System.Double,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of Lambertian Surface Emitting tube Source with source axis rotation and translation
            </summary>
            <param name="tubeRadius">Tube radius</param>
            <param name="tubeHeightZ">Tube height</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.SurfaceEmittingTubularSourceBase">
            <summary>
            Abstract class for SurfaceEmittingTubularSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingTubularSourceBase._newDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingTubularSourceBase._translationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingTubularSourceBase._rotationAndTranslationFlags">
            <summary>
            Source rotation and translation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingTubularSourceBase._tubeRadius">
            <summary>
            Tube radius
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingTubularSourceBase._tubeHeightZ">
            <summary>
            Tube height
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.SurfaceEmittingTubularSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SurfaceEmittingTubularSourceBase.#ctor(System.Double,System.Double,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Defines SurfaceEmittingTubularSourceBase class
            </summary>
            <param name="tubeRadius">Tube radius</param>
            <param name="tubeHeightZ">Tube height</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.SurfaceEmittingTubularSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.SurfaceEmittingTubularSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalArbitrarySurfaceSource">
            <summary>
            Implements DirectionalArbitrarySurfaceSource with converging/diverging angle, length, width,
            source profile, direction, position, inward normal beam rotation and initial tissue 
            region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalArbitrarySurfaceSource.#ctor(System.Double,System.Double,System.Double,System.Double[],System.Int32,System.Int32,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Defines DirectionalArbitrarySurfaceSource
            </summary>
            <param name="thetaConvOrDiv"></param>
            <param name="sourceLengthX">The length of the arbitrary (image-based) Source</param>
            <param name="sourceWidthY">The width of the arbitrary (image-based) Source</param>
            <param name="image"></param>
            <param name="pixelLengthX">pixel length X</param>
            <param name="pixelWidthY">pixel length Y</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>    
            <param name="beamRotationFromInwardNormal">Polar Azimuthal Rotational Angle of inward Normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput">
            <summary>
            Defines input data for CircularAngledFromCircleSource implementation 
            including radius, source profile, point position, and initial tissue region index.
            The angle of the source is determined by the position on the tissue surface (dictated by the source
            profile) and the *uniformly sampled* circle position in air.
            All of the "AngledFrom" series of sources translate the source on tissue
            and the source in air separately.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Position,System.Double,Vts.Common.Position,Vts.Common.Direction,System.Int32)">
            <summary>
            Initializes a new instance of CircularAngledFromCircleSourceInput class
            </summary>
            <param name="radiusOnTissue">The radius of the circular source on tissue surface</param>
            <param name="sourceProfile">source profile (Flat/Gaussian) of circle on tissue</param>
            <param name="translationFromOrigin">center of circle on tissue location</param>
            <param name="radiusInAir">radius of originating circle</param>
            <param name="circleInAirTranslationFromOrigin">Center of circle in air location</param>
            <param name="circleInAirRotation">Rotation of circle in air</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Position,System.Double,Vts.Common.Position,Vts.Common.Direction)">
            <summary>
            Initializes a new instance of CircularAngledFromCircleSourceInput class
            </summary>
            <param name="radiusOnTissue">Radius of the circular source on tissue surface</param>
            <param name="sourceProfile">source profile (Flat/Gaussian) of circle on tissue</param>
            <param name="translationFromOrigin">Circle on tissue translation</param>
            <param name="radiusInAir">Radius of circle in air</param>
            <param name="circleInAirTranslationFromOrigin">Circle in air location</param>
            <param name="circleInAirRotation">rotation of circle in air only</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.#ctor">
            <summary>
            Initializes the default constructor of CircularAngledFromCircleSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.SourceType">
            <summary>
            Circular source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.RadiusOnTissue">
            <summary>
            The radius of the circular source on tissue surface
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.TranslationFromOrigin">
            <summary>
            Circle on tissue translation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.RadiusInAir">
            <summary>
            The radius of the circular source in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.CircleInAirTranslationFromOrigin">
            <summary>
            Circle in Air translation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.CircleInAirRotation">
            <summary>
            Circle in Air Rotation 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromCircleSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CircularAngledFromCircleSource">
            <summary>
            Implements CircularAngledFromCircleSource with radius on tissue surface, source profile,  
            point position, and initial tissue region index. 
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromCircleSource.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Position,System.Double,Vts.Common.Position,Vts.Common.Direction,System.Int32)">
            <summary>
            Returns an instance of  Circular Source Angled From Point with specified radius,
            source profile (Flat/Gaussian), point position
            </summary>
            <param name="radiusOnTissue">The radius of the circular source on tissue surface</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="translationFromOrigin">Circle on tissue translation</param>
            <param name="radiusInAir">radius of circle in air</param>     
            <param name="circleInAirTranslationFromOrigin">circle in air translation</param>
            <param name="circleInAirRotation">circle in air rotation</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromCircleSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for CircularAngledFromPointSource implementation 
            including radius, source profile, point position, and initial tissue region index.
            The angle of the source is determined by the position on the tissue surface (dictated by the source
            profile) and the point position in the air.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Position,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of CircularAngledFromPointSourceInput class
            </summary>
            <param name="radius">The radius of the circular source on tissue surface</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="pointLocation">Location of originating point WITHOUT TRANSLATION</param>
            <param name="translationFromOrigin">Center of circle location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Position)">
            <summary>
            Initializes a new instance of CircularAngledFromPointSourceInput class
            </summary>
            <param name="radius">Radius of the circular source on tissue surface</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="pointLocation">Origin point location</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput.#ctor">
            <summary>
            Initializes the default constructor of CircularAngledFromPointSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput.SourceType">
            <summary>
            Circular source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput.Radius">
            <summary>
            The radius of the circular source on tissue surface
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput.PointLocation">
            <summary>
            Origin point location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromPointSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CircularAngledFromPointSource">
            <summary>
            Implements CircularAngledFromPointSource with radius on tissue surface, source profile,  
            point position, and initial tissue region index. 
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromPointSource.#ctor(System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Position,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of  Circular Source Angled From Point with specified radius,
            source profile (Flat/Gaussian), point position
            </summary>
            <param name="radius">The radius of the circular source on tissue surface</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param> 
            <param name="pointLocation">Origin point location</param>     
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularAngledFromPointSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CircularSourceBase">
            <summary>
            Abstract class for CircularSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.CircularSourceBase._sourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.CircularSourceBase._newDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction 
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.CircularSourceBase._translationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.CircularSourceBase._beamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.CircularSourceBase._rotationAndTranslationFlags">
            <summary>
            Source rotation and translation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.CircularSourceBase._outerRadius">
            <summary>
            The outer radius of the circular source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.CircularSourceBase._innerRadius">
            <summary>
            The inner radius of the circular source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.CircularSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularSourceBase.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Defines CircularSourceBase class
            </summary>
            <param name="innerRadius">The inner radius of the circular source</param>
            <param name="outerRadius">The outer radius of the circular source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param> 
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">Polar Azimuthal Rotational Angle of inward Normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CircularSourceBase.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns final direction for a given position
            </summary>
            <param name="position">Current position</param>
            <returns>new direction</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CircularSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomCircularSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for CustomCircularSource implementation 
            including inner and outer radius, source profile, polar angle range, azimuthal angle 
            range, direction, position, inward normal beam rotation and initial tissue region index. 
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomCircularSourceInput.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of CustomCircularSourceInput class
            </summary>
            <param name="outerRadius">The outer radius of the circular source</param>
            <param name="innerRadius">The inner radius of the circular source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">Beam rotation from inward normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomCircularSourceInput.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange)">
            <summary>
            Initializes a new instance of CustomCircularSourceInput class
            </summary>
            <param name="outerRadius">The outer radius of the circular source</param>
            <param name="innerRadius">The inner radius of the circular source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomCircularSourceInput.#ctor">
            <summary>
            Initializes the default constructor of CustomCircularSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomCircularSourceInput.SourceType">
            <summary>
            Circular source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomCircularSourceInput.OuterRadius">
            <summary>
            The outer radius of the circular source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomCircularSourceInput.InnerRadius">
            <summary>
            The inner radius of the circular source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomCircularSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomCircularSourceInput.PolarAngleEmissionRange">
            <summary>
            Polar angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomCircularSourceInput.AzimuthalAngleEmissionRange">
            <summary>
            Azimuthal angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomCircularSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomCircularSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomCircularSourceInput.BeamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomCircularSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomCircularSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomCircularSource">
            <summary>
            Implements CustomCircularSource with inner and outer radius, source profile, polar angle range, 
            azimuthal angle range, direction, position, inward normal beam rotation and initial tissue region
            index. 
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomCircularSource.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Returns an instance of  Custom Circular Source with specified length and width, source profile (Flat/Gaussian), 
            polar and azimuthal angle range, new source axis direction, translation, and  inward normal ray rotation
            </summary>
            <param name="innerRadius">The inner radius of the circular source</param>
            <param name="outerRadius">The outer radius of the circular source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle emission range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle emission range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param> 
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">Polar Azimuthal Rotational Angle of inward Normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomCircularSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for DirectionalCircularSource implementation 
            including converging/diverging angle, inner and outer radius, source profile, direction,
            position, inward normal beam rotation and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of DirectionalCircularSourceInput class
            </summary>
            <param name="thetaConvOrDiv">Convergence(negative angle in radians) or Divergence (positive angle in radians) angle {= 0, for a collimated beam}</param>
            <param name="outerRadius">The outer radius of the circular source</param>
            <param name="innerRadius">The inner radius of the circular source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">beam rotation angle</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile)">
            <summary>
            Initializes a new instance of DirectionalCircularSourceInput class
            </summary>
            <param name="thetaConvOrDiv">Convergence(negative angle in radians) or Divergence (positive angle in radians) angle {= 0, for a collimated beam}</param>
            <param name="outerRadius">The outer radius of the circular source</param>
            <param name="innerRadius">The inner radius of the circular source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.#ctor">
            <summary>
            Initializes the default constructor of DirectionalCircularSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.ThetaConvOrDiv">
            <summary>
            Convergence(negative angle in radians) or Divergence (positive angle in radians) angle {= 0, for a collimated beam}
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.SourceType">
            <summary>
            Circular source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.OuterRadius">
            <summary>
            The outer radius of the circular source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.InnerRadius">
            <summary>
            The inner radius of the circular source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.BeamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalCircularSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalCircularSource">
            <summary>
            Implements DirectionalCircularSource with converging/diverging angle, inner and outer radius,
            source profile, direction, position, inward normal beam rotation and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalCircularSource.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Returns an instance of directional (diverging/converging/collimated) Circular Source with specified length and width, 
            source profile (Flat/Gaussian), polar and azimuthal angle range, new source axis direction, translation, and  inward normal ray rotation
            </summary>
            <param name="thetaConvOrDiv">Convergence(negative angle in radians) or Divergence (positive angle in radians) angle {= 0, for a collimated beam}</param>
            <param name="innerRadius">The inner radius of the circular source</param>
            <param name="outerRadius">The outer radius of the circular source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">Polar Azimuthal Rotational Angle of inward Normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalCircularSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for CustomEllipticalSource implementation 
            including a and b parameter, source profile, polar angle range, azimuthal angle 
            range, direction, position, inward normal beam rotation, and initial tissue 
            region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of CustomEllipticalSourceInput class
            </summary>
            <param name="aParameter">"a" parameter of the ellipse source</param>
            <param name="bParameter">"b" parameter of the ellipse source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">beam rotation angle</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange)">
            <summary>
            Initializes a new instance of CustomEllipticalSourceInput class
            </summary>
            <param name="aParameter">"a" parameter of the ellipse source</param>
            <param name="bParameter">"b" parameter of the ellipse source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.#ctor">
            <summary>
            Initializes the default constructor of CustomEllipticalSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.SourceType">
            <summary>
            Elliptical source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.AParameter">
            <summary>
            "a" parameter of the ellipse source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.BParameter">
            <summary>
            "b" parameter of the ellipse source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.PolarAngleEmissionRange">
            <summary>
            Polar angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.AzimuthalAngleEmissionRange">
            <summary>
            Azimuthal angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.BeamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomEllipticalSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomEllipticalSource">
            <summary>
            Implements CustomEllipticalSource with a and b parameter, source profile, polar
            angle range, azimuthal angle range, direction, position and inward normal beam 
            rotation, and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomEllipticalSource.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Returns an instance of  Custom Elliptical Source with specified length and width, source profile (Flat/Gaussian), 
            polar and azimuthal angle range, new source axis direction, translation, and  inward normal ray rotation
            </summary>
            <param name="aParameter">"a" parameter of the ellipse source</param>
            <param name="bParameter">"b" parameter of the ellipse source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle emission range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle emission range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>    
            <param name="beamRotationFromInwardNormal">Polar Azimuthal Rotational Angle of inward Normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomEllipticalSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for DirectionalellipticalSource implementation 
            including converging/diverging angle, a and b parameters, source profile, direction, 
            position, inward normal beam rotation and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of DirectionalEllipticalSourceInput class
            </summary>
            <param name="thetaConvOrDiv">Covergence or Divergance Angle {= 0, for a collimated beam}</param>
            <param name="aParameter">"a" parameter of the ellipse source</param>
            <param name="bParameter">"b" parameter of the ellipse source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">beam rotation angle</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile)">
            <summary>
            Initializes a new instance of DirectionalEllipticalSourceInput class
            </summary>
            <param name="thetaConvOrDiv">Covergence or Divergance Angle {= 0, for a collimated beam}</param>
            <param name="aParameter">"a" parameter of the ellipse source</param>
            <param name="bParameter">"b" parameter of the ellipse source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.#ctor">
            <summary>
            Initializes the default constructor of DirectionalEllipticalSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.ThetaConvOrDiv">
            <summary>
            Covergence or Divergance Angle {= 0, for a collimated beam}
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.SourceType">
            <summary>
            Elliptical source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.AParameter">
            <summary>
            "a" parameter of the ellipse source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.BParameter">
            <summary>
            "b" parameter of the ellipse source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.BeamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalEllipticalSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalEllipticalSource">
            <summary>
            Implements DirectionalellipticalSource with converging/diverging angle, a and b
            parameters, source profile, direction, position, inward normal beam rotation and
            initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalEllipticalSource.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Returns an instance of directional (diverging/converging/collimated) Elliptical Source with specified length and width, 
            source profile (Flat/Gaussian), polar and azimuthal angle range, new source axis direction, translation, and  inward normal ray rotation
            </summary>
            <param name="thetaConvOrDiv">Covergence or Divergance Angle {= 0, for a collimated beam}</param>
            <param name="aParameter">"a" parameter of the ellipse source</param>
            <param name="bParameter">"b" parameter of the ellipse source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>    
            <param name="beamRotationFromInwardNormal">Polar Azimuthal Rotational Angle of inward Normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalEllipticalSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.EllipticalSourceBase">
            <summary>
            Abstract class for EllipticalSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.EllipticalSourceBase._sourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.EllipticalSourceBase._newDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.EllipticalSourceBase._translationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.EllipticalSourceBase._beamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.EllipticalSourceBase._rotationAndTranslationFlags">
            <summary>
            Source rotation and translation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.EllipticalSourceBase._aParameter">
            <summary>
            "a" parameter of the ellipse source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.EllipticalSourceBase._bParameter">
            <summary>
            "b" parameter of the ellipse source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.EllipticalSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.EllipticalSourceBase.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Defines EllipticalSourceBase class
            </summary>
            <param name="aParameter">"a" parameter of the ellipse source</param>
            <param name="bParameter">"b" parameter of the ellipse source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>    
            <param name="beamRotationFromInwardNormal">Polar Azimuthal Rotational Angle of inward Normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.EllipticalSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.EllipticalSourceBase.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns final direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.EllipticalSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomRectangularSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for CustomRectangularSource implementation 
            including length, width, source profile, polar angle range, azimuthal angle 
            range, direction, position, inward normal beam rotation and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of CustomRectangularSourceInput class
            </summary>
            <param name="rectLengthX">The length of the Rectangular Source</param>
            <param name="rectWidthY">The width of the Rectangular Source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">beam rotation angle</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange)">
            <summary>
            Initializes a new instance of CustomRectangularSourceInput class
            </summary>
            <param name="rectLengthX">The length of the Rectangular Source</param>
            <param name="rectWidthY">The width of the Rectangular Source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.#ctor">
            <summary>
            Initializes the default constructor of CustomRectangularSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.SourceType">
            <summary>
            Rectangular source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.RectLengthX">
            <summary>
            The length of the Rectangular Source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.RectWidthY">
            <summary>
            The width of the Rectangular Source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.PolarAngleEmissionRange">
            <summary>
            Polar angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.AzimuthalAngleEmissionRange">
            <summary>
            Azimuthal angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.BeamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomRectangularSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomRectangularSource">
            <summary>
            Implements CustomRectangularSource with length, width, source profile, polar angle range, 
            azimuthal angle range, direction, position, inward normal beam rotation and initial tissue
            region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomRectangularSource.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Returns an instance of Custom Rectangular Source with specified length and width, source profile (Flat/Gaussian), 
            polar and azimuthal angle range, translation, inward normal rotation, and source axis rotation
            </summary>
            <param name="rectLengthX">The length of the Rectangular Source</param>
            <param name="rectWidthY">The width of the Rectangular Source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle emission range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle emission range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>    
            <param name="beamRotationFromInwardNormal">Polar Azimuthal Rotational Angle of inward Normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomRectangularSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for DirectionalRectangularSource implementation 
            including converging/diverging angle, length, width, source profile, direction, position, 
            inward normal beam rotation and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Initializes a new instance of the DirectionalRectangularSourceInput class
            </summary>
            <param name="thetaConvOrDiv">Covergence or Divergance Angle {= 0, for a collimated beam}</param>
            <param name="rectLengthX">The length of the Rectangular Source</param>
            <param name="rectWidthY">The width of the Rectangular Source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="beamRotationFromInwardNormal">beam rotation angle</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile)">
            <summary>
            Initializes a new instance of the DirectionalRectangularSourceInput class
            </summary>
            <param name="thetaConvOrDiv">Covergence or Divergance Angle {= 0, for a collimated beam}</param>
            <param name="rectLengthX">The length of the Rectangular Source</param>
            <param name="rectWidthY">The width of the Rectangular Source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.#ctor">
            <summary>
            Initializes a new instance of the DirectionalRectangularSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.ThetaConvOrDiv">
            <summary>
            Covergence or Divergance Angle {= 0, for a collimated beam}
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.SourceType">
            <summary>
            Rectangular source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.RectLengthX">
            <summary>
            The length of the Rectangular Source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.RectWidthY">
            <summary>
            The width of the Rectangular Source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.BeamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalRectangularSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.DirectionalRectangularSource">
            <summary>
            Implements DirectionalRectangularSource with converging/diverging angle, length, width,
            source profile, direction, position, inward normal beam rotation and initial tissue 
            region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalRectangularSource.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Returns an instance of directional (diverging/converging/collimated) Rectangular Source with specified length and width, 
            source profile (Flat/Gaussian), polar and azimuthal angle range, new source axis direction, translation, and  inward normal ray rotation
            </summary>
            <param name="thetaConvOrDiv">Covergence or Divergance Angle {= 0, for a collimated beam}</param>
            <param name="rectLengthX">The length of the Rectangular Source</param>
            <param name="rectWidthY">The width of the Rectangular Source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>    
            <param name="beamRotationFromInwardNormal">Polar Azimuthal Rotational Angle of inward Normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.DirectionalRectangularSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for RectangularAngledFromCircleSource
            implementation including length, width, source profile,
            and initial tissue region index.
            The angle of the source is determined by the position on the tissue surface (dictated
            by the source profile) and the *uniformly sampled* circle position in air.
            All of the "AngledFrom" series of sources translate the source on tissue
            and the source in air separately.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Position,System.Double,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of RectangularAngledFromCircleSourceInput class
            </summary>
            <param name="rectLengthX">The length of the Rectangular Source</param>
            <param name="rectWidthY">The width of the Rectangular Source</param>
            <param name="sourceProfile">source profile (Flat/Gaussian) of rectangle on tissue</param>
            <param name="translationFromOrigin">rectangle on tissue surface translation</param>
            <param name="radiusInAir">radius of originating circle</param>
            <param name="circleInAirTranslationFromOrigin">Center of circle in air location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.#ctor">
            <summary>
            Initializes the default constructor of RectangularAngledFromCircleSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.SourceType">
            <summary>
            Rectangular source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.RectLengthX">
            <summary>
            The length of the Rectangular Source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.RectWidthY">
            <summary>
            The width of the Rectangular Source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.TranslationFromOrigin">
            <summary>
            Rectangle on tissue surface translation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.RadiusInAir">
            <summary>
            radius of circle in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.CircleInAirTranslationFromOrigin">
            <summary>
            Circle in air translation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSource">
            <summary>
            Implements RectangularAngledFromCircleSource with length, width, source profile,  
            circle in air translation from origin, and initial tissue
            region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSource.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Position,System.Double,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of Custom Rectangular Source with specified length and width,
            source profile (Flat/Gaussian),translation of circle in air
            </summary>
            <param name="rectLengthX">The length of the Rectangular Source</param>
            <param name="rectWidthY">The width of the Rectangular Source</param>
            <param name="sourceProfile">Source profile (Flat/Gaussian) of rectangle on tissue surface</param>  
            <param name="translationFromOrigin">New rectangular source location</param>    
            <param name="radiusInAir">radius of circle in air</param>
            <param name="circleInAirTranslationFromOrigin">New circle in air location</param>    
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.RectangularAngledFromCircleSource.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns direction for a given position
            </summary>
            <param name="position">position</param>
            <returns>new direction</returns>  
        </member>
        <member name="T:Vts.MonteCarlo.Sources.RectangularSourceBase">
            <summary>
            Abstract class for RectangularSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.RectangularSourceBase._sourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.RectangularSourceBase._newDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.RectangularSourceBase._translationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.RectangularSourceBase._beamRotationFromInwardNormal">
            <summary>
            Beam rotation from inward normal
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.RectangularSourceBase._rotationAndTranslationFlags">
            <summary>
            Source rotation and translation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.RectangularSourceBase._rectLengthX">
            <summary>
            The length of the Rectangular Source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.RectangularSourceBase._rectWidthY">
            <summary>
            The width of the Rectangular Source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.RectangularSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.RectangularSourceBase.#ctor(System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,Vts.MonteCarlo.Helpers.PolarAzimuthalAngles,System.Int32)">
            <summary>
            Defines RectangularSourceBase class
            </summary>
            <param name="rectLengthX">The length of the Rectangular Source</param>
            <param name="rectWidthY">The width of the Rectangular Source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>    
            <param name="beamRotationFromInwardNormal">Polar Azimuthal Rotational Angle of inward Normal</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.RectangularSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.RectangularSourceBase.GetFinalDirection(Vts.Common.Position)">
            <summary>
            Returns final direction for a given position
            </summary>
            <param name="position">Current position</param>
            <returns>new direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.RectangularSourceBase.GetFinalPosition">
            <summary>
            returns final position
            </summary>
            <returns>Position</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.RectangularSourceBase.GetFinalPositionFromProfileType(Vts.MonteCarlo.Interfaces.ISourceProfile,System.Double,System.Double,System.Random)">
            <summary>
            returns final position from profile type
            </summary>
            <param name="sourceProfile">ISourceProfile</param>
            <param name="rectLengthX">rectangular length in x direction (length)</param>
            <param name="rectWidthY">rectangular length in y direction (width)</param>
            <param name="rng">random number generator</param>
            <returns>Position</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.RectangularSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for CustomVolumetricEllipsoidalSource 
            implementation including a,b and c parameters, source profile, polar angle range,
            azimuthal angle range, direction, position and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of CustomVolumetricEllipsoidalSourceInput class
            </summary>
            <param name="aParameter">"a" parameter of the ellipsoid source</param>
            <param name="bParameter">"b" parameter of the ellipsoid source</param>
            <param name="cParameter">"c" parameter of the ellipsoid source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange)">
            <summary>
            Initializes a new instance of CustomVolumetricEllipsoidalSourceInput class
            </summary>
            <param name="aParameter">"a" parameter of the ellipsoid source</param>
            <param name="bParameter">"b" parameter of the ellipsoid source</param>
            <param name="cParameter">"c" parameter of the ellipsoid source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.#ctor">
            <summary>
            Initializes the default constructor of CustomVolumetricEllipsoidalSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.SourceType">
            <summary>
            Ellipsoidal source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.AParameter">
            <summary>
            "a" parameter of the ellipsoid source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.BParameter">
            <summary>
            "b" parameter of the ellipsoid source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.CParameter">
            <summary>
            "c" parameter of the ellipsoid source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.PolarAngleEmissionRange">
            <summary>
            Polar angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.AzimuthalAngleEmissionRange">
            <summary>
            Azimuthal angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSource">
            <summary>
            Implements CustomVolumetricEllipsoidalSource with a,b and c parameters, source 
            profile, polar angle range, azimuthal angle range, direction, position and 
            initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSource.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of  Custom Ellipsoidal Source with a given source profile (Flat/Gaussian), 
            polar and azimuthal angle range, new source axis direction, and translation,
            </summary>
            <param name="aParameter">"a" parameter of the ellipsoid source</param>
            <param name="bParameter">"b" parameter of the ellipsoid source</param>
            <param name="cParameter">"c" parameter of the ellipsoid source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle emission range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle emission range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricEllipsoidalSource.GetFinalDirection">
            <summary>
            Returns direction
            </summary>
            <returns>new direction</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for IsotropicVolumetricCuboidalSource
            implementation including length, width, height, source profile, direction, position, 
            and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of IsotropicVolumetricEllipsoidalSourceInput class
            </summary>
            <param name="aParameter">"a" parameter of the ellipsoid source</param>
            <param name="bParameter">"b" parameter of the ellipsoid source</param>
            <param name="cParameter">"c" parameter of the ellipsoid source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile)">
            <summary>
            Initializes a new instance of IsotropicVolumetricEllipsoidalSourceInput class
            </summary>
            <param name="aParameter">"a" parameter of the ellipsoid source</param>
            <param name="bParameter">"b" parameter of the ellipsoid source</param>
            <param name="cParameter">"c" parameter of the ellipsoid source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.#ctor">
            <summary>
            Initializes the default constructor of IsotropicVolumetricEllipsoidalSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.SourceType">
            <summary>
            Ellipsoidal source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.AParameter">
            <summary>
            "a" parameter of the ellipsoid source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.BParameter">
            <summary>
            "b" parameter of the ellipsoid source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.CParameter">
            <summary>
            "c" parameter of the ellipsoid source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSource">
            <summary>
            Implements IsotropicVolumetricEllipsoidalSource with a,b and c parameters, 
            source profile, direction, position, and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSource.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of  Isotropic Ellipsoidal Source with a given source profile (Flat/Gaussian), 
             new source axis direction, and translation.
            </summary>
            <param name="aParameter">"a" parameter of the ellipsoid source</param>
            <param name="bParameter">"b" parameter of the ellipsoid source</param>
            <param name="cParameter">"c" parameter of the ellipsoid source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricEllipsoidalSource.GetFinalDirection">
            <summary>
            Returns direction
            </summary>
            <returns>new direction</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase">
            <summary>
            Abstract class for VolumetricEllipsoidalSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase._sourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase._newDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase._translationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase._rotationAndTranslationFlags">
            <summary>
            Source rotation and translation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase._aParameter">
            <summary>
            "a" parameter of the ellipsoid source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase._bParameter">
            <summary>
            "b" parameter of the ellipsoid source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase._cParameter">
            <summary>
            "c" parameter of the ellipsoid source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Defines VolumetricEllipsoidalSourceBase class
            </summary>
            <param name="aParameter">"a" parameter of the ellipsoid source</param>
            <param name="bParameter">"b" parameter of the ellipsoid source</param>
            <param name="cParameter">"c" parameter of the ellipsoid source</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase.GetFinalDirection">
            <summary>
            Returns direction
            </summary>
            <returns>new direction</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.VolumetricEllipsoidalSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.AOfRhoAndZLoader">
            <summary>
            class to handle loading of absorbed energy results from prior simulation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.Rho">
            <summary>
            rho bins 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.Z">
            <summary>
            z bins 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.AOfRhoAndZ">
            <summary>
            AOfRhoAndZ of *entire* tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.MapOfRhoAndZ">
            <summary>
            Map of fluorescent tissue region with 1's identifying region within AOfRhoAndZ for debugging purposes
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.PDFOfRhoAndZ">
            <summary>
            PDF of fluorescent tissue region subset of AOfRhoAndZ 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.TotalProb">
            <summary>
            sum of ProbOfRhoAndZ
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.CDFOfRhoAndZ">
            <summary>
            CDF of fluorescent tissue region first index=row dominant index of MapOfRhoAndZ
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.FluorescentTissueRegion">
            <summary>
            tissue region of fluorescence
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.BoundedTissueRegion">
            <summary>
            potential bounding of FluorescentTissueRegion
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.FluorescentRegionIndicesInOrder">
            <summary>
            dictionary that maps key=count to triple of indices to go through AOfRhoAndZ fluorescent region in order
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.#ctor(System.String,System.String,System.Int32)">
            <summary>
            constructor that load excitation simulation AOfRhoAndZ
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.AOfRhoAndZLoader.InitializeFluorescentRegionArrays">
            <summary>
            method to initialize fluorescent region arrays that are used to sample the fluorescent source
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader">
            <summary>
            class to handle loading of absorbed energy results from prior simulation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.X">
            <summary>
            x bins 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.Y">
            <summary>
            y bins centers
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.Z">
            <summary>
            z bins 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.AOfXAndYAndZ">
            <summary>
            AOfXAndYAndZ of *entire* tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.MapOfXAndYAndZ">
            <summary>
            Map of fluorescent tissue region with 1's identifying region within AOfXAndYAndZ for debugging purposes
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.PDFOfXAndYAndZ">
            <summary>
            PDF of fluorescent tissue region subset of AOfXAndYAndZ 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.TotalProb">
            <summary>
            sum of ProbOfXAndYAndZ
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.CDFOfXAndYAndZ">
            <summary>
            CDF of fluorescent tissue region first index=row dominant index of MapOfXAndYAndZ
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.FluorescentTissueRegion">
            <summary>
            tissue region of fluorescence
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.BoundedTissueRegion">
            <summary>
            potential bounding of FluorescentTissueRegion
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.FluorescentRegionIndicesInOrder">
            <summary>
            dictionary that maps key=count to triple of indices to go through AOfXAndYAndZ fluorescent region in order
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.#ctor(System.String,System.String,System.Int32)">
            <summary>
            constructor that load excitation simulation AOfXAndYAndZ
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.AOfXAndYAndZLoader.InitializeFluorescentRegionArrays">
            <summary>
            method to initialize the fluorescent region arrays that are used to sample fluorescent source
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for FluorescenceEmissionAOfRhoAndZSource 
            implementation.  This source reads the Cartesian coordinate absorbed energy results of a
            prior simulation and uses it to generate an emission source.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSourceInput.#ctor(System.String,System.String,System.Int32,Vts.MonteCarlo.SourcePositionSamplingType)">
            <summary>
            Initializes a new instance of FluorescenceEmissionAOfRhoAndZSourceInput class
            </summary>
            <param name="inputFolder">Folder where AOfRhoAndZ resides</param>
            <param name="infile">Infile for simulation that generated AOfRhoAndZ</param>
            <param name="initialTissueRegionIndex">Tissue region of fluorescence</param>
            <param name="samplingMethod">sample initial position: CDF from AE or Uniform</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSourceInput.#ctor">
            <summary>
            Initializes the default constructor of FluorescenceEmissionAOfRhoAndZSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSourceInput.SourceType">
            <summary>
             fluorescence emission source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSourceInput.InputFolder">
            <summary>
            Input folder where AE(x,y,z) resides
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSourceInput.Infile">
            <summary>
            Infile that generated AOfRhoAndZ
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index = tissue region index of fluorescence
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSourceInput.SamplingMethod">
            <summary>
            Sampling method for location and associated weight
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSource">
            <summary>
            Implements FluorescenceEmissionAOfRhoAndZSource with AOfRhoAndZ created from prior
            simulation and initial tissue region index.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSource.Loader">
            <summary>
            class that holds all Source arrays for proper initiation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSource.SamplingMethod">
            <summary>
            Sampling method flag
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSource.IndexCount">
            <summary>
            key into dictionary of indices
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSource.#ctor(System.String,System.String,System.Int32,Vts.MonteCarlo.SourcePositionSamplingType)">
            <summary>
            Returns an instance of  Fluorescence Emission AOfRhoAndZ Source with
            a Lambertian angular distribution.
            </summary>
            <param name="inputFolder">folder where A(rho,z) resides</param>
            <param name="infile">infile that generated A(rho,z)</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
            <param name="samplingMethod">SourcePositionSamplingType(CDF,Uniform)</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfRhoAndZSource.GetFinalPositionAndWeight(System.Random,System.Double@)">
            <summary>
            method to determine final fluorescent source photon position and weight
            </summary>
            <param name="rng">random number generator</param>
            <param name="weight">return weight</param>
            <returns>photon position</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for FluorescenceEmissionAOfXAndYAndZSource 
            implementation.  This source reads the Cartesian coordinate absorbed energy results of a
            prior simulation and uses it to generate an emission source.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSourceInput.#ctor(System.String,System.String,System.Int32,Vts.MonteCarlo.SourcePositionSamplingType)">
            <summary>
            Initializes a new instance of FluorescenceEmissionAOfXAndYAndZSourceInput class
            </summary>
            <param name="inputFolder">Folder where AOfXAndYAndZ resides</param>
            <param name="infile">Infile for simulation that generated AOfXAndYAndZ</param>
            <param name="initialTissueRegionIndex">Tissue region of fluorescence</param>
            <param name="samplingMethod">sample initial position: CDF from AE or Uniform</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSourceInput.#ctor">
            <summary>
            Initializes the default constructor of FluorescenceEmissionAOfXAndYAndZSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSourceInput.SourceType">
            <summary>
             fluorescence emission source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSourceInput.InputFolder">
            <summary>
            Input folder where AE(x,y,z) resides
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSourceInput.Infile">
            <summary>
            Infile that generated AOfXAndYAndZ
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index = tissue region index of fluorescence
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSourceInput.SamplingMethod">
            <summary>
            Sampling method for location and associated weight
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSource">
            <summary>
            Implements FluorescenceEmissionAOfXAndYAndZSource with AOfXAndYAndZ created from prior
            simulation and initial tissue region index.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSource.Loader">
            <summary>
            class that holds all Source arrays for proper initiation
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSource.SamplingMethod">
            <summary>
            Sampling method flag
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSource.IndexCount">
            <summary>
            key into dictionary of indices
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSource.#ctor(System.String,System.String,System.Int32,Vts.MonteCarlo.SourcePositionSamplingType)">
            <summary>
            Returns an instance of  Fluorescence Emission AOfXAndYAndZ Source with
            a Lambertian angular distribution.
            </summary>
            <param name="inputFolder">folder where A(x,y,z) resides</param>
            <param name="infile">infile that generated A(x,y,z)</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
            <param name="samplingMethod">SourcePositionSamplingtype(CDF,Uniform)</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionAOfXAndYAndZSource.GetFinalPositionAndWeight(System.Random,System.Double@)">
            <summary>
            Method to determine source photon position and weight
            </summary>
            <param name="rng">random number generator</param>
            <param name="weight">return photon weight</param>
            <returns>photon position</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.FluorescenceEmissionSourceBase">
            <summary>
            Abstract class for FluorescenceEmissionSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.FluorescenceEmissionSourceBase._inputFolder">
            <summary>
            Input folder where AE(x,y,z) resides
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.FluorescenceEmissionSourceBase._infile">
            <summary>
            Infile that generated AOfXAndYAndZ
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.FluorescenceEmissionSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index = tissue region of fluorescence
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.FluorescenceEmissionSourceBase._weight">
            <summary>
            Photon weight as determined by GetNextPositionAndWeight
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionSourceBase.#ctor(System.String,System.String,System.Int32)">
            <summary>
            Defines FluorescenceEmissionSourceBase class
            </summary>
            <param name="inputFolder">folder where absorbed energy result resides</param>
            <param name="infile">infile that was used to generate absorbed energy result</param>
            <param name="fluorescenceTissueRegionIndex">tissue region index of fluorescent region</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionSourceBase.GetFinalDirection(System.Random)">
            <summary>
            Returns Lambertian direction - all fluorescence emission is Lambertian
            </summary>
            <param name="rng">random number generator</param>
            <returns>photon Direction</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.FluorescenceEmissionSourceBase.GetFinalPositionAndWeight(System.Random,System.Double@)">
            <summary>
            each inheritor generates own GetFinalPositionAndWeight
            </summary>
            <param name="rng">random number generator</param>
            <param name="weight">out: photon weight</param>
            <returns>photon Position</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.FluorescenceEmissionSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for CustomVolumetricCuboidalSource 
            implementation including length, width, height, source profile, polar angle range,
            azimuthal angle range, direction, position and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of CustomVolumetricCuboidalSourceInput class
            </summary>
            <param name="cubeLengthX">Length of the cuboid</param>
            <param name="cubeWidthY">Width of the cuboid</param>
            <param name="cubeHeightZ">Height of the cuboid</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange)">
            <summary>
            Initializes a new instance of CustomVolumetricCuboidalSourceInput class
            </summary>
            <param name="cubeLengthX">Length of the cuboid</param>
            <param name="cubeWidthY">Width of the cuboid</param>
            <param name="cubeHeightZ">Height of the cuboid</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle range</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.#ctor">
            <summary>
            Initializes the default constructor of CustomVolumetricCuboidalSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.SourceType">
            <summary>
            Volumetric Cuboidal source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.CubeLengthX">
            <summary>
            The length of the cube (along x axis)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.CubeWidthY">
            <summary>
            The width of the cube (along y axis)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.CubeHeightZ">
            <summary>
            The height of the cube (along z axis)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.PolarAngleEmissionRange">
            <summary>
            Polar angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.AzimuthalAngleEmissionRange">
            <summary>
            Azimuthal angle range
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSource">
            <summary>
            Implements CustomVolumetricCuboidalSource with length, width, height, source 
            profile, polar angle range,azimuthal angle range, direction, position and 
            initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSource.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.DoubleRange,Vts.Common.DoubleRange,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of  Custom Cuboidal Source with a given source profile (Flat/Gaussian), 
            polar and azimuthal angle range, new source axis direction, and translation.
            </summary>
            <param name="cubeLengthX">The length of the cuboid</param>
            <param name="cubeWidthY">The width of the cuboid</param>
            <param name="cubeHeightZ">The height of the cuboid</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="polarAngleEmissionRange">Polar angle emission range</param>
            <param name="azimuthalAngleEmissionRange">Azimuthal angle emission range</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.CustomVolumetricCuboidalSource.GetFinalDirection">
            <summary>
            Returns direction
            </summary>
            <returns>new direction</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput">
            <summary>
            Implements ISourceInput. Defines input data for IsotropicVolumetricCuboidalSource
            implementation including length, width, height, source profile, direction, position, 
            and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Initializes a new instance of IsotropicVolumetricCuboidalSourceInput class
            </summary>
            <param name="cubeLengthX">Length of the cuboid</param>
            <param name="cubeWidthY">Width of the cuboid</param>
            <param name="cubeHeightZ">Height of the cuboid</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile)">
            <summary>
            Initializes a new instance of IsotropicVolumetricCuboidalSourceInput class
            </summary>
            <param name="cubeLengthX">Length of the cuboid</param>
            <param name="cubeWidthY">Width of the cuboid</param>
            <param name="cubeHeightZ">Height of the cuboid</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.#ctor">
            <summary>
            Initializes the default constructor of IsotropicVolumetricCuboidalSourceInput class
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.SourceType">
            <summary>
            Volumetric Cuboidal source type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.CubeLengthX">
            <summary>
            The length of the cube (along x axis)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.CubeWidthY">
            <summary>
            The width of the cube (along y axis)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.CubeHeightZ">
            <summary>
            The height of the cube (along z axis)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.SourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.NewDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.TranslationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.InitialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSource">
            <summary>
            Implements IsotropicVolumetricCuboidalSource with length, width, height, source
            profile, direction, position, and initial tissue region index.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSource.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Returns an instance of  Isotropic Cuboidal Source with a given source profile (Flat/Gaussian), 
            translation, and source axis rotation
            </summary>
            <param name="cubeLengthX">The length of the cuboid</param>
            <param name="cubeWidthY">The width of the cuboid</param>
            <param name="cubeHeightZ">The height of the cuboid</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.IsotropicVolumetricCuboidalSource.GetFinalDirection">
            <summary>
            Returns direction
            </summary>
            <returns>new direction</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase">
            <summary>
            Abstract class for VolumetricCuboidalSourceBase
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase._sourceProfile">
            <summary>
            Source profile type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase._newDirectionOfPrincipalSourceAxis">
            <summary>
            New source axis direction
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase._translationFromOrigin">
            <summary>
            New source location
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase._rotationAndTranslationFlags">
            <summary>
            Source rotation and translation flags
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase._cubeLengthX">
            <summary>
            The length of the cuboid
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase._cubeWidthY">
            <summary>
            The width of the cuboid
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase._cubeHeightZ">
            <summary>
            The height of the cuboid
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase._initialTissueRegionIndex">
            <summary>
            Initial tissue region index
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase.#ctor(System.Double,System.Double,System.Double,Vts.MonteCarlo.Interfaces.ISourceProfile,Vts.Common.Direction,Vts.Common.Position,System.Int32)">
            <summary>
            Defines VolumetricCuboidalSourceBase class
            </summary>
            <param name="cubeLengthX">The length of the cuboid</param>
            <param name="cubeWidthY">The width of the cuboid</param>
            <param name="cubeHeightZ">The height of the cuboid</param>
            <param name="sourceProfile">Source Profile {Flat / Gaussian}</param>
            <param name="newDirectionOfPrincipalSourceAxis">New source axis direction</param>
            <param name="translationFromOrigin">New source location</param>
            <param name="initialTissueRegionIndex">Initial tissue region index</param>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Implements Get next photon
            </summary>
            <param name="tissue">tissue</param>
            <returns>photon</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase.GetFinalDirection">
            <summary>
            Returns direction
            </summary>
            <returns>new direction</returns>
        </member>
        <member name="P:Vts.MonteCarlo.Sources.VolumetricCuboidalSourceBase.Rng">
            <summary>
            The random number generator used to create photons. If not assigned externally,
            a Mersenne Twister (MathNet.Numerics.Random.MersenneTwister) will be created with
            a seed of zero.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.IDetector">
            <summary>
            Properties and methods that all IDetectors must implement
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IDetector.TallyType">
            <summary>
            TallyType enum specification
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IDetector.Name">
            <summary>
            Name string of IDetector.  Default = TallyType.ToString().
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IDetector.TallySecondMoment">
            <summary>
            Indicates if 2nd moment is tallied
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IDetector.TallyDetails">
            <summary>
            Details of the tally - booleans that specify when they should be tallied
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.IDetector.Initialize(Vts.MonteCarlo.ITissue,System.Random)">
            <summary>
            Initialize the detector, using tissue and random number generator information if necessary
            </summary>
            <param name="tissue">tissue definition</param>
            <param name="rng">random number generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.IDetector.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            Method to tally to detector using information in Photon
            </summary>
            <param name="photon">photon data needed to tally</param>
        </member>
        <member name="M:Vts.MonteCarlo.IDetector.Normalize(System.Int64)">
            <summary>
            Method to normalize the tally to get Mean and Second Moment estimates
            </summary>
            <param name="numPhotons">number of photons launched</param>
        </member>
        <member name="M:Vts.MonteCarlo.IDetector.GetBinarySerializers">
            <summary>
            Method that returns info for each large binary data array
            </summary>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.IDetectorController">
            <summary>
            Interface for Controller classes that manage the detectors.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IDetectorController.Detectors">
            <summary>
            List of detectors controller is managing
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.IDetectorController.NormalizeDetectors(System.Int64)">
            <summary>
            Method to normalize all detectors given the number of photons launched, N.
            </summary>
            <param name="N"></param>
        </member>
        <member name="M:Vts.MonteCarlo.IDetectorController.Tally(Vts.MonteCarlo.Photon)">
            <summary>
            Method to tally to detectors in controller using information in Photon
            </summary>
            <param name="photon"></param>
        </member>
        <member name="T:Vts.MonteCarlo.IDetectorInput">
            <summary>
            Defines a contract for DetectorInput classes.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IDetectorInput.TallyType">
            <summary>
            TallyType string identifying type of detector
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IDetectorInput.Name">
            <summary>
            Name of detector.  User can define or default is TallyType.ToString().
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IDetectorInput.TallyDetails">
            <summary>
            Details of the tally - booleans that specify when they should be tallied
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.IDetectorInput.CreateDetector">
            <summary>
            Required factory method to create the corresponding 
            IDetector based on the IDetectorInput data
            </summary>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.IHistoryDetector">
            <summary>
            Properties and methods that all IDetectors must implement
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.IHistoryDetector.TallySingle(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.PhotonDataPoint,System.Int32)">
            <summary>
            Method to tally to detector using information in Photon
            </summary>
            <param name="previousDP"></param>
            <param name="dp"></param>
            <param name="currentRegionIndex"></param>
        </member>
        <member name="T:Vts.MonteCarlo.IpMCDetectorInput">
            <summary>
            This is a contract for perturbation Monte Carlo (pMC) detector inputs.
            It describes the additional properties from IDetectorInput needed to
            perform the pMC detection.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IpMCDetectorInput.PerturbedOps">
            <summary>
            list of perturbed optical properties.  list indexing follows indexing of tissue.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IpMCDetectorInput.PerturbedRegionsIndices">
            <summary>
            list of perturbed region indices.  list indexing follows indexing of tissue.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.ISource">
            <summary>
            Defines a contract for Source classes for Monte Carlo simulation.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.ISource.GetNextPhoton(Vts.MonteCarlo.ITissue)">
            <summary>
            Method to initiate new photon.
            </summary>
            <param name="tissue"></param>
            <returns></returns>
        </member>
        <member name="P:Vts.MonteCarlo.ISource.Rng">
            <summary>
            Random number generator
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.ISourceInput">
            <summary>
            Defines a contract for SourceInput classes.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ISourceInput.SourceType">
            <summary>
            Type of source
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ISourceInput.InitialTissueRegionIndex">
            <summary>
            Index of region (according to Tissue definition) where photon first starts.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.ISourceInput.CreateSource(System.Random)">
            <summary>
            Required code to create a source based on the input values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Interfaces.ISourceProfile">
            <summary>
            Defines contract for source profile.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Interfaces.ISourceProfile.SourceProfileType">
            <summary>
            Source beam profile types enum, SourceProfileType
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.ITissue">
            <summary>
            Defines a contract for Tissue classes in Monte Carlo simulation.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ITissue.AbsorptionWeightingType">
            <summary>
            AbsorptionWeightingType enum specifier indicating Analog, Discrete Absorption weighting, etc.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ITissue.RussianRouletteWeightThreshold">
            <summary>
            photon weight threshold, below which turns on Russian Roulette
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ITissue.PhaseFunctionType">
            <summary>
            PhaseFunctionType enum specifier indicating Henyey-Greenstein, Birdirectional, etc.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ITissue.Regions">
            <summary>
            A list of ITissueRegions that describes the entire system.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ITissue.RegionScatterLengths">
            <summary>
            The scattering lengths for each tissue region.  For discrete absorption weighting and
            analog, this is based on 1/mut, for continuous it is based on 1/mus.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.ITissue.Initialize(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required method to initialize the corresponding ITissue
            </summary>
            <param name="awt">absorption weighting type</param>
            <param name="pft">phase function type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette threshold</param>
        </member>
        <member name="M:Vts.MonteCarlo.ITissue.GetRegionIndex(Vts.Common.Position)">
            <summary>
            Method that gives the current region index within Regions list (above) at the current
            position of the photon.
            </summary>
            <param name="position">current location of photon</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.ITissue.GetDistanceToBoundary(Vts.MonteCarlo.Photon)">
            <summary>
            Method that provides the distance to the closest tissue boundary.
            </summary>
            <param name="photon">Photon information (e.g. current position, direction,
            and current track length, S)</param>
            <returns>distance, includes double.PositiveInfinity and double.NegativeInfinity</returns>
        </member>
        <member name="M:Vts.MonteCarlo.ITissue.GetAngleRelativeToBoundaryNormal(Vts.MonteCarlo.Photon)">
            <summary>
            Method to provide the angle relative to a tissue boundary.
            </summary>
            <param name="photon">Photon information (e.g. direction and position).</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.ITissue.GetNeighborRegionIndex(Vts.MonteCarlo.Photon)">
            <summary>
            Method that gives the region the photon is about to enter.
            </summary>
            <param name="photon">Photon information (e.g. direction and position)</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.ITissue.OnDomainBoundary(Vts.Common.Position)">
            <summary>
            Method to determine whether on tissue domain boundary.  This method helps to
            determine when photon leaves the phase space and enters the air for example.
            </summary>
            <param name="position">Photon position</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.ITissue.GetPhotonDataPointStateOnExit(Vts.Common.Position)">
            <summary>
            Method to return updated PhotonStateType enum indicating type of photon exit
            from domain (e.g. reflectance boundary, transmittance boundary)
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.ITissue.GetReflectedDirection(Vts.Common.Position,Vts.Common.Direction)">
            <summary>
            Method to provide reflected direction of photon given current position and direction.
            </summary>
            <param name="currentPosition">current position of photon</param>
            <param name="currentDirection">current direction of photon</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.ITissue.GetRefractedDirection(Vts.Common.Position,Vts.Common.Direction,System.Double,System.Double,System.Double)">
            <summary>
            Method to provide refracted direction of photon.
            </summary>
            <param name="currentPosition">current position of photon</param>
            <param name="currentDirection">current direction of photon</param>
            <param name="currentN">refractive index of current tissue type</param>
            <param name="nextN">refractive index of next tissue type</param>
            <param name="cosThetaSnell">cos(theta) of the refracted direction according to Snell's law</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.ITissueInput">
            <summary>
            Defines a contract for TissueInput.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ITissueInput.TissueType">
            <summary>
            Type of tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ITissueInput.Regions">
            <summary>
            List of tissue regions comprising tissue.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.ITissueInput.CreateTissue(Vts.AbsorptionWeightingType,Vts.PhaseFunctionType,System.Double)">
            <summary>
            Required factory method to create the corresponding 
            ITissue based on the ITissueInput data
            </summary>
            <param name="awt">Absorption Weighting Type</param>
            <param name="pft">Phase Function Type</param>
            <param name="russianRouletteWeightThreshold">Russian Roulette Weight Threshold</param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.ITissueRegion">
            <summary>
            Defines contract for TissueRegion classes.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ITissueRegion.RegionOP">
            <summary>
            Optical properties of tissue region.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ITissueRegion.Center">
            <summary>
            Center position
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ITissueRegion.TissueRegionType">
            <summary>
            tissue region identifier
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.ITissueRegion.ContainsPosition(Vts.Common.Position)">
            <summary>
            Checks to see if the specified position is within the tissue region.  Definition should be such
            that regions do not overlap, i.e. photon can only be in one region at a time.
            </summary>
            <param name="position">The position to test</param>
            <returns>True if the specified position is within the tissue region, false otherwise</returns>
        </member>
        <member name="M:Vts.MonteCarlo.ITissueRegion.OnBoundary(Vts.Common.Position)">
            <summary>
            Determines if photon on boundary of tissue region.  Some checks require adjustments for
            floating point error in precision of Position.
            </summary>
            <param name="position">The position to test</param>
            <returns>True if specified position if on tissue region boundary, false otherwise</returns>
        </member>
        <member name="M:Vts.MonteCarlo.ITissueRegion.RayIntersectBoundary(Vts.MonteCarlo.Photon,System.Double@)">
            <summary>
            Checks if the specified photon will intersect the region boundary
            </summary>
            <param name="photon">Photon to check for intersection (including Position, Direction, and S)</param>
            <param name="distanceToBoundary">The distance to the next boundary</param>
            <returns>True if photon will intersect the region boundary, false otherwise</returns>
            <remarks>Use this method if the distance is required</remarks>
        </member>
        <member name="M:Vts.MonteCarlo.ITissueRegion.SurfaceNormal(Vts.Common.Position)">
            <summary>
            Determines surface normal at position
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.IVirtualBoundary">
            <summary>
            Defines a contract for Virtual Boundary classes in Monte Carlo simulation.
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IVirtualBoundary.WillHitBoundary">
            <summary>
            Predicate method to determine if photon will hit virtual boundary (VB)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.IVirtualBoundary.GetDistanceToVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to determine distance to VB
            </summary>
            <param name="dp">PhotonDataPoint current location</param>
            <returns>distance to VB</returns>
        </member>
        <member name="P:Vts.MonteCarlo.IVirtualBoundary.Name">
            <summary>
            Name of VB, default VirtualBoundaryType.ToString()
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IVirtualBoundary.VirtualBoundaryType">
            <summary>
            Type of the VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IVirtualBoundary.PhotonStateType">
            <summary>
            State of the photon at this VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.IVirtualBoundary.DetectorController">
            <summary>
            Each VB holds on to a detector controller which manages the detectors associated with this VB 
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.IO.Database`1">
            <summary>
            Describes database of generic type allowing for various classes to be written to database.
            </summary>
            <typeparam name="T">type of database</typeparam>
        </member>
        <member name="P:Vts.MonteCarlo.IO.Database`1.NumberOfElements">
            <summary>
            number of elements in database
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.IO.Database`1.SetDataPoints(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            method to set private _dataPoints to passed in dataPoints
            </summary>
            <param name="dataPoints">IEnumerable of generic type Time"</param>
        </member>
        <member name="P:Vts.MonteCarlo.IO.Database`1.DataPoints">
            <summary>
            DataPoints is an IEnumerable of Time
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.IO.DatabaseReader`2">
            <summary>
            This controls the reading of a database of generic-type.
            </summary>
            <typeparam name="TDatabase">Database of generic type Time</typeparam>
            <typeparam name="TElement">Generic database element</typeparam>
        </member>
        <member name="M:Vts.MonteCarlo.IO.DatabaseReader`2.#ctor(System.Func{`0,Vts.IO.ICustomBinaryReader{`1}})">
            <summary>
            Creates an instance of DatabaseReader with a map to create a binary reader. Use this overload
            if you need database-specific information in order to deserialize (e.g. number of subregions, etc)
            </summary>
            <param name="binaryReaderCreator">ICustomBonaryReader&lt;TElement&gt;</param>
        </member>
        <member name="M:Vts.MonteCarlo.IO.DatabaseReader`2.#ctor(Vts.IO.ICustomBinaryReader{`1})">
            <summary>
            Creates an instance of DatabaseReader with a simple binary reader. Use this overload
            if there is no database-specific information necessary for creating the reader
            </summary>
            <param name="binaryReader">ICustomBinaryReader&lt;TElement&gt;</param>
        </member>
        <member name="M:Vts.MonteCarlo.IO.DatabaseReader`2.FromFile(System.String)">
            <summary>
            Creates a database of generic type Time from an XML file
            </summary>
            <param name="fileName">Name of the XML file to be read</param>
            <returns>a database of generic type Time</returns>
        </member>
        <member name="M:Vts.MonteCarlo.IO.DatabaseReader`2.FromFileInResources(System.String,System.String)">
            <summary>
            Creates a database of generic type Time from a file in resources
            </summary>
            <param name="fileName">Name of the XML file to be read</param>
            <param name="projectName">Project name for the location of resources</param>
            <returns>a database of generic type Time</returns>
        </member>
        <member name="T:Vts.MonteCarlo.IO.DatabaseWriter`2">
            <summary>
            This is a base class to PhotonDatabaseWriter and CollisionInfoDatabaseWriter.
            It controls writing to a database of generic-type.
            </summary>
            <typeparam name="TDatabase">Database of generic type Time</typeparam>
            <typeparam name="TElement">Generic database element</typeparam>
        </member>
        <member name="M:Vts.MonteCarlo.IO.DatabaseWriter`2.#ctor(System.String,`0,Vts.IO.ICustomBinaryWriter{`1})">
            <summary>
            writes database to file
            </summary>
            <param name="filename">name of file to write to</param>
            <param name="database">database to be written</param>
            <param name="binaryWriter">ICustomBinaryWriter</param>
        </member>
        <member name="P:Vts.MonteCarlo.IO.DatabaseWriter`2.Database">
            <summary>
            Publicly exposed database for assigning custom parameters 
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.IO.DetectorIO">
            <summary>
            Class that handles IO for IDetectors.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.IO.DetectorIO.WriteDetectorToFile(Vts.MonteCarlo.IDetector,System.String)">
            <summary>
            Writes Detector xml for scalar detectors, writes Detector xml and 
            binary for 1D and larger detectors.  Detector.Name is used for filename.
            </summary>
            <param name="detector">IDetector being written.</param>
            <param name="folderPath">location of written file.</param>
        </member>
        <member name="M:Vts.MonteCarlo.IO.DetectorIO.ReadDetectorFromFile(System.String,System.String)">
            <summary>
            Reads Detector from File with given fileName.
            </summary>
            <param name="fileName">filename string of file to be read</param>
            <param name="folderPath">path string where file resides</param>
            <returns>IDetector</returns>
        </member>
        <member name="M:Vts.MonteCarlo.IO.DetectorIO.ReadDetectorFromFileInResources(System.String,System.String,System.String)">
            <summary>
            Reads Detector from a file in resources using given fileName.
            </summary>
            <param name="fileName">filename string of file to be read</param>
            <param name="folderPath">path string of folder where file to be read resides</param>
            <param name="projectName">project name string where file resides in resources</param>
            <returns>IDetector</returns>
        </member>
        <member name="T:Vts.MonteCarlo.MonteCarloSimulation">
            <summary>
            Provides main processing for Monte Carlo simulation. 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.MonteCarloSimulation.SimulationIndex">
            <summary>
            Integer index of Simulation specified in infile
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.MonteCarloSimulation.AbsorptionWeightingType">
            <summary>
            Absorption weighting: Discrete, Continuous, Analog, specified in infile
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.MonteCarloSimulation.TrackStatistics">
            <summary>
            flag to track statistics e.g. number of photons out top of tissue, out bottom, etc.
            specified in infile
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.MonteCarloSimulation._logger">
            <summary>
            local variables: general
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.MonteCarloSimulation._source">
            <summary>
            local variable: input related
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.#ctor">
            <summary>
            Default constructor to allow quick-and-easy simulation
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.#ctor(Vts.MonteCarlo.SimulationInput)">
            <summary>
            Constructor that only takes in input and generates a default
            for the random number
            </summary>
            <param name="input">Simulation input</param>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.#ctor(Vts.MonteCarlo.SimulationInput,System.Random)">
            <summary>
            Class that takes in SimulationInput and methods to initialize
            and execute Monte Carlo simulation
            </summary>
            <param name="input">SimulationInput</param>
            <param name="rng">random number generator already initialized</param>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.#ctor(Vts.MonteCarlo.SimulationInput,System.Boolean)">
            <summary>
            Constructor to delay the initialize if we are running parallel
            so we can pass in the random number separately in InitializeParallel
            </summary>
            <param name="input">Simulation input</param>
            <param name="isParallel">A boolean for if parallel</param>
        </member>
        <member name="P:Vts.MonteCarlo.MonteCarloSimulation.Input">
            <summary>
            The Simulation input
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.MonteCarloSimulation.Rng">
            <summary>
            The random number
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.MonteCarloSimulation.PhaseFunctionType">
            <summary>
            Phase function enum type as specified in SimulationOptions
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.MonteCarloSimulation.IsRunning">
            <summary>
            Boolean indicating whether simulation is running or not
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.MonteCarloSimulation.ResultsAvailable">
            <summary>
            Boolean indicating whether results are available or not
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.MonteCarloSimulation.Statistics">
            <summary>
            simulation statistics
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.MonteCarloSimulation.Results">
            <summary>
            Results of the simulation 
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.InitializeParallel(System.Random)">
            <summary>
            
            </summary>
            <param name="rng"></param>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.RunAll(Vts.MonteCarlo.MonteCarloSimulation[])">
            <summary>
            Method to run parallel, individual MC simulations
            </summary>
            <param name="simulations">array of MonteCarloSimulation</param>
            <returns>array of SimulationOutput</returns>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.SetOutputPathForDatabases(System.String)">
            <summary>
            Method that sets the output path (string) for databases
            </summary>
            <param name="outputPath">string indicating output path</param>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.Run">
            <summary>
            Run the simulation
            </summary>
            <returns>SimulationOutput</returns>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.Cancel">
            <summary>
            Method to cancel the simulation, for example, from the gui
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.ExecuteMCLoop">
            <summary>
            Executes the Monte Carlo Loop
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.InitializeInputs">
            <summary>
            Initialization of the inputs for the MonteCarloSimulation
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.InitialDatabases(System.Boolean)">
            <summary>
            Initializes databases for diffuse reflectance (1 database) or perturbation
            MC (2 databases)
            </summary>
            <param name="_doPMC"></param>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.MoveToBoundaryCheck(Vts.MonteCarlo.Photon,Vts.MonteCarlo.IVirtualBoundary@)">
            <summary>
            Checks if whether photon is going to first
            a) hit tissue boundary (BoundaryHitType.Tissue), and if so Photon.Move to 
            intersection position, then
            b) Photon.CrossOrReflect checks if at border of system and sets
            appropriate photon state flag, e.g. PhotonStateType.PseudoBoundingVolumeTissueBoundary
            c) finally sets BoundaryHitType.Virtual and tallies in main MC loop
            </summary>
            <param name="photon"></param>
            <param name="closestVirtualBoundary"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.DisplayIntro">
            <summary>
            Method to display introduction to the simulation
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.MonteCarloSimulation.DisplayStatus(System.Int64,System.Int64)">
            <summary>
            Method that displays simulation percentage done
            </summary>
            <param name="n"></param>
            <param name="num_phot"></param>
        </member>
        <member name="T:Vts.MonteCarlo.ParallelMonteCarloSimulation">
            <summary>
            Provides main processing for a single Monte Carlo simulation in parallel. 
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.ParallelMonteCarloSimulation._logger">
            <summary>
            local variables: general
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ParallelMonteCarloSimulation.Input">
            <summary>
            SimulationInput class passed in 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ParallelMonteCarloSimulation.NumberOfCPUs">
            <summary>
            number of CPUs
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.ParallelMonteCarloSimulation.SummedStatistics">
            <summary>
            simulation statistics
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.ParallelMonteCarloSimulation.#ctor(Vts.MonteCarlo.SimulationInput,System.Int32)">
            <summary>
            Class that defines methods to initialize and execute Monte Carlo simulation
            </summary>
            <param name="input">Simulation Input</param>
            <param name="numberOfCPUs">number of parallel CPUs to be run</param>
        </member>
        <member name="M:Vts.MonteCarlo.ParallelMonteCarloSimulation.#ctor">
            <summary>
            Default Constructor
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.ParallelMonteCarloSimulation.RunSingleInParallel">
            <summary>
            Method to run single MC simulation in parallel
            </summary>
            <returns>array of SimulationOutput</returns>
        </member>
        <member name="M:Vts.MonteCarlo.ParallelMonteCarloSimulation.SumStatisticsTogether(System.Collections.Generic.List{Vts.MonteCarlo.SimulationStatistics})">
            <summary>
            Sums the statistics from the list of SimulationStatistics
            </summary>
            <param name="stats">The list of SimulationStatistics</param>
            <returns>One instance of SimulationStatistics</returns>
        </member>
        <member name="M:Vts.MonteCarlo.ParallelMonteCarloSimulation.SumResultsTogether(System.Collections.Generic.List{Vts.MonteCarlo.SimulationOutput})">
            <summary>
            Sums the results from the list of SimulationOutputs
            </summary>
            <param name="results">List of SimulationOutputs</param>
            <returns>One instance of SimulationOutput</returns>
        </member>
        <member name="T:Vts.MonteCarlo.Photon">
            <summary>
            Handles all data and methods necessary to photon biography generation.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.#ctor(Vts.Common.Position,Vts.Common.Direction,System.Double,Vts.MonteCarlo.ITissue,System.Int32,System.Random)">
            <summary>
            Class that keeps a photon's data as it moves through the tissue
            </summary>
            <param name="p">Position</param>
            <param name="d">Direction</param>
            <param name="weight">Initial weight</param>
            <param name="tissue">Tissue></param>
            <param name="currentTissueRegionIndex">integer index within ITissue definition indicating photon's current position</param>
            <param name="generator">Random Number Generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.#ctor">
            <summary>
            default constructor for Photon
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Photon.DP">
            <summary>
            photon data point has position, direction etc. info
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Photon.History">
            <summary>
            PhotonHistory has list of PhotonDataPoints and SubRegionCollisionInfo
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Photon.S">
            <summary>
            path length of current track, gets updated when passing tissue boundary
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Photon.SLeft">
            <summary>
            path length left after crossing tissue boundary
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Photon.CurrentRegionIndex">
            <summary>
            tissue region index where photon current is
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Photon.CurrentTrackIndex">
            <summary>
            index of current track of photon
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Photon.Absorb">
            <summary>
            absorb action: analog, discrete, continuous
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Photon.Scatter">
            <summary>
            scatter action: Henyey-Greenstein, bidirectional, Mie
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.SetStepSize">
            <summary>
            method that determines photon's step size based on the RegionScatterLength (1/mus or 1/mut depending on CAW or DAW)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.Move(System.Double)">
            <summary>
            method to move the photon to its next location
            </summary>
            <param name="distance"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.CrossRegionOrReflect">
            <summary>
            Method that determines whether photon reflects or refracts across interface.  When this 
            method is called photon is sitting on boundary of region and CurrentRegionIndex is Index
            of region photon had been in.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.ScatterHenyeyGreenstein">
            <summary>
            Method to scatter according to Henyey-Greenstein scatter function
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.Scatter1D">
            <summary>
            Method to scatter bidirectionally
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.AbsorbAnalog">
            <summary>
            Method to check for absorption according to analog random walk process
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.AbsorbDiscrete">
            <summary>
            Method to deweight for absorption according to discrete absorption weighting (DAW)
            random walk process
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.AbsorbContinuous">
            <summary>
            Method to deweight for absorption according to continuous absorption weighting (CAW)
            random walk process
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.TestDeath">
            <summary>
            Method to test for death of the photon
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Photon.TestWeightAndDistance">
            <summary>
            Method that kills photon due to Russian Roulette, maximum path length, etc.
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.CollisionInfo">
            <summary>
            Describes a model object designed to hold extra information related to collisions and
            pathlength in each region. Inherits from List(OfSubRegionCollisionInfo) as a simple way 
            of having Add() and indexing methods available
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfo.#ctor(System.Int32)">
            <summary>
            class that holds photon information related to collisions and pathlength in each region
            </summary>
            <param name="numberOfSubRegions">number of tissue subregions</param>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfo.#ctor">
            <summary>
            default constructor assumes 0 tissue regions (used for serialization only)
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfo.Clone">
            <summary>
            method to cline the CollisionInfo class
            </summary>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.CollisionInfoDatabase">
            <summary>
            Describes database for storing and returning collision info (pathlength &amp; number of collisions).
            The base class, Database(OfT), exposes the IEnumerable(OfT) DataPoints list of CollisionInfo items
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfoDatabase.#ctor(System.Int32)">
            <summary>
            Creates an instance of a CollisionInfoDatabase
            </summary>
            <param name="numSubRegions">The number of "sub-regions" within the tissue</param>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfoDatabase.#ctor">
            <summary>
            Do not use this overload, it is only for serialization purposes
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.CollisionInfoDatabase.NumberOfSubRegions">
            <summary>
            The number of "sub-regions" within the tissue
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfoDatabase.FromFile(System.String)">
            <summary>
            Static helper method to simplify reading from file
            </summary>
            <param name="fileName">The base filename for the database (no ".txt")</param>
            <returns>A new instance of CollisionInfoDatabase</returns>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfoDatabase.FromFileInResources(System.String,System.String)">
            <summary>
            Static helper method to simplify reading from file
            </summary>
            <param name="fileName">The base filename for the database (no ".txt")</param>
            <param name="projectName">The project name containing the resource</param>
            <returns>A new instance of CollisionInfoDatabase</returns>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.CollisionInfoDatabaseWriter">
            <summary>
            Implements CustomBinaryStreamWriter(OfPhotonDataPoint). Handles writing photon
            terminating data to database.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfoDatabaseWriter.#ctor(Vts.MonteCarlo.VirtualBoundaryType,System.String,System.Int32)">
            <summary>
            constructor for the collision info database writer
            </summary>
            <param name="virtualBoundaryType">virtual boundary type</param>
            <param name="filename">name of database filename</param>
            <param name="numberOfSubRegions">number of subregions in tissue</param>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.CollisionInfoDatabaseWriter.VirtualBoundaryType">
            <summary>
            virtual boundary type
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.CollisionInfoSerializer">
            <summary>
            Implements ICustomBinaryReader(OfCollisionInfo) and ICustomBinaryWriter(OfCollisionInfo).
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfoSerializer.#ctor(System.Int32)">
            <summary>
            class that takes care of serializing CollisionInfo
            </summary>
            <param name="numberOfSubRegions">number of tissue subregions</param>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfoSerializer.WriteToBinary(System.IO.BinaryWriter,Vts.MonteCarlo.PhotonData.CollisionInfo)">
            <summary>
            method to write CollisionInfo to binary file
            </summary>
            <param name="bw">BinaryWriter</param>
            <param name="item">CollisionInfo</param>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.CollisionInfoSerializer.ReadFromBinary(System.IO.BinaryReader)">
            <summary>
            method to read CollisionInfo binary
            </summary>
            <param name="br">BinaryReader</param>
            <returns>SollisionInfo</returns>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.PhotonDatabase">
            <summary>
            Describes database for storing and returning photon data points (position, direction, weight &amp; total time).
            The base class, Database(OfT), exposes the IEnumerable(OfT) DataPoints list of PhotonDataPoint items
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.PhotonDatabase.#ctor">
            <summary>
            Returns an instance of PhotonDatabase
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.PhotonDatabase.FromFile(System.String)">
            <summary>
            Static helper method to simplify reading from file
            </summary>
            <param name="fileName">The base filename for the database (no ".txt")</param>
            <returns>A new instance of PhotonDatabase</returns>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.PhotonDatabase.FromFileInResources(System.String,System.String)">
            <summary>
            Static helper method to simplify reading from file
            </summary>
            <param name="fileName">The base filename for the database (no ".txt")</param>
            <param name="projectName">The project name containing the resource</param>
            <returns>A new instance of PhotonDatabase</returns>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.PhotonDatabaseWriter">
            <summary>
            Implements CustomBinaryStreamWriter(Of PhotonDataPoint). Handles writing photon
            data to database.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.PhotonDatabaseWriter.#ctor(Vts.MonteCarlo.VirtualBoundaryType,System.String)">
            <summary>
            constructor for photon database writer
            </summary>
            <param name="virtualBoundaryType">virtual boundary type</param>
            <param name="filename">database filename</param>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.PhotonDatabaseWriter.VirtualBoundaryType">
            <summary>
            virtual boundary type
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.PhotonDataPoint">
            <summary>
            Captures data describing current state of photon.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.PhotonDataPoint.#ctor(Vts.Common.Position,Vts.Common.Direction,System.Double,System.Double,Vts.MonteCarlo.PhotonStateType)">
            <summary>
            Photon information updated during its trajectory through tissue
            </summary>
            <param name="position">Position</param>
            <param name="direction">Direction</param>
            <param name="weight">weight</param>
            <param name="totalTime">total time of flight</param>
            <param name="stateFlag">PhotonStateType</param>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.PhotonDataPoint.Position">
            <summary>
            position of photon data point
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.PhotonDataPoint.Direction">
            <summary>
            direction of photon data point
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.PhotonDataPoint.Weight">
            <summary>
            weight of photon
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.PhotonDataPoint.TotalTime">
            <summary>
            total time to date that photon has lived
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.PhotonDataPoint.StateFlag">
            <summary>
            state flag indicating state of photon
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.PhotonDataPoint.Clone">
            <summary>
            method to clone photon data point
            </summary>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.PhotonDataPointSerializer">
            <summary>
            Implements ICustomBinaryReader&lt;PhotonDataPoint&gt; and 
            ICustomBinaryWriter&lt;PhotonDataPoint&gt;.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.PhotonDataPointSerializer.WriteToBinary(System.IO.BinaryWriter,Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            method to write PhotonDataPoint to binary
            </summary>
            <param name="bw">BinaryWriter</param>
            <param name="item">PhotonDataPoint</param>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.PhotonDataPointSerializer.ReadFromBinary(System.IO.BinaryReader)">
            <summary>
            method to read PhotonDataPoint from binary
            </summary>
            <param name="br">BinaryReader</param>
            <returns>PHotonDataPoint</returns>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.pMCDatabase">
            <summary>
            Describes database for storing and returning photon data points (position, direction, weight &amp; total time).
            The base class, Database(OfT), exposes the IEnumerable(OfT) DataPoints list of PhotonDataPoint items
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.pMCDatabase.#ctor(Vts.MonteCarlo.PhotonData.PhotonDatabase,Vts.MonteCarlo.PhotonData.CollisionInfoDatabase)">
            <summary>
            Returns an instance of PhotonDatabase
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.pMCDatabase.#ctor">
            <summary>
            Do not use this overload, it is only for serialization purposes
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.pMCDatabase.PhotonDatabase">
            <summary>
            The underlying PhotonDatabase
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.pMCDatabase.CollisionInfoDatabase">
            <summary>
            The underlying CollisionInfoDatabase
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.pMCDatabase.FromFile(System.String,System.String)">
            <summary>
            Static helper method to simplify reading from file
            </summary>
            <param name="photonDatabaseFileName">The filename for the PhotonDataPoint database (no ".txt")</param>
            <param name="collisionInfoDatabaseFileName">The filename for the CollisionInfo database (no ".txt")</param>
            <returns>A new instance of PhotonDatabase</returns>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.pMCDatabase.FromFileInResources(System.String,System.String,System.String)">
            <summary>
            Method to read database from file in resources.
            </summary>
            <param name="photonDatabaseFileName">PhotonDataPoint database name</param>
            <param name="collisionInfoDatabaseFileName">CollisionInfo database name</param>
            <param name="projectName">project name where the databases reside</param>
            <returns>pMCDatabase</returns>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.pMCDataPoint">
            <summary>
            Captures data describing current state of photon.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.pMCDataPoint.#ctor(Vts.MonteCarlo.PhotonData.PhotonDataPoint,Vts.MonteCarlo.PhotonData.CollisionInfo)">
            <summary>
            class to house data needed for pMC database.
            </summary>
            <param name="photonDataPoint">photon data point</param>
            <param name="collisionInfo">collision information</param>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.pMCDataPoint.PhotonDataPoint">
            <summary>
            photon data point
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.pMCDataPoint.CollisionInfo">
            <summary>
            collision information
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.pMCDataPoint.Clone">
            <summary>
            Method to clone class
            </summary>
            <returns>instantiated clone of class</returns>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonData.SubRegionCollisionInfo">
            <summary>
            A struct to hold pathlength and collision count for each subregion of a PhotonDataPoint.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.SubRegionCollisionInfo.#ctor(System.Double,System.Int64)">
            <summary>
            SubRegionCollisionInfo collects the number of collision and total path length
            at the current PhotonDataPoint position.
            </summary>
            <param name="pathLength">total path length in subregion</param>
            <param name="numberOfCollisions">total number of collisions in subregion</param>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.SubRegionCollisionInfo.PathLength">
            <summary>
            path length of photon in sub-region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonData.SubRegionCollisionInfo.NumberOfCollisions">
            <summary>
            number of collisions made by photon in sub-region
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonData.SubRegionCollisionInfo.Clone">
            <summary>
            Method to clone class
            </summary>
            <returns>instantiated clone of class</returns>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonHistory">
            <summary>
            Stores list of PhotonDataPoint that captures one photon's biography data. 
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonHistory.#ctor(System.Int32)">
            <summary>
            constructor for photon history class
            </summary>
            <param name="numSubRegions">number of subregions in tissue</param>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonHistory.HistoryData">
            <summary>
            HistoryData contains the photon's biography within a list of PhotonDataPoints
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonHistory.SubRegionInfoList">
            <summary>
            SubRegionInfoList keeps track of number of collisions and pathlength in each tissue
            region
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonHistory.CurrentDP">
            <summary>
            Identifies current PhotonDataPoint
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.PhotonHistory.PreviousDP">
            <summary>
            Identifies previous PhotonDataPoint
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PhotonHistory.AddDPToHistory(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Method to add PhotonDataPoint to History.  
            </summary>
            <param name="dp">PhotonD</param>
        </member>
        <member name="T:Vts.MonteCarlo.PostProcessing.PhotonDatabasePostProcessor">
            <summary>
            Sets up and postprocesses Monte Carlo termination data that has been 
            saved in a database.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessing.PhotonDatabasePostProcessor.#ctor(Vts.MonteCarlo.VirtualBoundaryType,System.Collections.Generic.IList{Vts.MonteCarlo.IDetectorInput},Vts.MonteCarlo.PhotonData.pMCDatabase,Vts.MonteCarlo.SimulationInput)">
            <summary>
            Creates an instance of PhotonDatabasePostProcessor for pMC database processing
            </summary>
            <param name="virtualBoundaryType">virtual boundary type</param>
            <param name="detectorInputs">List of IDetectorInputs designating binning</param>
            <param name="database">pMCDatabase</param>
            <param name="databaseInput">Database information needed for post-processing</param>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessing.PhotonDatabasePostProcessor.#ctor(Vts.MonteCarlo.VirtualBoundaryType,System.Collections.Generic.IList{Vts.MonteCarlo.IDetectorInput},Vts.MonteCarlo.PhotonData.PhotonDatabase,Vts.MonteCarlo.SimulationInput)">
            <summary>
            Creates an instance of PhotonDatabasePostProcessor for standard (photon) database processing
            </summary>
            <param name="virtualBoundaryType">virtual boundary type</param>
            <param name="detectorInputs">List of IDetectorInputs designating binning</param>
            <param name="photonDatabase">PhotonTerminationDatabase</param>
            <param name="databaseInput">Database information needed for post-processing</param>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessing.PhotonDatabasePostProcessor.#ctor(Vts.MonteCarlo.VirtualBoundaryType,System.Collections.Generic.IList{Vts.MonteCarlo.IDetectorInput},Vts.MonteCarlo.SimulationInput)">
            <summary>
            Shared constructor for both pMC and standard (photon) databases
            </summary>
            <param name="virtualBoundaryType"></param>
            <param name="detectorInputs">List of IDetectorInputs designating binning</param>
            <param name="databaseInput">Database information needed for post-processing</param>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessing.PhotonDatabasePostProcessor.RunAll(Vts.MonteCarlo.PostProcessing.PhotonDatabasePostProcessor[])">
            <summary>
            Helper static method to run a group of post-processors in parallel
            </summary>
            <param name="postProcessors"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.PostProcessing.PhotonDatabasePostProcessor.Run">
            <summary>
            Executes the post-processor
            </summary>
            <returns></returns>
        </member>
        <member name="T:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister">
            <summary>
            This class creates a parallelizable representation of the Mersenne Twister class.
            Code from Dynamic Creator (dc) Home Page
            http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/DC/dc.html or 
            GitHub: https://github.com/MersenneTwister-Lab/dcmt (same code both places)
            The code is in C, so this code maintained many of the constructs and coding
            statements to be able to produce same results
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._lower_mask">
            <summary>
            least significant r bits
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._m">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._matrix_a">
            <summary>
            constant vector a
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._n">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._reciprocal">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._upper_mask">
            <summary>
            most significant w-r bits
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._mag01">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._mt">
            <summary>
            Mersenne twister constant (should not be modified, except for serialization purposes)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._limit_irred_deg">
            <summary>
            Mersenne twister constant (was in original code): private int mti = _n + 1
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.check32_t">
            <summary>
            structs in dci.h
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct">
            <summary>
            Mersenne Twister structure 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.aaa">
            <summary>
            unsigned 32 bit integer used in algorithm
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.mm">
            <summary>
            integer parameter used in init_tempering algorithm
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.nn">
            <summary>
            integer parameter used in init_tempering algorithm
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.rr">
            <summary>
            integer parameter used in init_tempering algorithm
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.ww">
            <summary>
            integer parameter used in init_tempering algorithm
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.wmask">
            <summary>
            unsigned int mask used in sgenrand_mt
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.umask">
            <summary>
            unsigned int mask used in genrand_mt
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.lmask">
            <summary>
            unsigned int mask used in genrand_mt
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.shift0">
            <summary>
            int using in genrand_mt
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.shift1">
            <summary>
            int using in genrand_mt
            </summary> 
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.shiftB">
            <summary>
            int using in genrand_mt
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.shiftC">
            <summary>
            int using in genrand_mt
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.maskB">
            <summary>
            int using in genrand_mt
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.maskC">
            <summary>
            int using in genrand_mt
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.i">
            <summary>
            int using in genrand_mt
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct.state">
            <summary>
            unsigned array used in sgenrand_mt
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.org_state">
            struc in mt19937.h
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the MersenneTwister class.  
            </summary>
            <param name="seed"></param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the MersenneTwister class.  
            </summary>
            <param name="streamSeed"></param>
            <param name="seed"></param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.#ctor(System.Int32,System.Int32,System.UInt32,System.UInt32)">
            <summary>
            Initializes a new instance of the MersenneTwister class.  This version
            allows the user to specify word length, period exponent, original MT seed and
            new generator seed
            </summary>
            <param name="wordLength">word size either 31 or 32</param>
            <param name="periodExponent">Mersenne exponent defining period of stream</param>
            <param name="streamSeed">seed to obtain stream</param>
            <param name="seed">seed within stream to start</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.#ctor(System.Int32,System.Int32,System.Int32,System.UInt32,System.UInt32)">
            <summary>
            Overload that allows an Id to be specified
            </summary>
            <param name="wordLength">word size either 31 or 32</param>
            <param name="periodExponent">Mersenne exponent defining period of stream</param>
            <param name="Id">Id of stream</param>
            <param name="streamSeed">seed to obtain stream, this can be fixed if Id varying</param>
            <param name="seed">seed within stream to start</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.#ctor(System.Int32,System.Int32,System.UInt32,System.UInt32[],System.Int32,System.Int32,System.Int32@)">
            <summary>
             Overload that allows multiple MT streams to be specified in one call
            </summary>
            <param name="wordLength">word size either 31 or 32</param>
            <param name="periodExponent">Mersenne exponent defining period of stream</param>
            <param name="streamSeed">seed to search for stream</param>
            <param name="seeds">seeds within stream to start</param>
            <param name="startId">starting ID</param>
            <param name="maxId">maximum ID</param>
            <param name="count">number of streams</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.init_dc(System.UInt32)">
            <summary>
            method to initialize regular MT
            </summary>
            <param name="seed">unsigned integer seed</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.sgenrand_dc(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.org_state,System.UInt32)">
            <summary>
            Initializes the array with a seed.  Method in mt19937.c
            </summary>
            <param name="st">org_state struct</param>
            <param name="seed">seed for generator</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.genrand_dc(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.org_state@)">
            <summary>
            Generates _n words at one time _n=624. Method in mt19937.c
            </summary>
            <param name="st">org_state</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.sgenrand_mt(System.UInt32,Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct@)">
            <summary>
            Initiates mts struct given a seed. Method in genmtrand.c
            </summary>
            <param name="seed">seed for sequence</param>
            <param name="mts">return struct</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.genrand_mt(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct@)">
            <summary>
            Generates uint random number given mts. Method in genmtrand.c
            </summary>
            <param name="mts">mts_struct</param>
            <returns>uint random number</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.init_mt_search(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.check32_t@,Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.prescr_t@,System.Int32,System.Int32)">
            <summary>
            init_genrand_dc(uint s): initializing the array with a seed was in C code but
            not used here
            </summary>
            <summary>
            Used by get_mt_parameter_st to initialize MT search. Method in seive.c
            </summary>
            <param name="ck">check32_t struct</param>
            <param name="pre">prescr_t struct</param>
            <param name="w">destination wordsize: needs to be 31 or 32</param>
            <param name="p">exponent of MT period: needs to be [521-44497]</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.prescreening_dc(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.prescr_t,System.UInt32)">
            <summary>
            Prescreens the dynamic creator
            </summary>
            <param name="pre">prescr_t struct</param>
            <param name="aaa"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.polynomial_mod(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.polynomial@,Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.polynomial)">
            <summary>
            method performs wara.x (an int) mod waru.x (another in), with results stored in wara.x
            </summary>
            <param name="wara">first polynomial</param>
            <param name="waru">second polynomial</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.is_reducible(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.prescr_t,System.UInt32,System.UInt32[])">
            <summary>
            method to determine if polylist is reducible
            </summary>
            <param name="pre">prescr_t struct</param>
            <param name="aaa">uint</param>
            <param name="polylist">polynomial list</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.make_pre_mod_polys(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.prescr_t@,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            method to make prescr_t pre.preModPolys=polynomial[pre.SizeOfA+1] 
            </summary>
            <param name="pre"></param>
            <param name="mm"></param>
            <param name="nn"></param>
            <param name="rr"></param>
            <param name="ww"></param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.polynomial_dup(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.polynomial)">
            <summary>
            method duplicate polynomial 
            </summary>
            <param name="pl">polynomial to be duplicated</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.new_poly(System.Int32)">
            <summary>
            method creates a new polynomial of degree deg
            polynomial members are int[] x and int deg
            </summary>
            <param name="degree">degree of polynomial created</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.get_tempering_parameter_hard_dc(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct@)">
            <summary>
            Initializes tempering eqdeg_t struct and then updates it and
            mt_struct
            </summary>
            <param name="mts">mt_struct</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.init_tempering(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.eqdeg_t@,Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct)">
            <summary>
            Initializes the eqdeg_t struct using the mts struct
            </summary>
            <param name="eq">eqdeg_t struct to be initialized</param>
            <param name="mts">mt_struct used in initialization</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.optimize_v(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.eqdeg_t@,System.UInt32,System.UInt32,System.Int32)">
            <summary>
            Recursive method to update eqdeg_t struct passed in
            </summary>
            <param name="eq">eqdeg_t struct</param>
            <param name="b"></param>
            <param name="c"></param>
            <param name="v">number of nodes in linkedlist</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.optimize_v_hard(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.eqdeg_t@,System.Int32,System.Collections.Generic.LinkedList{Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._mask_node}@)">
            <summary>
            Manipulates the linked list of _mask_nodes
            </summary>
            <param name="eq">eqdeg_t struct</param>
            <param name="v">length of prev_masks</param>
            <param name="prev_masks">linked list of _mask_node structs</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.delete_lower_mask_nodes(System.Collections.Generic.LinkedList{Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister._mask_node}@,System.Int32)">
            <summary>
            delete "l" _mask_nodes in linkedlist from head.  This does not match
            C code because C# has LinkedList.  Parameter "head" gets updated here.
            </summary>
            <param name="head">head of linkedlist to delete from</param>
            <param name="l">number of nodes to delete</param>
            <returns>void</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.get_mt_parameter(System.Int32,System.Int32)">
            <summary>
            There are variants of this method:  Methods in seive.c
            get_mt_parameter(wordSize,periodExponent)
            get_mt_parameter_st(wordSize,periodExponent,originalMTSeed)    
            get_mt_parameters_st(wordSize,periodExponent,startId,maxId,originalMTSeed,count)
            get_mt_parameter_id(wordSize,periodExponent,id) id must be less than 65536 and positive
            get_mt_parameter_id_st(wordSize,periodExponent,id,originalMTSeed) 
            </summary>
            <param name="wordSize">word size: only w=32 or 31 allowed</param>
            <param name="periodExponent">Mersenne exponent: p greater than or equal to 521
            and p less than or equal to 44497</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.get_mt_parameter_st(System.Int32,System.Int32,System.UInt32)">
            <summary>
            There are variants of this method:  Methods in seive.c
            </summary>
            <param name="wordSize">word size: only w=32 or 31 allowed</param>
            <param name="periodExponent">Mersenne exponent that defines period of substream:
            521 greater than or equal to p and p less than or equal to 44497</param>
            <param name="originalMTSeed">seed of original mt19937 to generate parameter</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.get_mt_parameters_st(System.Int32,System.Int32,System.Int32,System.Int32,System.UInt32,System.Int32@)">
            <summary>
            Variant of get_mt_parameter_st for vectors.  Methods in seive.c
            get_mt_parameters_st(w,p,start_id,max_id,seed,count)
            </summary>
            <param name="wordSize">word size: only w=32 or 31 allowed</param>
            <param name="periodExponent">Mersenne exponent: p greater than or equal to 521
            and p less than or equal to 44497</param>
            <param name="startId">starting Id of substreams</param>
            <param name="maxId">ending Id of substreams</param>
            <param name="originalMTSeed">seed of original mt19937 to generate parameter</param>
            <param name="count">number of streams initiated</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.get_mt_parameter_id_st(System.Int32,System.Int32,System.Int32,System.UInt32)">
            <summary>
            There are variants of this method:  Methods in seive.c
            </summary>
            <param name="wordSize">word size: only w=32 or 31 allowed</param>
            <param name="periodExponent">Mersenne exponent: p greater than or equal to 521
            and p less than or equal to 44497</param>
            <param name="id">id of substream: id must be less than 65536 and positive</param>
            <param name="originalMTSeed">seed of original mt19937 to generate parameter</param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.get_irred_param(Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.check32_t,Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.prescr_t,Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.org_state@,Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.mt_struct@,System.Int32,System.Int32)">
            <summary>
            Obtains irreducible parameter
            </summary>
            <param name="ck">check32_t struct</param>
            <param name="pre">prescr_t struct></param>
            <param name="org">org_state struct</param>
            <param name="mts">mt_struct</param>
            <param name="id"></param>
            <param name="idw"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.proper_mersenne_exponent(System.Int32)">
            <summary>
            Checks if specified MT period exponent is valid
            </summary>
            <param name="p">exponent value</param>
            <returns>true:good parameter p, false: bad p specification</returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.DynamicCreatorMersenneTwister.DoSample">
            <summary>
            Returns a random number between 0.0 and 1.0. ONLY NEEDED IF INHERIT MATHNET.NUMERICS
            </summary>
            <returns>
            A double-precision floating point number greater than or equal to 0.0, and less than 1.0.
            </returns>
        </member>
        <member name="T:Vts.MonteCarlo.Rng.MersenneTwisterSerializationInfo">
            <summary>
            Represents the data required for serializing and deserializing
            a Mersenne Twister random number generator
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Rng.MersenneTwisterSerializationInfo.MT">
            <summary>
            unsigned integer variable saved in order to resume series if interrupted
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Rng.MersenneTwisterSerializationInfo.MTI">
            <summary>
            integer variable saved in order to resume series if interrupted
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.Rng.SerializableMersenneTwister">
            <summary>
            This class creates a serializable representation of the Mersenne Twister class.
            Code from MathNet Numerics.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.SerializableMersenneTwister._lower_mask">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.SerializableMersenneTwister._m">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.SerializableMersenneTwister._matrix_a">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.SerializableMersenneTwister._n">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.SerializableMersenneTwister._reciprocal">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.SerializableMersenneTwister._upper_mask">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.Rng.SerializableMersenneTwister._mag01">
            <summary>
            Mersenne twister constant.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.SerializableMersenneTwister.#ctor(System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the MersenneTwister class.
            </summary>
            <param name="seed">The seed value.</param>
            <param name="threadSafe">if set to <c>true</c>, the class is thread safe.</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.SerializableMersenneTwister.#ctor">
            <summary>
            Initializes a new instance of the MersenneTwister class using
            the current time as the seed.
            </summary>
            <remarks>If the seed value is zero, it is set to one. Uses the
            value of Control.ThreadSafeRandomNumberGenerators to
            set whether the instance is thread safe.</remarks>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.SerializableMersenneTwister.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the MersenneTwister class using
            the current time as the seed.
            </summary>
            <param name="threadSafe">if set to <c>true</c> , the class is thread safe.</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.SerializableMersenneTwister.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the MersenneTwister class.
            </summary>
            <param name="seed">The seed value.</param>
            <remarks>Uses the value of MathNet.Numerics.Control.ThreadSafeRandomNumberGenerators to
            set whether the instance is thread safe.</remarks>        
        </member>
        <member name="P:Vts.MonteCarlo.Rng.SerializableMersenneTwister.MT">
            <summary>
            variable within algorithm needed to resume series if interrupts
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.Rng.SerializableMersenneTwister.MTI">
            <summary>
            variable within algorithm needed to resume series if interrupts
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.SerializableMersenneTwister.Create(Vts.MonteCarlo.Rng.MersenneTwisterSerializationInfo)">
            <summary>
            Method to create class using saved sequence info
            </summary>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.SerializableMersenneTwister.init_genrand(System.UInt32)">
            <summary>
            initializes _mt[_n] with a seed
            </summary>
            <param name="s">seed is any 32-bit integer</param>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.SerializableMersenneTwister.genrand_int32">
            <summary>
            generates a random number on[0, 0xffffffff]-interval
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.SerializableMersenneTwister.DoSample">
            <summary>
            Returns a random number between 0.0 and 1.0.
            </summary>
            <returns>
            A double-precision floating point number greater than or equal to 0.0, and less than 1.0.
            </returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.SerializableMersenneTwister.FromFile(System.String)">
            <summary>
            methods to save current state of random number generator
            </summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:Vts.MonteCarlo.Rng.SerializableMersenneTwister.ToFile(Vts.MonteCarlo.Rng.SerializableMersenneTwister,System.String)">
            <summary>
            Method to write pertinent RNG info to file so can restart in sequence
            </summary>
            <param name="smt">class identifier</param>
            <param name="filename">file name to write sequence info</param>
        </member>
        <member name="T:Vts.MonteCarlo.AngleDistributionType">
            <summary>
            Source angle distribution types
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.AngleDistributionType.Collimated">
            <summary>
            Collimated source distribution
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.AngleDistributionType.Isotropic">
            <summary>
            Isotropic source distribution
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.AngleDistributionType.AngleDistributed">
            <summary>
            Angle distributed source distribution
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.BoundaryHitType">
            <summary>
            Flag indicating whether the photon hit a actual tissue boundary or a virtual boundary
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.BoundaryHitType.None">
            <summary>
            No boundary hit
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.BoundaryHitType.Virtual">
            <summary>
            Virtual boundary hit by photon
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.BoundaryHitType.Tissue">
            <summary>
            Actual (tissue) boundary hit by photon
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.CylinderTissueRegionAxisType">
            <summary>
            axis identifier of cylinder tissue region
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.CylinderTissueRegionAxisType.X">
            <summary>
            cylinder center axis along x-axis
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.CylinderTissueRegionAxisType.Y">
            <summary>
            cylinder center axis along y-axis
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.CylinderTissueRegionAxisType.Z">
            <summary>
            cylinder center axis along z-axis
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.DatabaseType">
            <summary>
            This should match VirtualBoundaryType one for one.  Commented out ones have not made
            it to the white list yet.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.DatabaseType.DiffuseReflectance">
            <summary>
            All diffuse reflectance detectors 
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.DatabaseType.DiffuseTransmittance">
            <summary>
            All diffuse transmittance detectors 
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.DatabaseType.SpecularReflectance">
            <summary>
            Specular reflection detectors 
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.DatabaseType.pMCDiffuseReflectance">
            <summary>
            pMC diffuse reflectance
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.DatabaseType.pMCDiffuseTransmittance">
            <summary>
            pMC diffuse transmittance
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.PhotonStateType">
            <summary>
            PhotonStateType is a bitmap of Photon.StateFlag.  Combinations of bits indicate
            the current state of the photon.  These states communicate what to do with the photon.
            ref: http://www.codeproject.com/Articles/37921/Enums-Flags-and-Csharp-Oh-my-bad-pun.aspx
            or http://stackoverflow.com/questions/93744/most-common-c-bitwise-operations
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.None">
            <summary>
            no bits set
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.Alive">
            <summary>
            photon alive
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.ExitedDomain">
            <summary>
            photon exited domain
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.Absorbed">
            <summary>
            photon was absorbed, used only in analog random walk process
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.KilledOverMaximumPathLength">
            <summary>
            photon killed because path length too long
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.KilledOverMaximumCollisions">
            <summary>
            photon killed because number of collisions over maximum
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.KilledRussianRoulette">
            <summary>
            photon killed by Russian Roulette
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.PseudoReflectedTissueBoundary">
            <summary>
            photon pseudo-collision at reflected tissue boundary
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.PseudoTransmittedTissueBoundary">
            <summary>
            photon pseudo-collision at transmitted tissue boundary
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.PseudoSpecularTissueBoundary">
            <summary>
            photon pseudo-collision at specular tissue boundary
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.PseudoBoundingVolumeTissueBoundary">
            <summary>
            photon pseudo-collision at bounding volume boundary
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.PseudoDiffuseReflectanceVirtualBoundary">
            <summary>
            photon pseudo-collision at DiffuseReflectance Virtual Boundary (VB)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.PseudoDiffuseTransmittanceVirtualBoundary">
            <summary>
            photon pseudo-collision at DiffuseTransmittance Virtual Boundary (VB)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.PseudoSpecularReflectanceVirtualBoundary">
            <summary>
            photon pseudo-collision at SpecularReflectance Virtual Boundary (VB)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.PseudoGenericVolumeVirtualBoundary">
            <summary>
            photon pseudo-collision at Generic Volume Virtual Boundary (VB)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.PseudoSurfaceRadianceVirtualBoundary">
            <summary>
            photon pseudo-collision at Dosimetry Virtual Boundary (VB)
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.PhotonStateType.PseudoBoundingCylinderVolumeVirtualBoundary">
            <summary>
            photon pseudo-collision at BoundingVolume Virtual Boundary (VB)
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.SourceOrientationType">
            <summary>
            Orientation types of the source
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.SourceOrientationType.Angled">
            <summary>
            Angled source type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.SourceOrientationType.Normal">
            <summary>
            Normally-oriented source type
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.SourcePositionSamplingType">
            <summary>
            fluorescent source sampling types: using a CDF generated from a PDF or Uniform
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.SourcePositionSamplingType.CDF">
            <summary>
            Sample location using PDF
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.SourcePositionSamplingType.Uniform">
            <summary>
            Sample location uniformly in space
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.SourceProfileType">
            <summary>
            Source beam profile types
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.SourceProfileType.Flat">
            <summary>
            Flat beam source profile
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.SourceProfileType.Gaussian">
            <summary>
            Gaussian beam source profile
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.SourceProfileType.Arbitrary">
            <summary>
            Arbitrary beam source profile
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.SourceType">
            <summary>
            Source types defined organized by dimension and geometric type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.SourceType.BuiltInTypes">
            <summary>
            built in types for sources
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.TallyType">
            <summary>
            detector tally types
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.TallyType.BuiltInTypes">
            <summary>
            built in types for detector tallies
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.SurfaceFiber">
            <summary>
            cylindrical fiber detector
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.RDiffuse">
            <summary>
            Total diffuse reflectance
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.RSpecular">
            <summary>
            Total specular reflectance
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfRho">
            <summary>
            Reflectance as a function of source-detector separation (rho)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfRhoRecessed">
            <summary>
            Reflectance as a function of source-detector separation (rho) recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfAngle">
            <summary>
            Reflectance as a function of angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfRhoAndAngle">
            <summary>
            Reflectance as a function of source-detector separation (rho) and angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfRhoAndTime">
            <summary>
            Reflectance as a function of source-detector separation (rho) and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfRhoAndMaxDepth">
            <summary>
            Reflectance as a function of source-detector separation (rho) and maximum depth attained
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfRhoAndMaxDepthRecessed">
            <summary>
            Reflectance as a function of source-detector separation (rho) and maximum depth attained recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfRhoAndOmega">
            <summary>
            Reflectance as a function of source-detector separation (rho) and temporal-frequency (omega)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfXAndY">
            <summary>
            Reflectance as a function of Cartesian position on the surface of the tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfXAndYRecessed">
            <summary>
            Reflectance as a function of Cartesian position on the surface of the tissue recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfXAndYAndTime">
            <summary>
            Reflectance as a function of Cartesian position on the surface of the tissue and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfXAndYAndTimeRecessed">
            <summary>
            Reflectance as a function of Cartesian position on the surface of the tissue and time recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfXAndYAndMaxDepth">
            <summary>
            Reflectance as a function of Cartesian position on the surface of the tissue and max depth
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfXAndYAndMaxDepthRecessed">
            <summary>
            Reflectance as a function of Cartesian position on the surface of the tissue and max depth recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfFx">
            <summary>
            Reflectance as a function of spatial frequency along the x-axis
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfFxAndTime">
            <summary>
            Reflectance as a function of spatial frequency along the x-axis, and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ROfFxAndAngle">
            <summary>
            Reflectance as a function of spatial frequency along the x-axis, and angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TDiffuse">
            <summary>
            Total diffuse transmittance
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TOfRho">
            <summary>
            Transmittance as a function of source-detector separation (rho)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TOfAngle">
            <summary>
            Transmittance as a function of angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TOfRhoAndAngle">
            <summary>
            Transmittance as a function of source-detector separation (rho) and angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TOfXAndY">
            <summary>
            Transmittance as a function of Cartesian position on the surface of the tissue
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TOfFx">
            <summary>
            Transmittance as a function of spatial frequency (fx)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.FluenceOfRhoAndZ">
            <summary>
            Fluence as a function of source-detector separation (rho) and tissue depth (Z)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.FluenceOfRhoAndZAndTime">
            <summary>
            Fluence as a function of source-detector separation (rho) and tissue depth (Z) and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.FluenceOfXAndYAndZ">
            <summary>
            Fluence as a function of x, y and z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.AOfRhoAndZ">
            <summary>
            Absorbed energy as a function of source-detector separation (rho) and tissue depth (Z)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.AOfXAndYAndZ">
            <summary>
            Absorbed energy as a function of Cartesian coordinates X, Y and Z
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ATotal">
            <summary>
            Total absorbed energy
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ATotalBoundingVolume">
            <summary>
            Total absorbed energy in a bounding volume
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ReflectedMTOfRhoAndSubregionHist">
            <summary>
            Reflected momentum transfer as a function of source-detector separation (rho) and tissue region with histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ReflectedMTOfXAndYAndSubregionHist">
            <summary>
            Reflected momentum transfer as a function of x, y and tissue region with histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TransmittedMTOfRhoAndSubregionHist">
            <summary>
            Reflected momentum transfer as a function of source-detector separation (rho) and tissue region with histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TransmittedMTOfXAndYAndSubregionHist">
            <summary>
            Reflected momentum transfer as a function of x, y and tissue region with histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ReflectedDynamicMTOfRhoAndSubregionHist">
            <summary>
            Reflected dynamic momentum transfer as a function of source-detector separation (rho) and tissue region with histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ReflectedDynamicMTOfXAndYAndSubregionHist">
            <summary>
            Reflected dynamic momentum transfer as a function of x, y and tissue region with histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ReflectedDynamicMTOfFxAndSubregionHist">
            <summary>
            Reflected dynamic momentum transfer as a function of spatial frequency fx and tissue region with histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TransmittedDynamicMTOfRhoAndSubregionHist">
            <summary>
            Transmitted dynamic momentum transfer as a function of rho and tissue region with histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TransmittedDynamicMTOfXAndYAndSubregionHist">
            <summary>
            Transmitted dynamic momentum transfer as a function of x, y and tissue region with histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.TransmittedDynamicMTOfFxAndSubregionHist">
            <summary>
            Transmitted dynamic momentum transfer as a function of fx and tissue region with histogram of MT
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.ReflectedTimeOfRhoAndSubregionHist">
            <summary>
            Reflected subregion time as a function of source-detector separation (rho) and tissue region 
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.RadianceOfRho">
            <summary>
            Surface radiance as a function of source-detector separation (rho)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.RadianceOfRhoAndZAndAngle">
            <summary>
            Volume randiance as a function of source-detector separation (rho), tissue depth (Z) and angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.RadianceOfFxAndZAndAngle">
            <summary>
            Volume randiance as a function of spatial frequency (fx), tissue depth (Z) and angle
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.RadianceOfXAndYAndZAndThetaAndPhi">
            <summary>
            Volume randiance as a function of x, y, z, theta and phi
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.pMCATotal">
            <summary>
            Total absorbed energy
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.pMCROfRho">
            <summary>
            perturbation Monte Carlo (pMC) reflectance as a function of source-detector separation (rho)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.pMCROfRhoRecessed">
            <summary>
            perturbation Monte Carlo (pMC) reflectance as a function of source-detector separation (rho) recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.pMCROfRhoAndTime">
            <summary>
            perturbation Monte Carlo (pMC) reflectance as a function of source-detector sep. (rho) and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.pMCROfRhoAndTimeRecessed">
            <summary>
            perturbation Monte Carlo (pMC) reflectance as a function of source-detector sep. (rho) and time recessed in air
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.pMCROfXAndY">
            <summary>
            perturbation Monte Carlo (pMC) reflectance as a function of Cartesian coordinates (x,y)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.pMCROfFx">
            <summary>
            perturbation Monte Carlo (pMC) reflectance as a function of spatial frequency (fx)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.pMCROfFxAndTime">
            <summary>
            perturbation Monte Carlo (pMC) reflectance as a function of spatial frequency (fx) and time
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.dMCdROfRhodMua">
            <summary>
            differential Monte Carlo (dMC) d(reflectance)/dMua as a function of source-detector separation (rho)
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.TallyType.dMCdROfRhodMus">
            <summary>
            differential Monte Carlo (dMC) d(reflectance)/dMus as a function of source-detector separation (rho) 
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.TissueRegionType">
            <summary>
            Tissue region type, sub-regions of layers
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.TissueRegionType.BuiltInTypes">
            <summary>
            built in types for tissue regions
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.TissueType">
            <summary>
            Tissue types
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.TissueType.BuiltInTypes">
            <summary>
            built in type for tissue
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.VirtualBoundaryType">
            <summary>
            Virtual boundaries are entities upon which detectors are attached.
            Each detector is associated with one and only one of the following types.
            The VBs have a spatial location (surface or volume) and sometimes have
            a direction.
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.VirtualBoundaryType.DiffuseReflectance">
            <summary>
            All diffuse reflectance detectors attach to this virtual boundary type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.VirtualBoundaryType.DiffuseTransmittance">
            <summary>
            All diffuse transmittance detectors attach to this virtual boundary type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.VirtualBoundaryType.SpecularReflectance">
            <summary>
            Specular reflection detectors attach to this virtual boundary type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.VirtualBoundaryType.GenericVolumeBoundary">
            <summary>
            Internal volume detectors attach to this virtual boundary type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.VirtualBoundaryType.Dosimetry">
            <summary>
            Internal dosimetry detectors attach to this virtual boundary type
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.VirtualBoundaryType.pMCDiffuseReflectance">
            <summary>
            Virtual boundary used for pMC diffuse reflectance detectors
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.VirtualBoundaryType.pMCDiffuseTransmittance">
            <summary>
            Virtual boundary used for pMC diffuse transmittance detectors
            </summary>
        </member>
        <member name="F:Vts.MonteCarlo.VirtualBoundaryType.BoundingCylinderVolume">
            <summary>
            Virtual boundary used to capture photons if leave this lateral boundary
            </summary>
        </member>
        <member name="T:Vts.MonteCarlo.VirtualBoundaries.BoundingCylinderVirtualBoundary">
            <summary>
            Implements IVirtualBoundary.  Used to capture all photons absorbed by bounding cylinder
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.BoundingCylinderVirtualBoundary.#ctor(Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetectorController,System.String)">
            <summary>
            diffuse reflectance VB
            </summary>
            <param name="tissue">ITissue</param>
            <param name="detectorController">IDetectorController</param>
            <param name="name">string name</param>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.BoundingCylinderVirtualBoundary.VirtualBoundaryType">
            <summary>
            VirtualBoundaryType enum indicating type of VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.BoundingCylinderVirtualBoundary.PhotonStateType">
            <summary>
            PhotonStateType enum indicating state of photon at this VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.BoundingCylinderVirtualBoundary.Name">
            <summary>
            Name string of VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.BoundingCylinderVirtualBoundary.WillHitBoundary">
            <summary>
            Predicate method to indicate if photon will hit VB boundary
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.BoundingCylinderVirtualBoundary.DetectorController">
            <summary>
            IDetectorController specifying type of detector controller.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.BoundingCylinderVirtualBoundary.GetDistanceToVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            finds distance to VB
            </summary>
            <param name="dp">PhotonDataPoint</param>
            <returns>distance to VB</returns>
        </member>
        <member name="T:Vts.MonteCarlo.VirtualBoundaries.DiffuseReflectanceVirtualBoundary">
            <summary>
            Implements IVirtualBoundary.  Used to capture all diffuse reflectance detectors
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.DiffuseReflectanceVirtualBoundary.#ctor(Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetectorController,System.String)">
            <summary>
            diffuse reflectance VB
            </summary>
            <param name="tissue">ITissue</param>
            <param name="detectorController">IDetectorController</param>
            <param name="name">string name</param>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.DiffuseReflectanceVirtualBoundary.VirtualBoundaryType">
            <summary>
            VirtualBoundaryType enum indicating type of VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.DiffuseReflectanceVirtualBoundary.PhotonStateType">
            <summary>
            PhotonStateType enum indicating state of photon at this VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.DiffuseReflectanceVirtualBoundary.Name">
            <summary>
            Name string of VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.DiffuseReflectanceVirtualBoundary.WillHitBoundary">
            <summary>
            Predicate method to indicate if photon will hit VB boundary
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.DiffuseReflectanceVirtualBoundary.DetectorController">
            <summary>
            IDetectorController specifying type of detector controller.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.DiffuseReflectanceVirtualBoundary.GetDistanceToVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            finds distance to VB
            </summary>
            <param name="dp">PhotonDataPoint</param>
            <returns>distance to VB</returns>
        </member>
        <member name="T:Vts.MonteCarlo.VirtualBoundaries.DiffuseTransmittanceVirtualBoundary">
            <summary>
            Implements IVirtualBoundary.  Used to capture all diffuse transmittance detectors
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.DiffuseTransmittanceVirtualBoundary.#ctor(Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetectorController,System.String)">
            <summary>
            diffuse transmittance VB
            </summary>
            <param name="tissue">ITissue</param>
            <param name="detectorController">IDetectorController</param>
            <param name="name">string name</param>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.DiffuseTransmittanceVirtualBoundary.VirtualBoundaryType">
            <summary>
            VirtualBoundaryType enum indicating type of VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.DiffuseTransmittanceVirtualBoundary.PhotonStateType">
            <summary>
            PhotonStateType enum indicating state of photon at this VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.DiffuseTransmittanceVirtualBoundary.Name">
            <summary>
            Name string of VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.DiffuseTransmittanceVirtualBoundary.WillHitBoundary">
            <summary>
            Predicate method to indicate if photon will hit VB boundary
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.DiffuseTransmittanceVirtualBoundary.DetectorController">
            <summary>
            IDetectorController specifying type of detector controller.
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.DiffuseTransmittanceVirtualBoundary.GetDistanceToVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Finds the distance to the virtual boundary given direction of VB and photon
            </summary>
            <param name="dp">photon data point</param>
        </member>
        <member name="T:Vts.MonteCarlo.VirtualBoundaries.GenericVolumeVirtualBoundary">
            <summary>
            Implements IVirtualBoundary.  Used to capture all internal volume detectors
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.GenericVolumeVirtualBoundary.#ctor(Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetectorController,System.String)">
            <summary>
            generic volume virtual boundary, used to capture all internal volume detectors e.g. FluenceOfRhoAndZ
            </summary>
            <param name="tissue">ITissue</param>
            <param name="detectorController">IDetectorController</param>
            <param name="name">string name</param>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.GenericVolumeVirtualBoundary.VirtualBoundaryType">
            <summary>
            VB type identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.GenericVolumeVirtualBoundary.PhotonStateType">
            <summary>
            photon state type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.GenericVolumeVirtualBoundary.Name">
            <summary>
            string name
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.GenericVolumeVirtualBoundary.WillHitBoundary">
            <summary>
            predicate of PhotonDataPoint determining whether will hit VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.GenericVolumeVirtualBoundary.DetectorController">
            <summary>
            IDetectorController
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.GenericVolumeVirtualBoundary.GetDistanceToVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            finds distance to VB
            </summary>
            <param name="dp">PhotonDataPoint</param>
            <returns>distance</returns>
        </member>
        <member name="T:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseReflectanceVirtualBoundary">
            <summary>
            Implements IVirtualBoundary.  Used to capture all diffuse reflectance detectors
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseReflectanceVirtualBoundary.#ctor(Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetectorController,System.String)">
            <summary>
            class for perturbation Monte Carlo (pMC) diffuse reflectance virtual boundary
            </summary>
            <param name="tissue">ITissue</param>
            <param name="detectorController">IDetectorController</param>
            <param name="name">string name</param>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseReflectanceVirtualBoundary.VirtualBoundaryType">
            <summary>
            VirtualBoundaryType
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseReflectanceVirtualBoundary.PhotonStateType">
            <summary>
            PhotonStateType
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseReflectanceVirtualBoundary.Name">
            <summary>
            string Name
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseReflectanceVirtualBoundary.WillHitBoundary">
            <summary>
            Predicate of PhotonDataPoint
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseReflectanceVirtualBoundary.DetectorController">
            <summary>
            IDetectorController
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseReflectanceVirtualBoundary.GetDistanceToVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Finds the distance to the virtual boundary given direction of VB and photon
            </summary>
            <param name="dp">photon data point</param>
        </member>
        <member name="T:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseTransmittanceVirtualBoundary">
            <summary>
            Implements IVirtualBoundary.  Used to capture all diffuse transmittance detectors
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseTransmittanceVirtualBoundary.#ctor(Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetectorController,System.String)">
            <summary>
            class for perturbation Monte Carlo (pMC) diffuse transmittance virtual boundary
            </summary>
            <param name="tissue">ITissue</param>
            <param name="detectorController">IDetectorController</param>
            <param name="name">string name</param>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseTransmittanceVirtualBoundary.VirtualBoundaryType">
            <summary>
            VirtualBoundaryType
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseTransmittanceVirtualBoundary.PhotonStateType">
            <summary>
            PhotonStateType
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseTransmittanceVirtualBoundary.Name">
            <summary>
            string Name
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseTransmittanceVirtualBoundary.WillHitBoundary">
            <summary>
            Predicate of PhotonDataPoint
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseTransmittanceVirtualBoundary.DetectorController">
            <summary>
            IDetectorController
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.pMCDiffuseTransmittanceVirtualBoundary.GetDistanceToVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Finds the distance to the virtual boundary given direction of VB and photon
            </summary>
            <param name="dp">photon data point</param>
        </member>
        <member name="T:Vts.MonteCarlo.VirtualBoundaries.RadianceVirtualBoundary">
            <summary>
            Implements IVirtualBoundary.  Used to capture surface radiance detectors
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.RadianceVirtualBoundary.#ctor(Vts.MonteCarlo.IDetectorController,System.String)">
            <summary>
            Radiance virtual boundary
            </summary>
            <param name="detectorController">IDetectorController</param>
            <param name="name">string name</param>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.RadianceVirtualBoundary.VirtualBoundaryType">
            <summary>
            VirtualBoundaryType
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.RadianceVirtualBoundary.PhotonStateType">
            <summary>
            PhotonStateType
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.RadianceVirtualBoundary.Name">
            <summary>
            Name
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.RadianceVirtualBoundary.WillHitBoundary">
            <summary>
            predicate of PhotonDataPoint providing whether photon will hit VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.RadianceVirtualBoundary.DetectorController">
            <summary>
            IDetectorController
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.RadianceVirtualBoundary.GetDistanceToVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Finds the distance to the virtual boundary given direction of VB and photon
            </summary>
            <param name="dp">photo data point</param>
        </member>
        <member name="T:Vts.MonteCarlo.VirtualBoundaries.SpecularReflectanceVirtualBoundary">
            <summary>
            Implements IVirtualBoundary.  Used to capture specular reflectance detectors
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.SpecularReflectanceVirtualBoundary.#ctor(Vts.MonteCarlo.ITissue,Vts.MonteCarlo.IDetectorController,System.String)">
            <summary>
            specular reflectance virtual boundary
            </summary>
            <param name="tissue">ITissue</param>
            <param name="detectorController">IDetectorController</param>
            <param name="name">string name</param>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.SpecularReflectanceVirtualBoundary.VirtualBoundaryType">
            <summary>
            virtual boundary type identifier
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.SpecularReflectanceVirtualBoundary.PhotonStateType">
            <summary>
            photon state type
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.SpecularReflectanceVirtualBoundary.Name">
            <summary>
            string name of VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.SpecularReflectanceVirtualBoundary.WillHitBoundary">
            <summary>
            predicate of PhotonDataPoint whether photon will hit VB
            </summary>
        </member>
        <member name="P:Vts.MonteCarlo.VirtualBoundaries.SpecularReflectanceVirtualBoundary.DetectorController">
            <summary>
            IDetectorController
            </summary>
        </member>
        <member name="M:Vts.MonteCarlo.VirtualBoundaries.SpecularReflectanceVirtualBoundary.GetDistanceToVirtualBoundary(Vts.MonteCarlo.PhotonData.PhotonDataPoint)">
            <summary>
            Finds the distance to the virtual boundary given direction of VB and photon
            </summary>
            <param name="dp">PhotonDataPoint</param>
            <returns>distance to VB</returns>
        </member>
    </members>
</doc>
